<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Tree Builder - Tanh Style Scoring</title>
    <style>
        :root {
            /* GSU Official Brand Colors 2025 */
            --gsu-primary: #0039A6;      /* Official GSU Blue */
            --gsu-cool: #000000;         /* Black */
            --gsu-vibrant: #00AEEF;      /* Vibrant Blue */
            --gsu-accent: #CC0000;       /* Red Accent */
            --gsu-light-blue: #97CAEB;   /* Light Blue */

            /* Legacy support */
            --gsu-blue: #0039A6;
            --gsu-blue-light: #0071CE;
            --gsu-blue-dark: #002d85;
            --gsu-success: #10B981;
            --gsu-warning: #F59E0B;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--gsu-primary) 0%, var(--gsu-cool) 30%, var(--gsu-vibrant) 70%, #3F3F46 100%);
            background-attachment: fixed;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0, 57, 166, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 80% 20%, rgba(0, 113, 206, 0.12) 0%, transparent 60%),
                radial-gradient(circle at 40% 60%, rgba(0, 174, 239, 0.08) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundFloat 30s ease-in-out infinite;
            opacity: 0.8;
        }

        @keyframes backgroundFloat {
            0%, 100% { 
                transform: translateY(0px) translateX(0px) rotate(0deg);
                opacity: 0.8;
            }
            25% { 
                transform: translateY(-10px) translateX(5px) rotate(0.5deg);
                opacity: 0.9;
            }
            50% { 
                transform: translateY(5px) translateX(-5px) rotate(-0.5deg);
                opacity: 0.7;
            }
            75% { 
                transform: translateY(-5px) translateX(-10px) rotate(0.3deg);
                opacity: 0.85;
            }
        }

        .container {
            max-width: 1400px;
            width: 100%;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 57, 166, 0.12);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            color: #52525B;
            margin-bottom: 30px;
            font-size: 1.2em;
            font-weight: 500;
        }

        #tree-container {
            width: 100%;
            height: 600px;
            border: 2px solid rgba(0, 57, 166, 0.1);
            border-radius: 16px;
            overflow: hidden;
            position: relative;
            background: linear-gradient(to bottom, rgba(0, 57, 166, 0.02), rgba(255, 255, 255, 0.98));
            box-shadow: inset 0 2px 8px rgba(0, 57, 166, 0.05);
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node rect {
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .node:hover rect {
            filter: brightness(1.1);
            stroke-width: 3px;
        }

        .node text {
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
        }

        .node .question {
            font-weight: 600;
            fill: white;
        }

        .node .score {
            font-size: 14px;
            font-weight: bold;
            fill: white;
        }

        .node .threshold {
            font-size: 10px;
            fill: rgba(255, 255, 255, 0.8);
        }

        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
            stroke-dasharray: 5,5;
            animation: dash 20s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -100;
            }
        }

        .link.positive {
            stroke: #4CAF50;
            stroke-width: 3px;
        }

        .link.negative {
            stroke: #f44336;
            stroke-width: 2px;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        input[type="number"], select {
            padding: 8px;
            border: 2px solid rgba(0, 57, 166, 0.2);
            border-radius: 8px;
            font-size: 14px;
            width: 150px;
            transition: all 0.3s ease;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--gsu-vibrant);
            box-shadow: 0 0 0 3px rgba(0, 174, 239, 0.1);
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant));
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 57, 166, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 57, 166, 0.3);
            background: linear-gradient(135deg, var(--gsu-blue-light), var(--gsu-vibrant));
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 57, 166, 0.2);
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0, 57, 166, 0.03), rgba(255, 255, 255, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(0, 57, 166, 0.1);
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-box {
            width: 30px;
            height: 20px;
            border-radius: 5px;
        }

        .score-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 57, 166, 0.15);
            border: 1px solid rgba(0, 57, 166, 0.1);
            backdrop-filter: blur(8px);
        }

        .path-highlight {
            stroke: #FFD700 !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
        }

        .builder-panel {
            position: fixed;
            right: 20px;
            top: 100px;
            width: 350px;
            max-height: 70vh;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 57, 166, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 57, 166, 0.1);
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
        }

        .builder-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(0, 57, 166, 0.1);
        }

        .builder-section:last-child {
            border-bottom: none;
        }

        .builder-section h3 {
            margin-bottom: 10px;
            color: var(--gsu-primary);
            font-weight: 600;
        }

        .node-input-group {
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(to bottom, rgba(0, 57, 166, 0.02), rgba(255, 255, 255, 0.98));
            border-radius: 10px;
            border: 1px solid rgba(0, 57, 166, 0.08);
        }

        .node-input-group input,
        .node-input-group select {
            width: 100%;
            margin: 5px 0;
        }

        .node-input-group label {
            display: block;
            margin-top: 5px;
        }

        .add-node-btn {
            width: 100%;
            background: linear-gradient(135deg, var(--gsu-success), #0ec775);
        }

        .remove-node-btn {
            background: linear-gradient(135deg, var(--gsu-accent), #ff3333);
            padding: 5px 10px;
            font-size: 12px;
            float: right;
        }

        .layer-container {
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(to bottom, rgba(151, 202, 235, 0.08), rgba(255, 255, 255, 0.95));
            border-radius: 12px;
            border: 1px solid rgba(0, 57, 166, 0.08);
        }

        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .layer-title {
            font-weight: bold;
            color: var(--gsu-primary);
        }

        .node-badge {
            background: linear-gradient(135deg, var(--gsu-vibrant), var(--gsu-light-blue));
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0, 57, 166, 0.2);
        }

        .selected-node {
            stroke: #FFD700 !important;
            stroke-width: 4px !important;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            background: rgba(0, 57, 166, 0.05);
            border: 1px solid rgba(0, 57, 166, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn:hover {
            background: rgba(0, 57, 166, 0.1);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant));
            color: white;
            border-color: transparent;
        }

        .import-export-btns {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .import-export-btns button {
            flex: 1;
            padding: 8px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Decision Tree Builder</h1>
        <div class="subtitle" id="scale-subtitle">Bipolar Scale: -5 (Very Poor) to +5 (Industry Leader)</div>
        
        <div id="tree-container">
            <svg id="tree-svg"></svg>
            <div class="score-display">
                <strong>Current Path Score:</strong> <span id="current-score">0.00</span>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Scale Type:</label>
                <select id="scale-type" onchange="updateScaleType()" style="padding: 8px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 8px; background: white;">
                    <option value="-5,5">-5 to +5 (11 points)</option>
                    <option value="-3,3">-3 to +3 (7 points)</option>
                    <option value="-2,2">-2 to +2 (5 points)</option>
                    <option value="0,10">0 to 10 (11 points)</option>
                    <option value="0,7">0 to 7 (8 points)</option>
                    <option value="1,7">1 to 7 (7 points)</option>
                    <option value="1,5">1 to 5 (5 points)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Visualization:</label>
                <select id="viz-mode" onchange="changeVisualization()">
                    <option value="standard">Standard Tree</option>
                    <option value="distribution">Score Distribution</option>
                    <option value="heatmap">Path Heatmap</option>
                    <option value="tanh">Tanh Curve</option>
                    <option value="radial">Radial Layout</option>
                    <option value="clustering">Clustering Analysis</option>
                </select>
            </div>
            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="allow-decimals" onchange="updateDecimalPrecision()">
                    Allow Decimal Values
                </label>
            </div>
            <button onclick="toggleBuilder()">Toggle Builder</button>
            <button onclick="toggleSettings()">Settings</button>
            <button onclick="resetPath()">Reset Path</button>
            <button onclick="runSurvey()">Run Survey</button>
            <button onclick="uploadSurveyData()">Upload Survey Data</button>
            <button onclick="showStatisticalAnalysis()">Statistical Analysis</button>
            <button onclick="saveTreeConfiguration()">Save Tree</button>
            <button onclick="loadTreeConfiguration()">Load Tree</button>
            <button onclick="showTreeTemplates()" style="background: linear-gradient(135deg, #0039A6, #00AEEF);">📋 Templates</button>
            <button onclick="showABTestingPanel()" style="background: linear-gradient(135deg, #00AEEF, #CC0000);">🔬 A/B Testing</button>
            <button onclick="showMappingTemplates()" style="background: linear-gradient(135deg, #0039A6, #97CAEB);">🗂️ Import Templates</button>
            <button onclick="showShannonAnalysis()">Shannon Information Theory</button>
            <input type="file" id="survey-data-file" style="display: none;" accept=".csv,.json" onchange="processSurveyDataFile(event)">
            <input type="file" id="tree-config-file" style="display: none;" accept=".json" onchange="processTreeConfigFile(event)">
        </div>

        <div class="legend" id="color-legend">
            <!-- Legend will be dynamically updated based on color scale -->
        </div>
    </div>

    <!-- Score Input Modal -->
    <div id="score-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 20px; width: 500px; box-shadow: 0 20px 40px rgba(0, 57, 166, 0.3); border: 1px solid rgba(0, 57, 166, 0.1);">
            <h2 id="modal-question" style="margin-bottom: 20px; background: linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;"></h2>
            <p id="scale-description" style="color: #666; margin-bottom: 20px;">Please rate on the selected scale</p>
            
            <div style="margin: 30px 0;">
                <input type="range" id="score-slider" min="-5" max="5" step="1" value="0" style="width: 100%;">
                <div id="scale-labels" style="display: flex; justify-content: space-between; margin-top: 10px;">
                    <!-- Will be dynamically filled based on scale -->
                </div>
            </div>
            
            <div style="text-align: center; margin: 20px 0;">
                <span style="font-size: 48px; font-weight: bold; color: #333;" id="score-display">0</span>
            </div>
            
            <div style="margin-top: 20px;">
                <label>Or enter exact value:</label>
                <input type="number" id="score-input" min="-5" max="5" step="1" value="0" style="width: 100%; padding: 10px; font-size: 16px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 8px; transition: all 0.3s ease;">
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 30px;">
                <button onclick="cancelScoreInput()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #71717A, #52525B); color: white; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; transition: all 0.3s ease;">Cancel</button>
                <button onclick="submitScore()" style="flex: 2; padding: 12px; background: linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant)); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0, 57, 166, 0.3);">Submit Score</button>
            </div>
        </div>
    </div>

    <!-- Builder Panel -->
    <div class="builder-panel" id="builder-panel" style="display: none;">
        <h2>Tree Builder</h2>
        
        <div class="mode-toggle">
            <button class="mode-btn active" onclick="setBuilderMode('build')">Build Mode</button>
            <button class="mode-btn" onclick="setBuilderMode('test')">Test Mode</button>
        </div>

        <div class="builder-section">
            <h3>Tree Layers</h3>
            <div id="layers-container"></div>
            <button class="add-node-btn" onclick="addLayer()">Add New Layer</button>
        </div>

        <div class="builder-section">
            <h3>Selected Node</h3>
            <div id="selected-node-info">
                <p style="color: #999;">Click a node to edit</p>
            </div>
        </div>

        <div class="builder-section">
            <div class="import-export-btns">
                <button onclick="exportTree()">Export Tree</button>
                <button onclick="importTree()">Import Tree</button>
            </div>
            <input type="file" id="import-file" style="display: none;" accept=".json">
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="builder-panel" id="settings-panel" style="display: none;">
        <h2 style="background: linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">Settings & Advanced Features</h2>
        
        <div class="builder-section">
            <h3>Export Options</h3>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button onclick="exportVisualizationAsPNG()" style="padding: 10px; background: linear-gradient(135deg, #0039A6, #4B9BFF); color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Export Visualization as PNG
                </button>
                <button onclick="exportVisualizationAsPDF()" style="padding: 10px; background: linear-gradient(135deg, #0039A6, #4B9BFF); color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Export Visualization as PDF
                </button>
                <button onclick="exportFullReport()" style="padding: 10px; background: linear-gradient(135deg, #CC0033, #FF6B6B); color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Generate Full Report (PDF)
                </button>
            </div>
        </div>

        <div class="builder-section">
            <h3>Analysis Tools</h3>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button onclick="compareDatasets()" style="padding: 10px; background: linear-gradient(135deg, #45B7D1, #0039A6); color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Compare Multiple Datasets
                </button>
                <button onclick="showNodeSearch()" style="padding: 10px; background: linear-gradient(135deg, #45B7D1, #0039A6); color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Search & Filter Nodes
                </button>
                <button onclick="showAdvancedMetrics()" style="padding: 10px; background: linear-gradient(135deg, #45B7D1, #0039A6); color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Advanced Metrics Dashboard
                </button>
            </div>
        </div>

        <div class="builder-section">
            <h3>History & Undo</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button onclick="undoAction()" id="undo-btn" style="flex: 1; padding: 10px; background: #71717A; color: white; border: none; border-radius: 8px; cursor: pointer;" disabled>
                    ← Undo
                </button>
                <button onclick="redoAction()" id="redo-btn" style="flex: 1; padding: 10px; background: #71717A; color: white; border: none; border-radius: 8px; cursor: pointer;" disabled>
                    Redo →
                </button>
            </div>
            <div id="history-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px;">
                <p style="color: #999; text-align: center;">No actions yet</p>
            </div>
        </div>

        <div class="builder-section">
            <h3>Collaboration</h3>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button onclick="shareTree()" style="padding: 10px; background: linear-gradient(135deg, #10B981, #059669); color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Share Tree (Generate Link)
                </button>
                <button onclick="exportForCollaboration()" style="padding: 10px; background: linear-gradient(135deg, #10B981, #059669); color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Export for Team Collaboration
                </button>
                <div style="margin-top: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="auto-save" onchange="toggleAutoSave()">
                        Enable Auto-Save (every 30 seconds)
                    </label>
                </div>
            </div>
        </div>

        <div class="builder-section">
            <h3>Display Preferences</h3>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <label>
                    Node Size:
                    <input type="range" id="node-size-slider" min="50" max="200" value="120" onchange="updateNodeSize(this.value)" style="width: 100%;">
                </label>
                <label>
                    Animation Speed:
                    <input type="range" id="animation-speed" min="0" max="2000" value="500" onchange="updateAnimationSpeed(this.value)" style="width: 100%;">
                </label>
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="show-tooltips" checked onchange="toggleTooltips()">
                    Show Tooltips
                </label>
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="show-grid" onchange="toggleGrid()">
                    Show Grid
                </label>
            </div>
        </div>
    </div>

    <script>
        // Step 1: Enhanced Decision Node class for research survey
        class DecisionNode {
            constructor(question, depth = 0, id = null, threshold = 0, score = 0) {
                this.id = id || `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.question = question;
                this.depth = depth;
                this.threshold = threshold;
                this.thresholdMode = 'manual'; // 'manual', 'mean', 'median', 'percentile'
                this.score = score;
                this.isTerminal = false;
                this.x = 0;
                this.y = 0;
                this.parentId = null;
                this.left = null;
                this.leftId = null;
                this.right = null;
                this.rightId = null;
                this.userScore = null;
            }

            evaluate() {
                const userInput = prompt(`${this.question}\nEnter score (-5 to 5):`);
                const userScore = parseFloat(userInput);
                if (isNaN(userScore) || userScore < -5 || userScore > 5) {
                    alert('Invalid score');
                    return null;
                }
                this.userScore = userScore;
                return userScore >= this.threshold;
            }

            getColor() {
                const s = this.userScore !== null ? this.userScore : this.score;
                // Use adaptive color scale
                return getColorForValue(s, currentColorScale);
            }
        }

        // Tree Builder System
        class TreeBuilder {
            constructor() {
                this.layers = [];
                this.nodes = new Map();
                this.selectedNode = null;
                this.mode = 'build'; // 'build' or 'test'
            }

            addLayer() {
                const layerIndex = this.layers.length;
                const layer = {
                    index: layerIndex,
                    nodes: []
                };
                this.layers.push(layer);
                this.updateLayersDisplay();
                return layer;
            }

            addNodeToLayer(layerIndex, question = '', threshold = 0, score = null) {
                if (layerIndex >= this.layers.length) {
                    for (let i = this.layers.length; i <= layerIndex; i++) {
                        this.addLayer();
                    }
                }

                score = score ?? 0;

                const node = new DecisionNode(
                    question || `Layer ${layerIndex} Node ${this.layers[layerIndex].nodes.length + 1}`,
                    layerIndex,
                    null,
                    threshold,
                    score
                );

                this.layers[layerIndex].nodes.push(node);
                this.nodes.set(node.id, node);

                // Auto-connect to parent if only one node in previous layer
                if (layerIndex > 0 && this.layers[layerIndex - 1].nodes.length === 1) {
                    const parentNode = this.layers[layerIndex - 1].nodes[0];
                    if (!parentNode.left) {
                        parentNode.left = node;
                        parentNode.leftId = node.id;
                        node.parentId = parentNode.id;
                    } else if (!parentNode.right) {
                        parentNode.right = node;
                        parentNode.rightId = node.id;
                        node.parentId = parentNode.id;
                    }
                }

                this.updateLayersDisplay();
                return node;
            }

            removeNode(nodeId) {
                const node = this.nodes.get(nodeId);
                if (!node) return;

                // Remove from layer
                const layer = this.layers[node.depth];
                layer.nodes = layer.nodes.filter(n => n.id !== nodeId);

                // Remove connections
                this.nodes.forEach(n => {
                    if (n.leftId === nodeId) {
                        n.left = null;
                        n.leftId = null;
                    }
                    if (n.rightId === nodeId) {
                        n.right = null;
                        n.rightId = null;
                    }
                });

                this.nodes.delete(nodeId);
                this.updateLayersDisplay();
                visualizeTree();
            }

            connectNodes(parentId, childId, branch) {
                const parent = this.nodes.get(parentId);
                const child = this.nodes.get(childId);

                if (!parent || !child) return;

                if (branch === 'left') {
                    parent.left = child;
                    parent.leftId = childId;
                } else {
                    parent.right = child;
                    parent.rightId = childId;
                }

                child.parentId = parentId;
                visualizeTree();
            }

            updateNodeProperties(nodeId, properties) {
                const node = this.nodes.get(nodeId);
                if (!node) return;

                Object.assign(node, properties);
                visualizeTree();
            }

            buildTreeFromLayers() {
                if (this.layers.length === 0 || this.layers[0].nodes.length === 0) {
                    return null;
                }
                // Return the root node which should have all connections
                return this.layers[0].nodes[0];
            }

            exportTreeData() {
                const treeData = {
                    layers: this.layers.map(layer => ({
                        index: layer.index,
                        nodes: layer.nodes.map(node => ({
                            id: node.id,
                            question: node.question,
                            threshold: node.threshold,
                            thresholdMode: node.thresholdMode || 'manual',
                            score: node.score,
                            leftId: node.leftId,
                            rightId: node.rightId,
                            isTerminal: node.isTerminal
                        }))
                    }))
                };
                return treeData;
            }

            importTreeData(data) {
                this.layers = [];
                this.nodes.clear();

                data.layers.forEach(layerData => {
                    const layer = { index: layerData.index, nodes: [] };

                    layerData.nodes.forEach(nodeData => {
                        const node = new DecisionNode(
                            nodeData.question,
                            layerData.index,
                            nodeData.id,
                            nodeData.threshold,
                            nodeData.score
                        );
                        node.leftId = nodeData.leftId;
                        node.rightId = nodeData.rightId;
                        node.isTerminal = nodeData.isTerminal;
                        node.thresholdMode = nodeData.thresholdMode || 'manual';

                        layer.nodes.push(node);
                        this.nodes.set(node.id, node);
                    });

                    this.layers.push(layer);
                });

                // Rebuild connections
                this.nodes.forEach(node => {
                    if (node.leftId) {
                        node.left = this.nodes.get(node.leftId);
                    }
                    if (node.rightId) {
                        node.right = this.nodes.get(node.rightId);
                    }
                });

                this.updateLayersDisplay();
                visualizeTree();
            }

            updateLayersDisplay() {
                const container = document.getElementById('layers-container');
                container.innerHTML = '';

                this.layers.forEach((layer, index) => {
                    const layerDiv = document.createElement('div');
                    layerDiv.className = 'layer-container';

                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'layer-header';
                    headerDiv.innerHTML = `
                        <span class="layer-title">Layer ${index}</span>
                        <span class="node-badge">${layer.nodes.length} nodes</span>
                    `;
                    layerDiv.appendChild(headerDiv);

                    layer.nodes.forEach(node => {
                        const nodeDiv = document.createElement('div');
                        nodeDiv.className = 'node-input-group';
                        
                        // Get available parent nodes from previous layer
                        const parentOptions = index > 0 ? 
                            this.layers[index - 1].nodes.map(n => 
                                `<option value="${n.id}">${n.question.substring(0, 30)}</option>`
                            ).join('') : '';

                        nodeDiv.innerHTML = `
                            <input type="text" placeholder="Question" value="${node.question}"
                                onchange="treeBuilder.updateNodeProperties('${node.id}', {question: this.value})">
                            <label>Default Score (${currentScaleMin} to ${currentScaleMax}) for testing:</label>
                            <input type="number" min="${currentScaleMin}" max="${currentScaleMax}" step="${allowDecimals ? '0.1' : '1'}" value="${node.score || ((currentScaleMin + currentScaleMax) / 2)}"
                                onchange="treeBuilder.updateNodeProperties('${node.id}', {score: parseFloat(this.value)})">
                            <label>Threshold Mode:</label>
                            <select id="threshold-mode-${node.id}" onchange="updateThresholdMode('${node.id}', this.value)">
                                <option value="manual" ${node.thresholdMode === 'manual' ? 'selected' : ''}>Manual</option>
                                <option value="mean" ${node.thresholdMode === 'mean' ? 'selected' : ''}>Mean of Responses</option>
                                <option value="median" ${node.thresholdMode === 'median' ? 'selected' : ''}>Median of Responses</option>
                                <option value="percentile" ${node.thresholdMode === 'percentile' ? 'selected' : ''}>Percentile (75th)</option>
                            </select>
                            <label>Threshold (triggers right branch if score ≥ threshold):</label>
                            <input type="number" id="threshold-value-${node.id}" min="${currentScaleMin}" max="${currentScaleMax}" step="${allowDecimals ? '0.1' : '1'}" 
                                value="${node.threshold}" ${node.thresholdMode !== 'manual' ? 'disabled' : ''}
                                onchange="treeBuilder.updateNodeProperties('${node.id}', {threshold: parseFloat(this.value)})">
                            ${node.thresholdMode !== 'manual' ? `<small style="color: var(--gsu-primary);">Auto-calculated: ${node.threshold.toFixed(2)}</small>` : ''}
                            ${index > 0 ? `
                                <label>Connect as LEFT branch (score < threshold) of:</label>
                                <select onchange="treeBuilder.setNodeAsLeftChild('${node.id}', this.value)">
                                    <option value="">-- Select Parent Node --</option>
                                    ${parentOptions}
                                </select>
                                <label>Connect as RIGHT branch (score ≥ threshold) of:</label>
                                <select onchange="treeBuilder.setNodeAsRightChild('${node.id}', this.value)">
                                    <option value="">-- Select Parent Node --</option>
                                    ${parentOptions}
                                </select>
                            ` : '<label>Root Node</label>'}
                            <label>Terminal Node:</label>
                            <input type="checkbox" ${node.isTerminal ? 'checked' : ''}
                                onchange="treeBuilder.updateNodeProperties('${node.id}', {isTerminal: this.checked})">
                            <button class="remove-node-btn" onclick="treeBuilder.removeNode('${node.id}')">Remove</button>
                        `;
                        nodeDiv.onclick = (e) => {
                            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT') {
                                this.selectNode(node.id);
                            }
                        };
                        layerDiv.appendChild(nodeDiv);
                    });

                    const addNodeBtn = document.createElement('button');
                    addNodeBtn.textContent = `Add Node to Layer ${index}`;
                    addNodeBtn.style.width = '100%';
                    addNodeBtn.style.marginTop = '10px';
                    addNodeBtn.onclick = () => this.addNodeToLayer(index);
                    layerDiv.appendChild(addNodeBtn);

                    container.appendChild(layerDiv);
                });
            }

            setNodeAsLeftChild(childId, parentId) {
                if (!parentId) return;
                
                const parent = this.nodes.get(parentId);
                const child = this.nodes.get(childId);
                
                if (!parent || !child) return;
                
                // Clear any existing connection to this child
                this.nodes.forEach(node => {
                    if (node.leftId === childId) {
                        node.left = null;
                        node.leftId = null;
                    }
                    if (node.rightId === childId) {
                        node.right = null;
                        node.rightId = null;
                    }
                });
                
                // Set new connection
                parent.left = child;
                parent.leftId = childId;
                child.parentId = parentId;
                
                this.updateLayersDisplay();
                visualizeTree();
            }

            setNodeAsRightChild(childId, parentId) {
                if (!parentId) return;
                
                const parent = this.nodes.get(parentId);
                const child = this.nodes.get(childId);
                
                if (!parent || !child) return;
                
                // Clear any existing connection to this child
                this.nodes.forEach(node => {
                    if (node.leftId === childId) {
                        node.left = null;
                        node.leftId = null;
                    }
                    if (node.rightId === childId) {
                        node.right = null;
                        node.rightId = null;
                    }
                });
                
                // Set new connection
                parent.right = child;
                parent.rightId = childId;
                child.parentId = parentId;
                
                this.updateLayersDisplay();
                visualizeTree();
            }

            selectNode(nodeId) {
                this.selectedNode = this.nodes.get(nodeId);
                this.updateSelectedNodeDisplay();

                // Highlight selected node in visualization
                document.querySelectorAll('.node rect').forEach(rect => {
                    rect.classList.remove('selected-node');
                });

                const nodeElement = document.getElementById(`node-${nodeId}`);
                if (nodeElement) {
                    nodeElement.querySelector('rect').classList.add('selected-node');
                }
            }

            updateSelectedNodeDisplay() {
                const container = document.getElementById('selected-node-info');
                if (!this.selectedNode) {
                    container.innerHTML = '<p style="color: #999;">Click a node to edit</p>';
                    return;
                }

                const node = this.selectedNode;
                const availableNodes = Array.from(this.nodes.values())
                    .filter(n => n.depth === node.depth + 1);

                container.innerHTML = `
                    <div>
                        <strong>${node.question}</strong><br>
                        Score: ${node.score.toFixed(1)}<br>
                        Threshold: ${node.threshold}<br>
                        <br>
                        <label>Left Branch (Score < ${node.threshold}):</label>
                        <select onchange="treeBuilder.connectNodes('${node.id}', this.value, 'left')">
                            <option value="">None</option>
                            ${availableNodes.map(n =>
                                `<option value="${n.id}" ${node.leftId === n.id ? 'selected' : ''}>${n.question}</option>`
                            ).join('')}
                        </select>
                        <br><br>
                        <label>Right Branch (Score ≥ ${node.threshold}):</label>
                        <select onchange="treeBuilder.connectNodes('${node.id}', this.value, 'right')">
                            <option value="">None</option>
                            ${availableNodes.map(n =>
                                `<option value="${n.id}" ${node.rightId === n.id ? 'selected' : ''}>${n.question}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            }
        }

        // Adaptive Color Scales System
        const colorScales = {
            // -5 to +5 (Bipolar with zero center)
            'bipolar_5': {
                range: [-5, 5],
                colors: [
                    { value: -5, color: '#CC0000', label: 'Very Poor' },        // Deep Red
                    { value: -4, color: '#E53935', label: 'Poor' },             // Red
                    { value: -3, color: '#FF6B6B', label: 'Below Average' },    // Light Red
                    { value: -2, color: '#FFA726', label: 'Somewhat Below' },   // Orange
                    { value: -1, color: '#FFD54F', label: 'Slightly Below' },   // Light Orange
                    { value: 0, color: '#FFF59D', label: 'Average' },           // Yellow (neutral)
                    { value: 1, color: '#C5E1A5', label: 'Slightly Above' },    // Light Green
                    { value: 2, color: '#81C784', label: 'Somewhat Above' },    // Green
                    { value: 3, color: '#4FC3F7', label: 'Above Average' },     // Light Blue
                    { value: 4, color: '#0039A6', label: 'Good' },              // GSU Blue
                    { value: 5, color: '#00AEEF', label: 'Industry Leader' }    // Vibrant Blue
                ]
            },

            // 0 to 7 (Unipolar positive)
            'unipolar_7': {
                range: [0, 7],
                colors: [
                    { value: 0, color: '#E0E0E0', label: 'None/Never' },        // Gray
                    { value: 1, color: '#FFCDD2', label: 'Very Low' },          // Very Light Red
                    { value: 2, color: '#FFAB91', label: 'Low' },               // Light Orange
                    { value: 3, color: '#FFE082', label: 'Slightly Low' },      // Light Yellow
                    { value: 4, color: '#C5E1A5', label: 'Moderate' },          // Light Green
                    { value: 5, color: '#81C784', label: 'High' },              // Green
                    { value: 6, color: '#4FC3F7', label: 'Very High' },         // Light Blue
                    { value: 7, color: '#0039A6', label: 'Excellent' }          // GSU Blue
                ]
            },

            // -3 to +3 (Compact bipolar)
            'bipolar_3': {
                range: [-3, 3],
                colors: [
                    { value: -3, color: '#CC0000', label: 'Strongly Negative' }, // Deep Red
                    { value: -2, color: '#FF6B6B', label: 'Negative' },          // Light Red
                    { value: -1, color: '#FFA726', label: 'Slightly Negative' }, // Orange
                    { value: 0, color: '#FFF59D', label: 'Neutral' },            // Yellow
                    { value: 1, color: '#81C784', label: 'Slightly Positive' },  // Light Green
                    { value: 2, color: '#4FC3F7', label: 'Positive' },           // Light Blue
                    { value: 3, color: '#0039A6', label: 'Strongly Positive' }   // GSU Blue
                ]
            },

            // 1 to 5 (Traditional Likert)
            'likert_5': {
                range: [1, 5],
                colors: [
                    { value: 1, color: '#CC0000', label: 'Strongly Disagree' },  // Red
                    { value: 2, color: '#FFA726', label: 'Disagree' },           // Orange
                    { value: 3, color: '#FFF59D', label: 'Neutral' },            // Yellow
                    { value: 4, color: '#81C784', label: 'Agree' },              // Green
                    { value: 5, color: '#0039A6', label: 'Strongly Agree' }      // GSU Blue
                ]
            },

            // 0 to 10 (Extended scale)
            'scale_10': {
                range: [0, 10],
                colors: [
                    { value: 0, color: '#CC0000', label: 'Worst' },
                    { value: 2, color: '#FF6B6B', label: 'Very Poor' },
                    { value: 4, color: '#FFD54F', label: 'Below Average' },
                    { value: 5, color: '#FFF59D', label: 'Average' },
                    { value: 6, color: '#C5E1A5', label: 'Above Average' },
                    { value: 8, color: '#4FC3F7', label: 'Very Good' },
                    { value: 10, color: '#00AEEF', label: 'Best' }
                ]
            }
        };

        // Current active scale
        let currentColorScale = 'bipolar_5';
        let allowDecimals = false; // Default to integers only

        // Auto-detect data range from survey data
        function detectDataRange(data) {
            if (!data || data.length === 0) return 'bipolar_5';
            
            // Flatten all numeric values
            const allValues = [];
            data.forEach(response => {
                Object.values(response).forEach(val => {
                    if (typeof val === 'number' && !isNaN(val)) {
                        allValues.push(val);
                    }
                });
            });

            if (allValues.length === 0) return 'bipolar_5';

            const min = Math.min(...allValues);
            const max = Math.max(...allValues);
            
            // Detect which scale matches best
            if (min >= -5.5 && max <= 5.5 && min < 0) {
                return 'bipolar_5';
            } else if (min >= -3.5 && max <= 3.5 && min < 0) {
                return 'bipolar_3';
            } else if (min >= -0.5 && max <= 7.5 && max > 5.5) {
                return 'unipolar_7';
            } else if (min >= 0.5 && max <= 5.5) {
                return 'likert_5';
            } else if (min >= -0.5 && max <= 10.5 && max > 7.5) {
                return 'scale_10';
            }
            
            // Default
            return 'bipolar_5';
        }

        // Get color for a specific value
        function getColorForValue(value, scaleType) {
            if (!scaleType) scaleType = currentColorScale;
            const scale = colorScales[scaleType];
            const colors = scale.colors;
            
            // Find the two colors to interpolate between
            for (let i = 0; i < colors.length - 1; i++) {
                if (value >= colors[i].value && value <= colors[i + 1].value) {
                    // Linear interpolation
                    const t = (value - colors[i].value) / (colors[i + 1].value - colors[i].value);
                    return interpolateColor(colors[i].color, colors[i + 1].color, t);
                }
            }
            
            // Edge cases
            if (value <= colors[0].value) return colors[0].color;
            if (value >= colors[colors.length - 1].value) return colors[colors.length - 1].color;
            
            // Fallback
            return '#999999';
        }

        // Interpolate between two hex colors
        function interpolateColor(color1, color2, t) {
            // Convert hex to RGB
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            
            // Interpolate
            const r = Math.round(c1.r + (c2.r - c1.r) * t);
            const g = Math.round(c1.g + (c2.g - c1.g) * t);
            const b = Math.round(c1.b + (c2.b - c1.b) * t);
            
            // Convert back to hex
            return rgbToHex(r, g, b);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // Get display name for current scale
        function getScaleDisplayName() {
            const scaleNames = {
                '-5,5': '-5 to +5 (Bipolar)',
                '-3,3': '-3 to +3 (Compact Bipolar)',
                '-2,2': '-2 to +2 (Short Bipolar)',
                '0,10': '0 to 10 (Extended)',
                '0,7': '0 to 7 (Standard)',
                '1,7': '1 to 7 (Traditional)',
                '1,5': '1 to 5 (Likert)'
            };
            return scaleNames[currentScaleRange] || currentScaleRange;
        }
        
        // Update legend based on current color scale
        function updateColorLegend() {
            const legendDiv = document.getElementById('color-legend');
            if (!legendDiv) return;
            
            const scale = colorScales[currentColorScale];
            const colors = scale.colors;
            
            // Create gradient for the scale
            const gradientStops = colors.map(c => c.color).join(', ');
            
            legendDiv.innerHTML = `
                <div class="legend-item" style="flex: 1;">
                    <div class="legend-box" style="background: linear-gradient(90deg, ${gradientStops}); width: 200px;"></div>
                    <span style="margin-left: 10px;">
                        ${colors[0].label} (${colors[0].value}) → ${colors[colors.length-1].label} (${colors[colors.length-1].value})
                    </span>
                </div>
                <div class="legend-item">
                    <span style="font-weight: bold; color: var(--gsu-primary);">
                        Scale: ${getScaleDisplayName()}
                    </span>
                </div>
            `;
        }

        // Global variables
        let currentTree = null;
        let currentPath = [];
        let treeBuilder = new TreeBuilder();
        let builderMode = 'build';
        let currentSurveyNode = null;
        let scoreCallback = null;
        let surveyData = null; // Store uploaded survey data globally
        
        // Scale management
        let currentScaleMin = -5;
        let currentScaleMax = 5;
        let currentScaleRange = '-5,5';
        
        // Scale descriptions for subtitle
        const scaleDescriptions = {
            '-5,5': 'Bipolar Scale: -5 (Very Poor) to +5 (Industry Leader)',
            '-3,3': 'Bipolar Scale: -3 (Strongly Negative) to +3 (Strongly Positive)',
            '-2,2': 'Bipolar Scale: -2 (Disagree) to +2 (Agree)',
            '0,10': 'Rating Scale: 0 (Worst) to 10 (Best)',
            '0,7': 'Likert Scale: 0 (Not at All) to 7 (Extremely)',
            '1,7': 'Likert Scale: 1 (Strongly Disagree) to 7 (Strongly Agree)',
            '1,5': 'Likert Scale: 1 (Strongly Disagree) to 5 (Strongly Agree)'
        };
        
        // ============= FEATURE 1: Tree Templates =============
        // Pre-built decision tree templates for common use cases
        const treeTemplates = {
            customerSatisfaction: {
                name: 'Customer Satisfaction Survey',
                description: 'Evaluate customer experience and identify improvement areas',
                scale: '1,5',
                tree: {
                    layers: [
                        {
                            index: 0,
                            nodes: [{
                                id: 'root',
                                question: 'Overall Satisfaction',
                                threshold: 3,
                                score: 0,
                                leftId: 'service_issue',
                                rightId: 'product_quality'
                            }]
                        },
                        {
                            index: 1,
                            nodes: [
                                {
                                    id: 'service_issue',
                                    question: 'Service Quality Issue?',
                                    threshold: 2,
                                    score: -2,
                                    leftId: 'critical_service',
                                    rightId: 'minor_service'
                                },
                                {
                                    id: 'product_quality',
                                    question: 'Product Meets Expectations?',
                                    threshold: 4,
                                    score: 2,
                                    leftId: 'quality_improvement',
                                    rightId: 'excellent_product'
                                }
                            ]
                        },
                        {
                            index: 2,
                            nodes: [
                                {
                                    id: 'critical_service',
                                    question: 'Immediate Intervention Required',
                                    threshold: 0,
                                    score: -4,
                                    isTerminal: true
                                },
                                {
                                    id: 'minor_service',
                                    question: 'Service Training Needed',
                                    threshold: 0,
                                    score: -1,
                                    isTerminal: true
                                },
                                {
                                    id: 'quality_improvement',
                                    question: 'Product Enhancement Opportunity',
                                    threshold: 0,
                                    score: 1,
                                    isTerminal: true
                                },
                                {
                                    id: 'excellent_product',
                                    question: 'Promoter - Leverage for Testimonials',
                                    threshold: 0,
                                    score: 4,
                                    isTerminal: true
                                }
                            ]
                        }
                    ]
                }
            },
            riskAssessment: {
                name: 'Risk Assessment Matrix',
                description: 'Evaluate and categorize risk levels for decision making',
                scale: '0,10',
                tree: {
                    layers: [
                        {
                            index: 0,
                            nodes: [{
                                id: 'root',
                                question: 'Probability of Occurrence',
                                threshold: 5,
                                score: 0,
                                leftId: 'low_probability',
                                rightId: 'high_probability'
                            }]
                        },
                        {
                            index: 1,
                            nodes: [
                                {
                                    id: 'low_probability',
                                    question: 'Impact if Occurs',
                                    threshold: 5,
                                    score: 2,
                                    leftId: 'low_risk',
                                    rightId: 'medium_risk_1'
                                },
                                {
                                    id: 'high_probability',
                                    question: 'Impact Severity',
                                    threshold: 7,
                                    score: 8,
                                    leftId: 'medium_risk_2',
                                    rightId: 'critical_risk'
                                }
                            ]
                        },
                        {
                            index: 2,
                            nodes: [
                                {
                                    id: 'low_risk',
                                    question: 'Accept Risk - Monitor Only',
                                    threshold: 0,
                                    score: 1,
                                    isTerminal: true
                                },
                                {
                                    id: 'medium_risk_1',
                                    question: 'Mitigate - Standard Controls',
                                    threshold: 0,
                                    score: 4,
                                    isTerminal: true
                                },
                                {
                                    id: 'medium_risk_2',
                                    question: 'Mitigate - Enhanced Controls',
                                    threshold: 0,
                                    score: 6,
                                    isTerminal: true
                                },
                                {
                                    id: 'critical_risk',
                                    question: 'Avoid - Immediate Action Required',
                                    threshold: 0,
                                    score: 9,
                                    isTerminal: true
                                }
                            ]
                        }
                    ]
                }
            },
            performanceEvaluation: {
                name: 'Employee Performance Evaluation',
                description: 'Assess employee performance and identify development needs',
                scale: '1,7',
                tree: {
                    layers: [
                        {
                            index: 0,
                            nodes: [{
                                id: 'root',
                                question: 'Meeting Core Objectives',
                                threshold: 4,
                                score: 0,
                                leftId: 'underperforming',
                                rightId: 'meeting_goals'
                            }]
                        },
                        {
                            index: 1,
                            nodes: [
                                {
                                    id: 'underperforming',
                                    question: 'Improvement Shown Recently?',
                                    threshold: 3,
                                    score: 2,
                                    leftId: 'performance_plan',
                                    rightId: 'coaching_needed'
                                },
                                {
                                    id: 'meeting_goals',
                                    question: 'Leadership Potential?',
                                    threshold: 5,
                                    score: 5,
                                    leftId: 'solid_contributor',
                                    rightId: 'high_potential'
                                }
                            ]
                        },
                        {
                            index: 2,
                            nodes: [
                                {
                                    id: 'performance_plan',
                                    question: 'Performance Improvement Plan',
                                    threshold: 0,
                                    score: 1,
                                    isTerminal: true
                                },
                                {
                                    id: 'coaching_needed',
                                    question: 'Development Coaching',
                                    threshold: 0,
                                    score: 3,
                                    isTerminal: true
                                },
                                {
                                    id: 'solid_contributor',
                                    question: 'Recognition & Retention',
                                    threshold: 0,
                                    score: 5,
                                    isTerminal: true
                                },
                                {
                                    id: 'high_potential',
                                    question: 'Fast Track Development',
                                    threshold: 0,
                                    score: 7,
                                    isTerminal: true
                                }
                            ]
                        }
                    ]
                }
            },
            marketSegmentation: {
                name: 'Market Segmentation Analysis',
                description: 'Classify customers/markets for targeted strategies',
                scale: '0,10',
                tree: {
                    layers: [
                        {
                            index: 0,
                            nodes: [{
                                id: 'root',
                                question: 'Purchase Frequency',
                                threshold: 5,
                                score: 0,
                                leftId: 'low_frequency',
                                rightId: 'high_frequency'
                            }]
                        },
                        {
                            index: 1,
                            nodes: [
                                {
                                    id: 'low_frequency',
                                    question: 'Average Order Value',
                                    threshold: 6,
                                    score: 3,
                                    leftId: 'browsers',
                                    rightId: 'occasional_premium'
                                },
                                {
                                    id: 'high_frequency',
                                    question: 'Customer Lifetime Value',
                                    threshold: 7,
                                    score: 8,
                                    leftId: 'regular_customers',
                                    rightId: 'vip_customers'
                                }
                            ]
                        },
                        {
                            index: 2,
                            nodes: [
                                {
                                    id: 'browsers',
                                    question: 'Nurture Campaign Target',
                                    threshold: 0,
                                    score: 2,
                                    isTerminal: true
                                },
                                {
                                    id: 'occasional_premium',
                                    question: 'Upsell Opportunity',
                                    threshold: 0,
                                    score: 5,
                                    isTerminal: true
                                },
                                {
                                    id: 'regular_customers',
                                    question: 'Loyalty Program',
                                    threshold: 0,
                                    score: 7,
                                    isTerminal: true
                                },
                                {
                                    id: 'vip_customers',
                                    question: 'White Glove Service',
                                    threshold: 0,
                                    score: 10,
                                    isTerminal: true
                                }
                            ]
                        }
                    ]
                }
            }
        };
        
        // ============= FEATURE 2: A/B Testing Support =============
        // A/B testing configuration and tracking
        let abTestConfig = {
            enabled: false,
            tests: {},
            results: {}
        };
        
        class ABTestManager {
            constructor() {
                this.activeTests = new Map();
                this.testResults = new Map();
            }
            
            createTest(nodeId, config) {
                const test = {
                    nodeId: nodeId,
                    originalThreshold: config.originalThreshold,
                    variants: config.variants || [
                        { name: 'A', threshold: config.originalThreshold },
                        { name: 'B', threshold: config.testThreshold }
                    ],
                    allocation: config.allocation || [0.5, 0.5], // 50/50 split by default
                    metrics: {
                        impressions: new Map(),
                        conversions: new Map(),
                        pathScores: new Map()
                    },
                    startTime: new Date(),
                    endTime: config.endTime || null,
                    status: 'active'
                };
                
                this.activeTests.set(nodeId, test);
                return test;
            }
            
            assignVariant(nodeId, respondentId) {
                const test = this.activeTests.get(nodeId);
                if (!test || test.status !== 'active') {
                    return null;
                }
                
                // Use consistent hashing for assignment
                const hash = this.hashRespondent(respondentId + nodeId);
                let cumulative = 0;
                
                for (let i = 0; i < test.variants.length; i++) {
                    cumulative += test.allocation[i];
                    if (hash < cumulative) {
                        const variant = test.variants[i];
                        
                        // Track impression
                        if (!test.metrics.impressions.has(variant.name)) {
                            test.metrics.impressions.set(variant.name, 0);
                        }
                        test.metrics.impressions.set(
                            variant.name, 
                            test.metrics.impressions.get(variant.name) + 1
                        );
                        
                        return variant;
                    }
                }
                
                return test.variants[0]; // Fallback to control
            }
            
            hashRespondent(str) {
                // Simple hash function for consistent assignment
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash = hash & hash;
                }
                return Math.abs(hash) / 2147483647; // Normalize to 0-1
            }
            
            recordConversion(nodeId, variantName, score, path) {
                const test = this.activeTests.get(nodeId);
                if (!test) return;
                
                if (!test.metrics.conversions.has(variantName)) {
                    test.metrics.conversions.set(variantName, 0);
                }
                test.metrics.conversions.set(
                    variantName,
                    test.metrics.conversions.get(variantName) + 1
                );
                
                if (!test.metrics.pathScores.has(variantName)) {
                    test.metrics.pathScores.set(variantName, []);
                }
                test.metrics.pathScores.get(variantName).push(score);
            }
            
            calculateStatistics(nodeId) {
                const test = this.activeTests.get(nodeId);
                if (!test) return null;
                
                const stats = {
                    nodeId: nodeId,
                    startTime: test.startTime,
                    variants: []
                };
                
                test.variants.forEach(variant => {
                    const impressions = test.metrics.impressions.get(variant.name) || 0;
                    const conversions = test.metrics.conversions.get(variant.name) || 0;
                    const scores = test.metrics.pathScores.get(variant.name) || [];
                    
                    const conversionRate = impressions > 0 ? conversions / impressions : 0;
                    const avgScore = scores.length > 0 ? 
                        scores.reduce((a, b) => a + b, 0) / scores.length : 0;
                    
                    // Calculate confidence interval using Wilson score interval
                    const confidence = this.calculateConfidence(conversions, impressions);
                    
                    stats.variants.push({
                        name: variant.name,
                        threshold: variant.threshold,
                        impressions: impressions,
                        conversions: conversions,
                        conversionRate: conversionRate,
                        avgScore: avgScore,
                        confidence: confidence,
                        isWinning: false // Will be determined after all variants calculated
                    });
                });
                
                // Determine statistical significance and winner
                if (stats.variants.length === 2) {
                    const significance = this.calculateSignificance(
                        stats.variants[0], 
                        stats.variants[1]
                    );
                    stats.significance = significance;
                    
                    if (significance.pValue < 0.05) {
                        const winner = stats.variants[0].conversionRate > stats.variants[1].conversionRate ? 0 : 1;
                        stats.variants[winner].isWinning = true;
                        stats.hasWinner = true;
                    }
                }
                
                return stats;
            }
            
            calculateConfidence(successes, trials) {
                if (trials === 0) return { lower: 0, upper: 0 };
                
                const z = 1.96; // 95% confidence
                const phat = successes / trials;
                const denominator = 1 + z * z / trials;
                const centre = (phat + z * z / (2 * trials)) / denominator;
                const halfWidth = (z * Math.sqrt(phat * (1 - phat) / trials + z * z / (4 * trials * trials))) / denominator;
                
                return {
                    lower: Math.max(0, centre - halfWidth),
                    upper: Math.min(1, centre + halfWidth)
                };
            }
            
            calculateSignificance(variantA, variantB) {
                // Z-test for proportions
                const p1 = variantA.conversionRate;
                const p2 = variantB.conversionRate;
                const n1 = variantA.impressions;
                const n2 = variantB.impressions;
                
                if (n1 === 0 || n2 === 0) {
                    return { zScore: 0, pValue: 1, significant: false };
                }
                
                const pooledP = (variantA.conversions + variantB.conversions) / (n1 + n2);
                const se = Math.sqrt(pooledP * (1 - pooledP) * (1/n1 + 1/n2));
                
                if (se === 0) {
                    return { zScore: 0, pValue: 1, significant: false };
                }
                
                const zScore = (p1 - p2) / se;
                const pValue = 2 * (1 - this.normalCDF(Math.abs(zScore)));
                
                return {
                    zScore: zScore,
                    pValue: pValue,
                    significant: pValue < 0.05
                };
            }
            
            normalCDF(x) {
                // Approximation of the cumulative distribution function for standard normal
                const t = 1 / (1 + 0.2316419 * Math.abs(x));
                const d = 0.3989423 * Math.exp(-x * x / 2);
                const prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
                return x > 0 ? 1 - prob : prob;
            }
            
            endTest(nodeId, applyWinner = false) {
                const test = this.activeTests.get(nodeId);
                if (!test) return null;
                
                test.status = 'completed';
                test.endTime = new Date();
                
                const stats = this.calculateStatistics(nodeId);
                
                if (applyWinner && stats.hasWinner) {
                    const winner = stats.variants.find(v => v.isWinning);
                    if (winner) {
                        // Update the actual node threshold
                        const node = treeBuilder.nodes.get(nodeId);
                        if (node) {
                            node.threshold = winner.threshold;
                            visualizeTree();
                        }
                    }
                }
                
                // Archive test results
                this.testResults.set(nodeId, {
                    test: test,
                    stats: stats
                });
                
                this.activeTests.delete(nodeId);
                
                return stats;
            }
        }
        
        const abTestManager = new ABTestManager();
        
        // ============= FEATURE 3: Data Import Mapping Templates =============
        // Save and reuse field mappings for consistent data formats
        class DataMappingTemplates {
            constructor() {
                this.templates = this.loadTemplates();
            }
            
            loadTemplates() {
                const saved = localStorage.getItem('dataMappingTemplates');
                return saved ? JSON.parse(saved) : {};
            }
            
            saveTemplate(name, mapping) {
                const template = {
                    name: name,
                    created: new Date().toISOString(),
                    idField: mapping.idField,
                    scoreFields: mapping.scoreFields,
                    fieldDescriptions: mapping.fieldDescriptions || {},
                    scale: mapping.scale || currentScaleRange,
                    allowDecimals: mapping.allowDecimals !== undefined ? mapping.allowDecimals : allowDecimals,
                    sampleData: mapping.sampleData || null
                };
                
                this.templates[name] = template;
                this.persist();
                return template;
            }
            
            applyTemplate(templateName, data) {
                const template = this.templates[templateName];
                if (!template) return null;
                
                const processedData = [];
                
                data.forEach((record, index) => {
                    const processedRecord = {};
                    
                    // Apply ID field mapping
                    if (template.idField && record[template.idField]) {
                        processedRecord.respondentId = record[template.idField];
                    } else {
                        processedRecord.respondentId = `Respondent_${index + 1}`;
                    }
                    
                    // Apply score field mappings
                    template.scoreFields.forEach(field => {
                        if (record[field] !== undefined) {
                            const value = parseFloat(record[field]);
                            if (!isNaN(value)) {
                                processedRecord[field] = value;
                            }
                        }
                    });
                    
                    processedData.push(processedRecord);
                });
                
                // Apply scale settings
                if (template.scale) {
                    document.getElementById('scale-type').value = template.scale;
                    updateScaleType();
                }
                
                if (template.allowDecimals !== undefined) {
                    document.getElementById('allow-decimals').checked = template.allowDecimals;
                    allowDecimals = template.allowDecimals;
                }
                
                return processedData;
            }
            
            deleteTemplate(name) {
                delete this.templates[name];
                this.persist();
            }
            
            getTemplateList() {
                return Object.keys(this.templates).map(name => ({
                    name: name,
                    ...this.templates[name]
                }));
            }
            
            persist() {
                localStorage.setItem('dataMappingTemplates', JSON.stringify(this.templates));
            }
            
            exportTemplate(name) {
                const template = this.templates[name];
                if (!template) return null;
                
                const blob = new Blob([JSON.stringify(template, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mapping-template-${name}-${Date.now()}.json`;
                a.click();
            }
            
            importTemplate(jsonString) {
                try {
                    const template = JSON.parse(jsonString);
                    if (template.name) {
                        this.templates[template.name] = template;
                        this.persist();
                        return template;
                    }
                } catch (e) {
                    console.error('Failed to import template:', e);
                }
                return null;
            }
        }
        
        const dataMappingTemplates = new DataMappingTemplates();
        
        // Update scale type based on dropdown
        function updateScaleType() {
            const scaleSelect = document.getElementById('scale-type');
            currentScaleRange = scaleSelect.value;
            const [min, max] = scaleSelect.value.split(',').map(Number);
            currentScaleMin = min;
            currentScaleMax = max;
            
            // Update color scale detection
            const scaleMap = {
                '-5,5': 'bipolar_5',
                '-3,3': 'bipolar_3',
                '-2,2': 'bipolar_3', // Use bipolar_3 for -2,2
                '0,10': 'scale_10',
                '0,7': 'unipolar_7',
                '1,7': 'unipolar_7', // Use unipolar_7 for 1,7
                '1,5': 'likert_5'
            };
            
            currentColorScale = scaleMap[currentScaleRange] || 'bipolar_5';
            updateColorLegend();
            
            // Update subtitle
            const subtitle = document.getElementById('scale-subtitle');
            if (subtitle && scaleDescriptions[currentScaleRange]) {
                subtitle.textContent = scaleDescriptions[currentScaleRange];
            }
            
            // Update builder display if it exists
            if (treeBuilder && typeof treeBuilder.updateLayersDisplay === 'function') {
                treeBuilder.updateLayersDisplay();
            }
            
            // Update any existing visualizations
            if (treeBuilder.nodes.size > 0) {
                visualizeTree();
            }
            
            console.log(`Scale updated: ${min} to ${max}, using color scale: ${currentColorScale}`);
        }

        // Update decimal precision based on checkbox
        function updateDecimalPrecision() {
            const checkbox = document.getElementById('allow-decimals');
            allowDecimals = checkbox.checked;
            
            // Update builder display if it exists
            if (treeBuilder && typeof treeBuilder.updateLayersDisplay === 'function') {
                treeBuilder.updateLayersDisplay();
            }
            
            console.log(`Decimal values: ${allowDecimals ? 'enabled' : 'disabled'}`);
        }

        function changeVisualization() {
            const vizMode = document.getElementById('viz-mode').value;
            
            if (vizMode === 'distribution') {
                if (window.batchResults && window.batchResults.length > 0) {
                    drawScoreDistribution();
                } else {
                    showNoDataMessage('Upload survey data to see score distributions');
                }
            } else if (vizMode === 'heatmap') {
                if (window.batchResults && window.batchResults.length > 0) {
                    visualizePathTraversals(getEdgeTraversals(), window.batchResults.length);
                } else {
                    showNoDataMessage('Upload survey data to see path heatmap');
                }
            } else if (vizMode === 'clustering') {
                if (window.batchResults && window.batchResults.length > 0) {
                    drawClusteringVisualization();
                } else {
                    showNoDataMessage('Upload survey data to see clustering analysis');
                }
            } else {
                visualizeTree();
            }
        }
        
        function showNoDataMessage(message) {
            const container = document.getElementById('tree-container');
            const svg = document.getElementById('tree-svg');
            svg.innerHTML = '';
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', container.clientWidth / 2);
            text.setAttribute('y', container.clientHeight / 2);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '20');
            text.setAttribute('fill', '#666');
            text.textContent = message;
            svg.appendChild(text);
            
            // Add upload hint
            const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            hint.setAttribute('x', container.clientWidth / 2);
            hint.setAttribute('y', container.clientHeight / 2 + 30);
            hint.setAttribute('text-anchor', 'middle');
            hint.setAttribute('font-size', '14');
            hint.setAttribute('fill', '#999');
            hint.textContent = 'Click "Upload Survey Data" to load responses';
            svg.appendChild(hint);
        }

        function getEdgeTraversals() {
            const edgeTraversals = {};
            if (window.batchResults) {
                window.batchResults.forEach(result => {
                    result.path.forEach((step, index) => {
                        if (index < result.path.length - 1) {
                            const nextStep = result.path[index + 1];
                            const edgeKey = `${step.nodeId}_${nextStep.nodeId}`;
                            edgeTraversals[edgeKey] = (edgeTraversals[edgeKey] || 0) + 1;
                        }
                    });
                });
            }
            return edgeTraversals;
        }

        function drawClusteringVisualization() {
            if (!surveyData || surveyData.length === 0) {
                showNoDataMessage('Upload survey data to see clustering analysis');
                return;
            }

            const container = document.getElementById('tree-container');
            const svg = document.getElementById('tree-svg');
            const width = container.clientWidth;
            const height = container.clientHeight;
            svg.innerHTML = '';

            // Extract response patterns
            const responsePatterns = [];
            const responseLabels = [];
            
            surveyData.forEach(response => {
                const pattern = [];
                const label = response.respondentId || `R${responsePatterns.length + 1}`;
                
                // Collect all numeric values
                for (const key in response) {
                    if (key !== 'respondentId' && !isNaN(parseFloat(response[key]))) {
                        pattern.push(parseFloat(response[key]));
                    }
                }
                
                if (pattern.length > 0) {
                    responsePatterns.push(pattern);
                    responseLabels.push(label);
                }
            });

            if (responsePatterns.length === 0) {
                showNoDataMessage('No valid numeric data found for clustering');
                return;
            }

            // Simple k-means clustering (k=3-5 based on data size)
            const k = Math.min(5, Math.max(3, Math.floor(responsePatterns.length / 5)));
            const clusters = performKMeansClustering(responsePatterns, k);
            
            // Color palette
            const clusterColors = ['#0039A6', '#CC0033', '#4B9BFF', '#FF6B6B', '#45B7D1'];
            
            // Calculate cluster centers for visualization
            const clusterGroups = {};
            clusters.forEach((clusterId, idx) => {
                if (!clusterGroups[clusterId]) {
                    clusterGroups[clusterId] = [];
                }
                clusterGroups[clusterId].push({
                    pattern: responsePatterns[idx],
                    label: responseLabels[idx],
                    index: idx
                });
            });

            // Position clusters in circular layout
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            
            let clusterIndex = 0;
            for (const clusterId in clusterGroups) {
                const angle = (clusterIndex / k) * Math.PI * 2 - Math.PI / 2; // Start from top
                const clusterX = centerX + Math.cos(angle) * radius;
                const clusterY = centerY + Math.sin(angle) * radius;
                
                // Draw cluster circle
                const clusterCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                clusterCircle.setAttribute('cx', clusterX);
                clusterCircle.setAttribute('cy', clusterY);
                clusterCircle.setAttribute('r', Math.sqrt(clusterGroups[clusterId].length) * 15);
                clusterCircle.setAttribute('fill', clusterColors[clusterIndex % clusterColors.length]);
                clusterCircle.setAttribute('fill-opacity', '0.2');
                clusterCircle.setAttribute('stroke', clusterColors[clusterIndex % clusterColors.length]);
                clusterCircle.setAttribute('stroke-width', '2');
                svg.appendChild(clusterCircle);
                
                // Draw cluster label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', clusterX);
                label.setAttribute('y', clusterY - Math.sqrt(clusterGroups[clusterId].length) * 15 - 10);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '14');
                label.setAttribute('font-weight', 'bold');
                label.setAttribute('fill', clusterColors[clusterIndex % clusterColors.length]);
                label.textContent = `Cluster ${parseInt(clusterId) + 1}`;
                svg.appendChild(label);
                
                // Draw individual points
                clusterGroups[clusterId].forEach((item, i) => {
                    const pointAngle = (i / clusterGroups[clusterId].length) * Math.PI * 2;
                    const pointRadius = Math.sqrt(clusterGroups[clusterId].length) * 10;
                    const pointX = clusterX + Math.cos(pointAngle) * pointRadius;
                    const pointY = clusterY + Math.sin(pointAngle) * pointRadius;
                    
                    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    point.setAttribute('cx', pointX);
                    point.setAttribute('cy', pointY);
                    point.setAttribute('r', '4');
                    point.setAttribute('fill', clusterColors[clusterIndex % clusterColors.length]);
                    point.setAttribute('fill-opacity', '0.8');
                    point.setAttribute('stroke', '#fff');
                    point.setAttribute('stroke-width', '1');
                    
                    // Add tooltip
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    const avgScore = item.pattern.reduce((a, b) => a + b, 0) / item.pattern.length;
                    title.textContent = `${item.label}\nAvg: ${avgScore.toFixed(2)}`;
                    point.appendChild(title);
                    
                    svg.appendChild(point);
                });
                
                // Add cluster size
                const sizeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sizeText.setAttribute('x', clusterX);
                sizeText.setAttribute('y', clusterY + 5);
                sizeText.setAttribute('text-anchor', 'middle');
                sizeText.setAttribute('font-size', '12');
                sizeText.setAttribute('fill', '#666');
                sizeText.textContent = `n=${clusterGroups[clusterId].length}`;
                svg.appendChild(sizeText);
                
                clusterIndex++;
            }

            // Add legend
            const legendX = width - 150;
            const legendY = 30;
            
            const legendTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            legendTitle.setAttribute('x', legendX);
            legendTitle.setAttribute('y', legendY);
            legendTitle.setAttribute('font-size', '14');
            legendTitle.setAttribute('font-weight', 'bold');
            legendTitle.textContent = 'Response Clusters';
            svg.appendChild(legendTitle);

            clusterIndex = 0;
            for (const clusterId in clusterGroups) {
                const y = legendY + 25 + clusterIndex * 25;
                
                const legendCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                legendCircle.setAttribute('cx', legendX + 10);
                legendCircle.setAttribute('cy', y);
                legendCircle.setAttribute('r', '8');
                legendCircle.setAttribute('fill', clusterColors[clusterIndex % clusterColors.length]);
                legendCircle.setAttribute('fill-opacity', '0.7');
                svg.appendChild(legendCircle);
                
                const legendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                legendText.setAttribute('x', legendX + 25);
                legendText.setAttribute('y', y + 5);
                legendText.setAttribute('font-size', '12');
                legendText.textContent = `Group ${parseInt(clusterId) + 1} (${clusterGroups[clusterId].length})`;
                svg.appendChild(legendText);
                
                clusterIndex++;
            }

            // Add description
            const desc = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            desc.setAttribute('x', width / 2);
            desc.setAttribute('y', height - 20);
            desc.setAttribute('text-anchor', 'middle');
            desc.setAttribute('font-size', '12');
            desc.setAttribute('fill', '#666');
            desc.textContent = 'Responses grouped by similarity of answer patterns';
            svg.appendChild(desc);
        }

        function performKMeansClustering(data, k) {
            const n = data.length;
            const assignments = new Array(n).fill(0);
            
            if (n <= k) {
                // If fewer data points than clusters, each gets its own cluster
                return data.map((_, i) => i);
            }
            
            // Initialize cluster centers randomly
            const centers = [];
            const usedIndices = new Set();
            while (centers.length < k) {
                const idx = Math.floor(Math.random() * n);
                if (!usedIndices.has(idx)) {
                    centers.push([...data[idx]]);
                    usedIndices.add(idx);
                }
            }
            
            // K-means iterations
            for (let iter = 0; iter < 20; iter++) {
                let changed = false;
                
                // Assign points to nearest center
                for (let i = 0; i < n; i++) {
                    let minDist = Infinity;
                    let bestCluster = 0;
                    
                    for (let j = 0; j < k; j++) {
                        const dist = euclideanDistance(data[i], centers[j]);
                        if (dist < minDist) {
                            minDist = dist;
                            bestCluster = j;
                        }
                    }
                    
                    if (assignments[i] !== bestCluster) {
                        assignments[i] = bestCluster;
                        changed = true;
                    }
                }
                
                if (!changed) break;
                
                // Update centers
                for (let c = 0; c < k; c++) {
                    const clusterPoints = [];
                    for (let i = 0; i < n; i++) {
                        if (assignments[i] === c) {
                            clusterPoints.push(data[i]);
                        }
                    }
                    
                    if (clusterPoints.length > 0) {
                        // Calculate mean of cluster points
                        const dims = centers[c].length;
                        for (let d = 0; d < dims; d++) {
                            centers[c][d] = clusterPoints.reduce((sum, p) => sum + (p[d] || 0), 0) / clusterPoints.length;
                        }
                    }
                }
            }
            
            return assignments;
        }

        function euclideanDistance(a, b) {
            let sum = 0;
            const len = Math.min(a.length, b.length);
            for (let i = 0; i < len; i++) {
                const diff = (a[i] || 0) - (b[i] || 0);
                sum += diff * diff;
            }
            return Math.sqrt(sum);
        }

        function autoCalculateAllThresholds() {
            if (!window.uploadedSurveyData || window.uploadedSurveyData.length === 0) {
                alert('No survey data loaded. Please upload survey data first.');
                return;
            }
            
            const modes = ['mean', 'median', 'percentile'];
            const modeChoice = prompt(
                'Choose threshold calculation method:\n' +
                '1. Mean - Average of all responses\n' +
                '2. Median - Middle value of all responses\n' +
                '3. Percentile - 75th percentile\n' +
                'Enter 1, 2, or 3:',
                '1'
            );
            
            let selectedMode = 'mean';
            switch(modeChoice) {
                case '2':
                    selectedMode = 'median';
                    break;
                case '3':
                    selectedMode = 'percentile';
                    break;
                default:
                    selectedMode = 'mean';
            }
            
            // Update all nodes with the selected threshold mode
            let updatedCount = 0;
            treeBuilder.nodes.forEach((node, nodeId) => {
                updateThresholdMode(nodeId, selectedMode);
                updatedCount++;
            });
            
            if (updatedCount > 0) {
                alert(`✅ Updated ${updatedCount} nodes with ${selectedMode.toUpperCase()} threshold calculation`);
                visualizeTree();
            } else {
                alert('No nodes to update. Please build your tree first.');
            }
        }
        
        function updateThresholdMode(nodeId, mode) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;
            
            node.thresholdMode = mode;
            
            if (mode !== 'manual' && window.uploadedSurveyData && window.uploadedSurveyData.length > 0) {
                // Calculate threshold based on all responses for this node's question
                const values = [];
                window.uploadedSurveyData.forEach(response => {
                    // Find the value for this node's question
                    const questionKey = node.question;
                    if (response[questionKey] !== undefined) {
                        values.push(parseFloat(response[questionKey]));
                    }
                });
                
                if (values.length > 0) {
                    let calculatedThreshold = 0;
                    
                    switch (mode) {
                        case 'mean':
                            calculatedThreshold = values.reduce((a, b) => a + b, 0) / values.length;
                            break;
                        case 'median':
                            const sorted = values.sort((a, b) => a - b);
                            const mid = Math.floor(sorted.length / 2);
                            calculatedThreshold = sorted.length % 2 !== 0 
                                ? sorted[mid] 
                                : (sorted[mid - 1] + sorted[mid]) / 2;
                            break;
                        case 'percentile':
                            const sortedPercentile = values.sort((a, b) => a - b);
                            const index = Math.ceil(sortedPercentile.length * 0.75) - 1;
                            calculatedThreshold = sortedPercentile[index];
                            break;
                    }
                    
                    node.threshold = calculatedThreshold;
                    
                    // Update the UI
                    const thresholdInput = document.getElementById(`threshold-value-${nodeId}`);
                    if (thresholdInput) {
                        thresholdInput.value = calculatedThreshold.toFixed(2);
                        thresholdInput.disabled = true;
                    }
                }
            } else if (mode === 'manual') {
                // Enable manual input
                const thresholdInput = document.getElementById(`threshold-value-${nodeId}`);
                if (thresholdInput) {
                    thresholdInput.disabled = false;
                }
            }
            
            treeBuilder.updateNodeProperties(nodeId, {
                threshold: node.threshold,
                thresholdMode: node.thresholdMode
            });
            
            // Refresh the display to show the updated info
            treeBuilder.updateLayersDisplay();
        }

        function visualizeTree() {
            const container = document.getElementById('tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const svg = document.getElementById('tree-svg');
            svg.innerHTML = '';

            const vizMode = document.getElementById('viz-mode').value;
            
            // Calculate positions based on visualization mode
            if (vizMode === 'radial') {
                calculateRadialPositions();
            } else if (vizMode === 'tanh') {
                calculateTanhPositions();
            } else {
                calculateStandardPositions();
            }

            // Draw connections
            treeBuilder.nodes.forEach(node => {
                if (node.left) {
                    drawLabeledLink(svg, node, node.left, 'negative', `< ${node.threshold}`);
                }
                if (node.right) {
                    drawLabeledLink(svg, node, node.right, 'positive', `≥ ${node.threshold}`);
                }
            });

            // Draw nodes
            treeBuilder.nodes.forEach(node => {
                drawSingleNode(svg, node, 120, 60);
            });
        }

        function calculateStandardPositions() {
            const container = document.getElementById('tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const layerHeight = height / (treeBuilder.layers.length + 1);
            
            if (treeBuilder.layers.length > 0 && treeBuilder.layers[0].nodes.length > 0) {
                treeBuilder.layers[0].nodes[0].x = width / 2;
                treeBuilder.layers[0].nodes[0].y = layerHeight;
            }
            
            for (let layerIndex = 1; layerIndex < treeBuilder.layers.length; layerIndex++) {
                const layer = treeBuilder.layers[layerIndex];
                const prevLayer = treeBuilder.layers[layerIndex - 1];
                
                layer.nodes.forEach(node => {
                    let positioned = false;
                    prevLayer.nodes.forEach(parent => {
                        if (parent.leftId === node.id) {
                            node.x = parent.x - (width / Math.pow(2, layerIndex + 1));
                            node.y = layerHeight * (layerIndex + 1);
                            positioned = true;
                        } else if (parent.rightId === node.id) {
                            node.x = parent.x + (width / Math.pow(2, layerIndex + 1));
                            node.y = layerHeight * (layerIndex + 1);
                            positioned = true;
                        }
                    });
                    
                    if (!positioned) {
                        const unconnectedIndex = layer.nodes.filter(n => !n.parentId).indexOf(node);
                        node.x = 50 + (unconnectedIndex * 150);
                        node.y = layerHeight * (layerIndex + 1);
                    }
                });
            }
        }

        function calculateTanhPositions() {
            const container = document.getElementById('tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const layerHeight = height / (treeBuilder.layers.length + 1);
            
            // Create S-curve effect where nodes flow based on their scores
            treeBuilder.layers.forEach((layer, layerIndex) => {
                layer.nodes.forEach((node, nodeIndex) => {
                    // Normalize score to current scale range
                    const normalizedScore = (node.score - currentScaleMin) / (currentScaleMax - currentScaleMin) * 2 - 1;
                    
                    // Apply tanh for smooth S-curve
                    const tanhFactor = Math.tanh(normalizedScore * 2); // multiply by 2 for more dramatic curve
                    
                    // Create vertical S-curve effect
                    const baseX = width / 2;
                    const maxSpread = width * 0.4; // Use 40% of width for spreading
                    
                    // Add layer-based oscillation for S-shape
                    const oscillation = Math.sin(layerIndex * Math.PI / 3) * 0.3;
                    const spreadAdjust = maxSpread * (1 + oscillation);
                    
                    node.x = baseX + tanhFactor * spreadAdjust;
                    node.y = layerHeight * (layerIndex + 1);
                    
                    // Store the tanh factor for coloring
                    node.tanhFactor = tanhFactor;
                });
            });
        }

        function calculateRadialPositions() {
            const container = document.getElementById('tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2 - 80;
            
            // Place root at center if it exists
            if (treeBuilder.layers.length > 0 && treeBuilder.layers[0].nodes.length > 0) {
                const rootNode = treeBuilder.layers[0].nodes[0];
                rootNode.x = centerX;
                rootNode.y = centerY;
                rootNode.angle = 0; // Store angle for curved links
            }
            
            // Place other layers in concentric circles
            for (let layerIndex = 1; layerIndex < treeBuilder.layers.length; layerIndex++) {
                const layer = treeBuilder.layers[layerIndex];
                const radius = (maxRadius / (treeBuilder.layers.length - 1)) * layerIndex;
                
                // Calculate total angle needed based on parent nodes
                const parentLayer = treeBuilder.layers[layerIndex - 1];
                let angleRanges = [];
                
                parentLayer.nodes.forEach(parentNode => {
                    const childCount = layer.nodes.filter(n => 
                        n.parentId === parentNode.id || 
                        parentNode.leftId === n.id || 
                        parentNode.rightId === n.id
                    ).length;
                    
                    if (childCount > 0) {
                        angleRanges.push({
                            parent: parentNode,
                            count: childCount,
                            startAngle: parentNode.angle || 0
                        });
                    }
                });
                
                // Distribute nodes around the circle
                let currentAngle = -Math.PI / 2; // Start at top
                const totalNodes = layer.nodes.length;
                const angleStep = (2 * Math.PI) / Math.max(totalNodes, 3); // Minimum 3 for spacing
                
                layer.nodes.forEach((node, nodeIndex) => {
                    const angle = currentAngle + angleStep * nodeIndex;
                    node.x = centerX + radius * Math.cos(angle);
                    node.y = centerY + radius * Math.sin(angle);
                    node.angle = angle; // Store for child positioning
                    node.radius = radius; // Store for drawing curved links
                });
            }
        }

        function drawScoreDistribution() {
            const container = document.getElementById('tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const svg = document.getElementById('tree-svg');
            svg.innerHTML = '';
            
            if (!window.batchResults || window.batchResults.length === 0) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', String(width/2));
                text.setAttribute('y', String(height/2));
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '20');
                text.textContent = 'No data available. Upload survey responses first.';
                svg.appendChild(text);
                return;
            }
            
            // Collect score distributions for each node
            const nodeDistributions = {};
            treeBuilder.nodes.forEach(node => {
                if (!node.isTerminal) {
                    nodeDistributions[node.id] = {
                        question: node.question,
                        scores: [],
                        histogram: {}
                    };
                }
            });
            
            window.batchResults.forEach(result => {
                result.path.forEach(step => {
                    if (nodeDistributions[step.nodeId]) {
                        nodeDistributions[step.nodeId].scores.push(step.score);
                    }
                });
            });
            
            // Create histograms adapted to current scale
            Object.values(nodeDistributions).forEach(dist => {
                // Create bins based on current scale
                const binCount = 20; // Use 20 bins for any scale
                const binSize = (currentScaleMax - currentScaleMin) / binCount;
                
                for (let i = 0; i <= binCount; i++) {
                    const binValue = currentScaleMin + i * binSize;
                    dist.histogram[binValue.toFixed(1)] = 0;
                }
                
                dist.scores.forEach(score => {
                    // Find the closest bin
                    const binIndex = Math.round((score - currentScaleMin) / binSize);
                    const binValue = (currentScaleMin + binIndex * binSize).toFixed(1);
                    if (dist.histogram[binValue] !== undefined) {
                        dist.histogram[binValue]++;
                    }
                });
            });
            
            // Draw distribution charts
            const chartHeight = height / Object.keys(nodeDistributions).length;
            const chartWidth = width - 100;
            const margin = 50;
            
            Object.entries(nodeDistributions).forEach(([nodeId, dist], index) => {
                const y = index * chartHeight + 50;
                
                // Draw title
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', String(margin));
                title.setAttribute('y', String(y - 10));
                title.setAttribute('font-size', '14');
                title.setAttribute('font-weight', 'bold');
                title.textContent = dist.question.substring(0, 40) + (dist.question.length > 40 ? '...' : '');
                svg.appendChild(title);
                
                // Draw axis
                const axis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                axis.setAttribute('x1', String(margin));
                axis.setAttribute('y1', String(y + chartHeight - 40));
                axis.setAttribute('x2', String(margin + chartWidth));
                axis.setAttribute('y2', String(y + chartHeight - 40));
                axis.setAttribute('stroke', '#333');
                svg.appendChild(axis);
                
                // Draw bars
                const maxCount = Math.max(...Object.values(dist.histogram));
                const barWidth = chartWidth / 21; // 21 bars from -5 to 5 in 0.5 steps
                
                Object.entries(dist.histogram).forEach(([score, count]) => {
                    const scoreNum = parseFloat(score);
                    const x = margin + ((scoreNum + 5) * 2) * barWidth;
                    const barHeight = maxCount > 0 ? (count / maxCount) * (chartHeight - 60) : 0;
                    
                    // Bar
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', String(x));
                    rect.setAttribute('y', String(y + chartHeight - 40 - barHeight));
                    rect.setAttribute('width', String(barWidth - 2));
                    rect.setAttribute('height', String(barHeight));
                    
                    // Color based on score using adaptive scale
                    const color = getColorForValue(scoreNum, currentColorScale);
                    
                    rect.setAttribute('fill', color);
                    rect.setAttribute('opacity', '0.7');
                    svg.appendChild(rect);
                    
                    // Count label if > 0
                    if (count > 0) {
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', String(x + barWidth/2 - 1));
                        label.setAttribute('y', String(y + chartHeight - 45 - barHeight));
                        label.setAttribute('text-anchor', 'middle');
                        label.setAttribute('font-size', '10');
                        label.textContent = String(count);
                        svg.appendChild(label);
                    }
                });
                
                // Score labels
                for (let score = -5; score <= 5; score++) {
                    const x = margin + ((score + 5) * 2) * barWidth;
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', String(x + barWidth));
                    label.setAttribute('y', String(y + chartHeight - 25));
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('font-size', '10');
                    label.textContent = String(score);
                    svg.appendChild(label);
                }
                
                // Stats text
                const mean = dist.scores.length > 0 ? 
                    (dist.scores.reduce((a,b) => a+b, 0) / dist.scores.length).toFixed(2) : 0;
                const statsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                statsText.setAttribute('x', String(margin + chartWidth - 100));
                statsText.setAttribute('y', String(y + 10));
                statsText.setAttribute('font-size', '12');
                statsText.textContent = `n=${dist.scores.length}, μ=${mean}`;
                svg.appendChild(statsText);
            });
        }

        function drawLabeledLink(svg, fromNode, toNode, type, label) {
            // Draw the line
            const link = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            link.setAttribute('x1', String(fromNode.x));
            link.setAttribute('y1', String(fromNode.y));
            link.setAttribute('x2', String(toNode.x));
            link.setAttribute('y2', String(toNode.y));
            link.setAttribute('class', `link ${type}`);
            svg.appendChild(link);
            
            // Add label at midpoint
            const midX = (fromNode.x + toNode.x) / 2;
            const midY = (fromNode.y + toNode.y) / 2;
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', String(midX));
            text.setAttribute('y', String(midY - 5));
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', type === 'negative' ? '#f44336' : '#4CAF50');
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', 'bold');
            text.textContent = label;
            svg.appendChild(text);
        }

        function drawLink(svg, fromNode, toNode, type) {
            const link = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            link.setAttribute('x1', fromNode.x);
            link.setAttribute('y1', fromNode.y);
            link.setAttribute('x2', toNode.x);
            link.setAttribute('y2', toNode.y);
            link.setAttribute('class', `link ${type}`);
            svg.appendChild(link);
        }

        function drawSingleNode(svg, node, width, height) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'node');
            g.setAttribute('id', `node-${node.id}`);
            g.setAttribute('transform', `translate(${node.x - width/2}, ${node.y - height/2})`);

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.setAttribute('rx', 5);
            rect.setAttribute('fill', node.getColor());
            rect.setAttribute('stroke', '#fff');
            g.appendChild(rect);

            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('class', 'question');
            text1.setAttribute('x', width/2);
            text1.setAttribute('y', height/2 - 10);
            text1.setAttribute('text-anchor', 'middle');
            text1.textContent = node.question.substring(0, 20);
            g.appendChild(text1);

            const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text2.setAttribute('class', 'score');
            text2.setAttribute('x', String(width/2));
            text2.setAttribute('y', String(height/2 + 5));
            text2.setAttribute('text-anchor', 'middle');
            text2.textContent = `Score: ${(node.score || 0).toFixed(1)} | Thr: ${node.threshold}`;
            g.appendChild(text2);

            g.addEventListener('click', () => handleNodeClick(node));
            svg.appendChild(g);
        }

        function drawStandardTree(svg, root, width, height) {
            const nodeWidth = 120;
            const nodeHeight = 60;
            const levelHeight = height / (getTreeDepth(root) + 1);

            // Calculate positions
            calculatePositions(root, width / 2, 50, width / 4);

            // Draw links
            drawLinks(svg, root);

            // Draw nodes
            drawNodes(svg, root, nodeWidth, nodeHeight);
        }

        function drawTanhTree(svg, root, width, height) {
            const nodeWidth = 120;
            const nodeHeight = 60;

            // Use tanh curve for x-position distribution
            calculateTanhPositions(root, width / 2, 50, width / 4, height);

            // Draw curved links
            drawCurvedLinks(svg, root);

            // Draw nodes
            drawNodes(svg, root, nodeWidth, nodeHeight);
        }

        function drawRadialTree(svg, root, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;

            calculateRadialPositions(root, centerX, centerY, radius, 0, 2 * Math.PI);

            drawLinks(svg, root);
            drawNodes(svg, root, 100, 50);
        }

        function calculatePositions(node, x, y, spread) {
            if (!node) return;

            node.x = x;
            node.y = y;

            if (node.left) {
                calculatePositions(node.left, x - spread, y + 100, spread / 2);
            }
            if (node.right) {
                calculatePositions(node.right, x + spread, y + 100, spread / 2);
            }
        }

        function calculateTanhPositions(node, x, y, spread, totalHeight) {
            if (!node) return;

            // Apply tanh transformation to x position based on score
            const tanhFactor = Math.tanh(node.score / 3);
            node.x = x + tanhFactor * spread;
            node.y = y;

            if (node.left) {
                calculateTanhPositions(node.left, x - spread/2, y + 100, spread / 2, totalHeight);
            }
            if (node.right) {
                calculateTanhPositions(node.right, x + spread/2, y + 100, spread / 2, totalHeight);
            }
        }


        function drawLinks(svg, node) {
            if (!node) return;

            if (node.left) {
                const link = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                link.setAttribute('x1', node.x);
                link.setAttribute('y1', node.y);
                link.setAttribute('x2', node.left.x);
                link.setAttribute('y2', node.left.y);
                link.setAttribute('class', 'link negative');
                svg.appendChild(link);
                drawLinks(svg, node.left);
            }

            if (node.right) {
                const link = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                link.setAttribute('x1', node.x);
                link.setAttribute('y1', node.y);
                link.setAttribute('x2', node.right.x);
                link.setAttribute('y2', node.right.y);
                link.setAttribute('class', 'link positive');
                svg.appendChild(link);
                drawLinks(svg, node.right);
            }
        }

        function drawCurvedLinks(svg, node) {
            if (!node) return;

            if (node.left) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const d = `M ${node.x} ${node.y} Q ${node.x} ${node.y + 50}, ${node.left.x} ${node.left.y}`;
                path.setAttribute('d', d);
                path.setAttribute('class', 'link negative');
                svg.appendChild(path);
                drawCurvedLinks(svg, node.left);
            }

            if (node.right) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const d = `M ${node.x} ${node.y} Q ${node.x} ${node.y + 50}, ${node.right.x} ${node.right.y}`;
                path.setAttribute('d', d);
                path.setAttribute('class', 'link positive');
                svg.appendChild(path);
                drawCurvedLinks(svg, node.right);
            }
        }

        function drawNodes(svg, node, width, height) {
            if (!node) return;

            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'node');
            g.setAttribute('id', `node-${node.id}`);
            g.setAttribute('transform', `translate(${node.x - width/2}, ${node.y - height/2})`);

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.setAttribute('rx', 5);
            rect.setAttribute('fill', node.getColor());
            rect.setAttribute('stroke', '#fff');
            g.appendChild(rect);

            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('class', 'question');
            text1.setAttribute('x', width/2);
            text1.setAttribute('y', height/2 - 20);
            text1.textContent = node.question;
            g.appendChild(text1);

            const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text2.setAttribute('class', 'score');
            text2.setAttribute('x', width/2);
            text2.setAttribute('y', height/2);
            text2.textContent = `Score: ${node.score.toFixed(2)}`;
            g.appendChild(text2);

            if (!node.isTerminal) {
                const text3 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text3.setAttribute('class', 'threshold');
                text3.setAttribute('x', width/2);
                text3.setAttribute('y', height/2 + 15);
                text3.textContent = `Threshold: ${node.threshold}`;
                g.appendChild(text3);
            }

            g.addEventListener('click', () => handleNodeClick(node));

            svg.appendChild(g);

            if (node.left) drawNodes(svg, node.left, width, height);
            if (node.right) drawNodes(svg, node.right, width, height);
        }

        function handleNodeClick(node) {
            if (builderMode === 'build') {
                treeBuilder.selectNode(node.id);
                return;
            }

            // Test/Survey mode - show score input modal
            if (node.isTerminal) {
                showFinalResult(node);
                return;
            }

            showScoreModal(node);
        }

        function showScoreModal(node) {
            currentSurveyNode = node;
            document.getElementById('modal-question').textContent = node.question;
            
            // Update scale description
            const scaleDesc = document.getElementById('scale-description');
            scaleDesc.textContent = `Please rate on a scale from ${currentScaleMin} to ${currentScaleMax}`;
            
            // Update slider attributes
            const slider = document.getElementById('score-slider');
            const input = document.getElementById('score-input');
            const display = document.getElementById('score-display');
            
            slider.min = currentScaleMin;
            slider.max = currentScaleMax;
            slider.step = allowDecimals ? '0.1' : '1';
            
            input.min = currentScaleMin;
            input.max = currentScaleMax;
            input.step = allowDecimals ? '0.1' : '1';
            
            // Calculate midpoint for initial value
            const midpoint = (currentScaleMin + currentScaleMax) / 2;
            const initialValue = allowDecimals ? midpoint : Math.round(midpoint);
            slider.value = initialValue;
            input.value = allowDecimals ? initialValue.toFixed(1) : initialValue;
            display.textContent = allowDecimals ? initialValue.toFixed(1) : initialValue;
            
            // Update scale labels based on current scale
            const labelsDiv = document.getElementById('scale-labels');
            const scaleColors = colorScales[currentColorScale];
            
            // Create scale labels
            let labelsHTML = '';
            if (scaleColors && scaleColors.colors) {
                // Show a few key points on the scale
                const keyPoints = [];
                
                // Add min, max, and a few middle points
                keyPoints.push(scaleColors.colors[0]);
                if (scaleColors.colors.length > 4) {
                    keyPoints.push(scaleColors.colors[Math.floor(scaleColors.colors.length / 3)]);
                    keyPoints.push(scaleColors.colors[Math.floor(scaleColors.colors.length / 2)]);
                    keyPoints.push(scaleColors.colors[Math.floor(2 * scaleColors.colors.length / 3)]);
                }
                keyPoints.push(scaleColors.colors[scaleColors.colors.length - 1]);
                
                keyPoints.forEach(point => {
                    labelsHTML += `<span style="color: ${point.color}; font-size: 11px; text-align: center;">
                        <strong>${point.value}</strong><br>${point.label}
                    </span>`;
                });
            } else {
                // Fallback labels
                labelsHTML = `
                    <span style="color: #CC0000;">${currentScaleMin}<br>Lowest</span>
                    <span style="color: #FFF59D;">${midpoint}<br>Middle</span>
                    <span style="color: #0039A6;">${currentScaleMax}<br>Highest</span>
                `;
            }
            labelsDiv.innerHTML = labelsHTML;
            
            updateScoreDisplay(display, midpoint);
            
            document.getElementById('score-modal').style.display = 'block';
            
            // Sync slider and input
            slider.oninput = function() {
                const value = parseFloat(this.value);
                input.value = allowDecimals ? value.toFixed(1) : Math.round(value);
                display.textContent = allowDecimals ? value.toFixed(1) : Math.round(value);
                updateScoreDisplay(display, value);
            };
            
            input.oninput = function() {
                const value = parseFloat(this.value);
                if (!isNaN(value) && value >= currentScaleMin && value <= currentScaleMax) {
                    slider.value = value;
                    display.textContent = allowDecimals ? value.toFixed(1) : Math.round(value);
                    updateScoreDisplay(display, value);
                }
            };
        }

        function updateScoreDisplay(element, value) {
            // Update color based on score using adaptive color scale
            const color = getColorForValue(value, currentColorScale);
            element.style.color = color;
        }

        function submitScore() {
            const score = parseFloat(document.getElementById('score-input').value);
            
            if (isNaN(score) || score < currentScaleMin || score > currentScaleMax) {
                alert(`Please enter a valid score between ${currentScaleMin} and ${currentScaleMax}`);
                return;
            }
            
            // Hide modal
            document.getElementById('score-modal').style.display = 'none';
            
            // Process the score
            if (currentSurveyNode) {
                currentSurveyNode.userScore = score;
                
                // Determine which branch to take
                const takesRightBranch = score >= currentSurveyNode.threshold;
                const nextNode = takesRightBranch ? currentSurveyNode.right : currentSurveyNode.left;
                
                // Record the path
                currentPath.push({
                    node: currentSurveyNode,
                    userScore: score,
                    threshold: currentSurveyNode.threshold,
                    decision: takesRightBranch ? 'right' : 'left',
                    branch: takesRightBranch ? `≥ ${currentSurveyNode.threshold}` : `< ${currentSurveyNode.threshold}`
                });
                
                updatePathDisplay();
                visualizeTree();
                
                if (nextNode) {
                    // Highlight the path taken
                    highlightPath(currentSurveyNode, nextNode);
                    
                    // Auto-advance to next question after a short delay
                    setTimeout(() => {
                        handleNodeClick(nextNode);
                    }, 500);
                } else {
                    // No next node - end of path
                    showPathComplete();
                }
            }
        }

        function cancelScoreInput() {
            document.getElementById('score-modal').style.display = 'none';
            currentSurveyNode = null;
        }

        function showFinalResult(node) {
            const pathScores = currentPath.map(p => p.userScore);
            const avgScore = pathScores.length > 0 ? 
                pathScores.reduce((a, b) => a + b, 0) / pathScores.length : 0;
            
            alert(`Survey Complete!\n\nFinal Node: ${node.question}\n` +
                  `Average Score: ${avgScore.toFixed(2)}\n` +
                  `${getScoreInterpretation(avgScore)}\n\n` +
                  `Path taken: ${currentPath.length} decisions`);
        }

        function showPathComplete() {
            const pathScores = currentPath.map(p => p.userScore);
            const avgScore = pathScores.length > 0 ? 
                pathScores.reduce((a, b) => a + b, 0) / pathScores.length : 0;
            
            alert(`Path Complete!\n\n` +
                  `Average Score: ${avgScore.toFixed(2)}\n` +
                  `${getScoreInterpretation(avgScore)}\n\n` +
                  `Decisions made: ${currentPath.length}\n` +
                  `Path: ${currentPath.map(p => p.decision).join(' → ')}`);
        }

        function getScoreInterpretation(score) {
            if (score >= 4) return "Industry Leader - Exceptional Performance";
            if (score >= 2) return "Above Average - Strong Performance";
            if (score >= 0) return "Average - Meets Standards";
            if (score >= -2) return "Below Average - Needs Improvement";
            if (score >= -4) return "Poor - Significant Issues";
            return "Very Poor - Critical Problems";
        }

        function highlightPath(fromNode, toNode) {
            const svg = document.getElementById('tree-svg');
            const links = svg.querySelectorAll('.link');

            links.forEach(link => {
                if (link.getAttribute('x1') == fromNode.x && link.getAttribute('y1') == fromNode.y &&
                    link.getAttribute('x2') == toNode.x && link.getAttribute('y2') == toNode.y) {
                    link.classList.add('path-highlight');
                }
            });
        }

        function updatePathDisplay() {
            const totalScore = currentPath.reduce((sum, item) => sum + item.node.userScore, 0);
            const avgScore = currentPath.length > 0 ? totalScore / currentPath.length : 0;
            document.getElementById('current-score').textContent = avgScore.toFixed(2);
        }

        function resetPath() {
            currentPath = [];
            const links = document.querySelectorAll('.path-highlight');
            links.forEach(link => link.classList.remove('path-highlight'));
            treeBuilder.nodes.forEach(node => node.userScore = null);
            visualizeTree();
            updatePathDisplay();
        }

        function getTreeDepth(node) {
            if (!node) return 0;
            return 1 + Math.max(getTreeDepth(node.left), getTreeDepth(node.right));
        }

        // New Builder Functions
        function toggleBuilder() {
            const panel = document.getElementById('builder-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            // Hide settings panel if open
            document.getElementById('settings-panel').style.display = 'none';
        }

        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            // Hide builder panel if open
            document.getElementById('builder-panel').style.display = 'none';
        }

        function setBuilderMode(mode) {
            builderMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            treeBuilder.mode = mode;

            if (mode === 'test') {
                currentPath = [];
                updatePathDisplay();
            }
        }

        function addLayer() {
            const layer = treeBuilder.addLayer();
            // Add first node to new layer automatically
            const layerIndex = layer.index;
            treeBuilder.addNodeToLayer(layerIndex, `Layer ${layerIndex} Question`, 0, 0);
            visualizeTree();
        }

        function runSurvey() {
            if (!currentTree) {
                alert('Please build a tree first!');
                return;
            }

            setBuilderMode('test');
            currentPath = [];
            updatePathDisplay();
            alert('Survey mode activated! Click on nodes to navigate through the decision tree.');
        }

        function exportTree() {
            const treeData = treeBuilder.exportTreeData();
            const blob = new Blob([JSON.stringify(treeData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `decision-tree-${Date.now()}.json`;
            a.click();
        }

        function importTree() {
            document.getElementById('import-file').click();
        }

        // Initialize with sample tree
        function initializeSampleTree() {
            // Start with completely empty tree
            // Don't add any nodes - let user build from scratch or generate from data
            visualizeTree();
        }

        // Survey Data Upload Functions
        function uploadSurveyData() {
            // Check if there's existing tree data
            if (treeBuilder && treeBuilder.nodes && treeBuilder.nodes.size > 0) {
                showSaveBeforeUploadDialog();
            } else {
                // No existing tree, proceed directly
                document.getElementById('survey-data-file').click();
            }
        }
        
        function showSaveBeforeUploadDialog() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 5000; display: flex; align-items: center; justify-content: center;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: relative; background: white; padding: 30px; border-radius: 20px; width: 500px; box-shadow: 0 20px 40px rgba(0, 57, 166, 0.3);';
            
            content.innerHTML = `
                <h2 style="margin-bottom: 20px; color: #0039A6;">Save Current Tree?</h2>
                <p style="margin-bottom: 25px; color: #666;">You have an existing tree with ${treeBuilder.nodes.size} nodes. What would you like to do?</p>
                
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button onclick="saveAndUpload()" style="padding: 15px; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 600;">
                        💾 Save Current Tree & Upload New Data
                    </button>
                    
                    <button onclick="uploadWithoutSaving()" style="padding: 15px; background: linear-gradient(135deg, #FF9800, #F57C00); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 600;">
                        📤 Upload Without Saving
                    </button>
                    
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="padding: 15px; background: #666; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 600;">
                        ❌ Cancel
                    </button>
                </div>
            `;
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function saveAndUpload() {
            // Close the dialog
            document.querySelector('[style*="z-index: 5000"]').remove();
            
            // Save the current tree
            saveTreeConfiguration();
            
            // Small delay to ensure save completes, then open file picker
            setTimeout(() => {
                document.getElementById('survey-data-file').click();
            }, 500);
        }
        
        function uploadWithoutSaving() {
            // Close the dialog
            document.querySelector('[style*="z-index: 5000"]').remove();
            
            // Proceed directly to file picker
            document.getElementById('survey-data-file').click();
        }

        function processSurveyDataFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileType = file.name.split('.').pop().toLowerCase();
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                
                if (fileType === 'json') {
                    processSurveyJSON(content);
                } else if (fileType === 'csv') {
                    processSurveyCSV(content);
                } else {
                    alert('Please upload a CSV or JSON file');
                }
                
                // Reset the file input so the same file can be selected again
                event.target.value = '';
            };
            
            reader.readAsText(file);
        }

        function processSurveyJSON(jsonString) {
            try {
                const data = JSON.parse(jsonString);
                const responses = Array.isArray(data) ? data : (data.responses || []);
                
                if (responses.length === 0) {
                    alert('No survey responses found in JSON file');
                    return;
                }
                
                // Show field selector to let user identify ID vs score columns
                showFieldSelector(responses);
                
            } catch (error) {
                alert('Error parsing JSON: ' + error.message);
            }
        }

        function showScaleSelectionDialog(detectedMin, detectedMax, hasDecimals, responses, suggestedScale) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 20px; width: 500px; box-shadow: 0 20px 40px rgba(0, 57, 166, 0.3);';
            
            content.innerHTML = `
                <h2 style="margin-bottom: 20px; color: #0039A6;">Confirm Data Scale</h2>
                <p style="margin-bottom: 20px;">
                    The uploaded data has values ranging from <strong>${detectedMin.toFixed(1)}</strong> to <strong>${detectedMax.toFixed(1)}</strong>.
                    ${hasDecimals ? 'The data contains decimal values.' : 'The data contains only integer values.'}
                </p>
                <p style="margin-bottom: 20px;">${suggestedScale ? 'We detected the scale below. Please confirm or change it:' : 'Please select the appropriate scale for this data:'}</p>
                
                <div style="margin: 20px 0;">
                    <select id="modal-scale-type" style="width: 100%; padding: 10px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 8px;">
                        <option value="-5,5" ${suggestedScale === '-5,5' ? 'selected' : ''}>Bipolar (-5 to 5)</option>
                        <option value="-3,3" ${suggestedScale === '-3,3' ? 'selected' : ''}>Bipolar (-3 to 3)</option>
                        <option value="-2,2" ${suggestedScale === '-2,2' ? 'selected' : ''}>Bipolar (-2 to 2)</option>
                        <option value="0,10" ${suggestedScale === '0,10' ? 'selected' : ''}>0-10 Scale</option>
                        <option value="0,7" ${suggestedScale === '0,7' ? 'selected' : ''}>0-7 Scale</option>
                        <option value="1,7" ${suggestedScale === '1,7' ? 'selected' : ''}>1-7 Likert</option>
                        <option value="1,5" ${suggestedScale === '1,5' ? 'selected' : ''}>1-5 Likert</option>
                    </select>
                </div>
                
                <div style="margin: 20px 0;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="modal-allow-decimals" ${hasDecimals ? 'checked' : ''}>
                        Allow Decimal Values
                    </label>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 30px;">
                    <button id="apply-scale-btn" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #0039A6, #CC0033); color: white; border: none; border-radius: 10px; cursor: pointer;">
                        Apply Scale
                    </button>
                    <button id="cancel-scale-btn" style="flex: 1; padding: 12px; background: #ccc; color: #333; border: none; border-radius: 10px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Add click handler for Cancel button
            document.getElementById('cancel-scale-btn').onclick = function() {
                modal.remove();
            };
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            // Add click handler for Apply button
            document.getElementById('apply-scale-btn').onclick = function() {
                const selectedScale = document.getElementById('modal-scale-type').value;
                const allowDec = document.getElementById('modal-allow-decimals').checked;
                
                // Apply the selected scale
                document.getElementById('scale-type').value = selectedScale;
                updateScaleType();
                
                document.getElementById('allow-decimals').checked = allowDec;
                allowDecimals = allowDec;
                
                // Remove modal
                modal.remove();
                
                // Update color scale
                currentColorScale = detectDataRange(responses);
                updateColorLegend();
                
                // Continue processing the data
                continueProcessingData(responses);
            };
        }

        function applyScaleSelection(responsesJson, button) {
            const modal = button.closest('[style*="position: fixed"]');
            const selectedScale = modal.querySelector('#modal-scale-type').value;
            const allowDec = modal.querySelector('#modal-allow-decimals').checked;
            
            // Apply the selected scale
            document.getElementById('scale-type').value = selectedScale;
            updateScaleType();
            
            document.getElementById('allow-decimals').checked = allowDec;
            allowDecimals = allowDec;
            
            // Remove modal
            modal.remove();
            
            // Continue processing with the selected scale
            const responses = JSON.parse(responsesJson);
            
            // Update color scale
            currentColorScale = detectDataRange(responses);
            updateColorLegend();
            
            // Continue processing the data
            continueProcessingData(responses);
        }

        function processSurveyCSV(csvString) {
            try {
                const lines = csvString.trim().split('\n');
                const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
                    const row = {};
                    headers.forEach((header, index) => {
                        const value = values[index];
                        // Try to parse as number, otherwise keep as string
                        row[header] = isNaN(parseFloat(value)) ? value : parseFloat(value);
                    });
                    data.push(row);
                }
                
                // Show field selector for CSV data
                showFieldSelector(data);
            } catch (error) {
                alert('Error parsing CSV: ' + error.message);
            }
        }
        
        function showFieldSelector(rawData) {
            if (!rawData || rawData.length === 0) return;
            
            // Get all field names from first record
            const firstRecord = rawData[0];
            const fields = Object.keys(firstRecord);
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000;';
            modal.id = 'field-selector-modal';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 20px; width: 700px; max-height: 85vh; overflow-y: auto;';
            
            // Build ID selector dropdown
            let idOptionsHtml = '<option value="">None (Auto-generate)</option>';
            fields.forEach(field => {
                idOptionsHtml += `<option value="${field}">${field}</option>`;
            });
            
            // Build score fields checkboxes
            let scoreFieldsHtml = '';
            fields.forEach((field, index) => {
                const sampleValue = firstRecord[field];
                const isNumeric = !isNaN(parseFloat(sampleValue));
                
                scoreFieldsHtml += `
                    <div style="margin: 8px 0; padding: 8px; border: 1px solid #eee; border-radius: 6px; background: ${index % 2 ? '#f9f9f9' : 'white'};">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="score-field-${field.replace(/[^a-zA-Z0-9]/g, '_')}" 
                                value="${field}" 
                                ${isNumeric && parseFloat(sampleValue) >= -10 && parseFloat(sampleValue) <= 10 ? 'checked' : ''}
                                style="width: 18px; height: 18px;">
                            <div style="flex: 1;">
                                <strong>${field}</strong>
                                <div style="color: #666; font-size: 12px;">
                                    Sample value: ${sampleValue} ${isNumeric ? '(numeric)' : '(text)'}
                                </div>
                            </div>
                        </label>
                    </div>
                `;
            });
            
            content.innerHTML = `
                <h2 style="margin-bottom: 20px; color: #0039A6;">Configure Data Import</h2>
                
                <div style="margin-bottom: 25px; padding: 15px; background: #f0f8ff; border-radius: 8px;">
                    <h3 style="margin-bottom: 10px; color: #0039A6;">Step 1: Select ID/Label Field (Optional)</h3>
                    <p style="margin-bottom: 10px; color: #666;">Choose which field contains the respondent ID or label:</p>
                    <select id="id-field-selector" style="width: 100%; padding: 10px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 8px;">
                        ${idOptionsHtml}
                    </select>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h3 style="margin-bottom: 10px; color: #0039A6;">Step 2: Select Survey Score Fields</h3>
                    <p style="margin-bottom: 10px; color: #666;">Check all fields that contain survey scores (uncheck ID fields and other non-score data):</p>
                    <div style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 8px; background: white;">
                        ${scoreFieldsHtml}
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button id="process-fields-btn" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #0039A6, #CC0033); color: white; border: none; border-radius: 10px; cursor: pointer;">
                        Process Data
                    </button>
                    <button id="cancel-field-selector" style="flex: 1; padding: 12px; background: #ccc; color: #333; border: none; border-radius: 10px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Add click handler for Cancel button
            document.getElementById('cancel-field-selector').onclick = function() {
                modal.remove();
            };
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            // Add click handler for Process button
            document.getElementById('process-fields-btn').onclick = function() {
                const processedData = [];
                const selectedIdField = document.getElementById('id-field-selector').value;
                
                // Get all checked score fields
                const scoreFields = [];
                fields.forEach(field => {
                    const sanitizedField = field.replace(/[^a-zA-Z0-9]/g, '_');
                    const checkbox = document.getElementById(`score-field-${sanitizedField}`);
                    if (checkbox && checkbox.checked) {
                        scoreFields.push(field);
                    }
                });
                
                if (scoreFields.length === 0) {
                    alert('Please select at least one score field');
                    return;
                }
                
                // Process each record
                rawData.forEach((record, index) => {
                    const processedRecord = {};
                    
                    // Add ID if selected
                    if (selectedIdField) {
                        processedRecord.respondentId = record[selectedIdField];
                    } else {
                        processedRecord.respondentId = `Respondent_${index + 1}`;
                    }
                    
                    // Add all selected score fields
                    let hasValidScores = false;
                    scoreFields.forEach(field => {
                        const value = record[field];
                        if (value !== null && value !== undefined && value !== '') {
                            const numValue = parseFloat(value);
                            if (!isNaN(numValue)) {
                                processedRecord[field] = numValue;
                                hasValidScores = true;
                            }
                        }
                    });
                    
                    // Only add if we have at least one valid score
                    if (hasValidScores) {
                        processedData.push(processedRecord);
                    }
                });
                
                modal.remove();
                
                if (processedData.length > 0) {
                    console.log('Processing data with', processedData.length, 'records');
                    console.log('Sample record:', processedData[0]);
                    processUploadedData(processedData);
                } else {
                    alert('No valid survey data found after processing');
                }
            };
        }

        function processUploadedData(responses) {
            // Check if there's existing data and ask for confirmation
            if (window.surveyData && window.surveyData.length > 0) {
                if (!confirm('There is existing survey data loaded. Do you want to replace it with the new data?')) {
                    return; // User clicked No/Cancel
                }
            }
            
            // Store the uploaded data globally
            window.uploadedSurveyData = responses;
            
            // Detect the data range
            let detectedMin = Infinity;
            let detectedMax = -Infinity;
            let hasDecimals = false;
            
            responses.forEach(response => {
                Object.keys(response).forEach(key => {
                    if (key !== 'respondentId' && !isNaN(parseFloat(response[key]))) {
                        const value = parseFloat(response[key]);
                        detectedMin = Math.min(detectedMin, value);
                        detectedMax = Math.max(detectedMax, value);
                        if (value % 1 !== 0) {
                            hasDecimals = true;
                        }
                    }
                });
            });
            
            // Try to match to a known scale
            const scaleMatches = {
                '-5,5': (min, max) => min >= -5 && max <= 5 && min < -3,
                '-3,3': (min, max) => min >= -3 && max <= 3 && min < -1,
                '-2,2': (min, max) => min >= -2 && max <= 2 && min < 0,
                '0,10': (min, max) => min >= 0 && max <= 10 && max > 7,
                '0,7': (min, max) => min >= 0 && max <= 7 && max > 5,
                '1,7': (min, max) => min >= 1 && max <= 7,
                '1,5': (min, max) => min >= 1 && max <= 5
            };
            
            let detectedScale = null;
            for (const [scale, matcher] of Object.entries(scaleMatches)) {
                if (matcher(detectedMin, detectedMax)) {
                    detectedScale = scale;
                    break;
                }
            }
            
            // Always ask the user to confirm or select the scale
            console.log('Showing scale selection dialog. Detected:', detectedScale, 'Min:', detectedMin, 'Max:', detectedMax);
            showScaleSelectionDialog(detectedMin, detectedMax, hasDecimals, responses, detectedScale);
        }
        
        function continueProcessingData(responses) {
            // Store data globally for visualization
            surveyData = responses;
            
            // Check if tree exists, if not offer to generate one
            if (treeBuilder.layers.length === 0 || treeBuilder.nodes.size === 0) {
                // Show tree generation options
                showTreeGenerationOptions(responses);
                return;
            }
            
            // Automatically process responses through existing tree
            window.batchResults = [];
            
            responses.forEach((response, index) => {
                const result = {
                    respondentId: response.respondentId || `respondent_${index + 1}`,
                    path: [],
                    totalScore: 0
                };
                
                // Get all available keys from response (excluding respondentId)
                const scoreKeys = Object.keys(response).filter(key => key !== 'respondentId');
                
                // Traverse the tree, matching questions to response keys
                let currentNode = treeBuilder.layers[0]?.nodes[0];
                let keyIndex = 0;
                
                while (currentNode && keyIndex < scoreKeys.length) {
                    // Try to find a matching score in the response
                    let score = null;
                    
                    // First try exact match with node question
                    if (response[currentNode.question] !== undefined) {
                        score = parseFloat(response[currentNode.question]);
                    }
                    // Then try using keys in order
                    else if (scoreKeys[keyIndex]) {
                        score = parseFloat(response[scoreKeys[keyIndex]]);
                        keyIndex++;
                    }
                    
                    // Default to 0 if no score found
                    if (score === null || isNaN(score)) {
                        score = 0;
                    }
                    
                    // Determine branch direction
                    const decision = score >= currentNode.threshold ? 'right' : 'left';
                    
                    result.path.push({
                        nodeId: currentNode.id,
                        question: currentNode.question,
                        score: score,
                        threshold: currentNode.threshold,
                        decision: decision
                    });
                    
                    result.totalScore += score;
                    
                    // Move to next node
                    if (currentNode.isTerminal) {
                        break;
                    }
                    
                    if (decision === 'right' && currentNode.right) {
                        currentNode = currentNode.right;
                    } else if (decision === 'left' && currentNode.left) {
                        currentNode = currentNode.left;
                    } else {
                        break;
                    }
                }
                
                if (result.path.length > 0) {
                    window.batchResults.push(result);
                }
            });
            
            // Update visualizations
            console.log(`Processed ${window.batchResults.length} responses`);
            
            // Show results summary
            showUploadResultsSummary();
            
            // Force update the tree visualization to show the data
            visualizeTree();
            
            // If in a data visualization mode, update it
            const vizMode = document.getElementById('viz-mode').value;
            if (vizMode === 'heatmap') {
                visualizePathTraversals(getEdgeTraversals(), window.batchResults.length);
            } else if (vizMode === 'distribution') {
                drawScoreDistribution();
            }
        }
        
        function showUploadResultsSummary() {
            if (!window.batchResults || window.batchResults.length === 0) return;
            
            // Calculate summary statistics
            const pathCounts = {};
            let totalScore = 0;
            const scores = [];
            
            window.batchResults.forEach(result => {
                const pathKey = result.path.map(p => p.decision).join(' → ');
                pathCounts[pathKey] = (pathCounts[pathKey] || 0) + 1;
                
                result.path.forEach(step => {
                    scores.push(step.score);
                    totalScore += step.score;
                });
            });
            
            const avgScore = scores.length > 0 ? (totalScore / scores.length).toFixed(2) : 0;
            const uniquePaths = Object.keys(pathCounts).length;
            const mostCommonPath = Object.entries(pathCounts).sort((a, b) => b[1] - a[1])[0];
            
            // Simple notification instead of complex modal
            const message = `
✅ Successfully processed ${window.batchResults.length} responses
📊 Average Score: ${avgScore}
🛤️ Unique Paths: ${uniquePaths}
🎯 Most Common Path: ${mostCommonPath ? mostCommonPath[0] : 'N/A'} (${mostCommonPath ? mostCommonPath[1] : 0} responses)

You can now:
• View Statistical Analysis
• View Shannon Information Theory
• Change visualization to Heatmap or Distribution
• Auto-calculate thresholds based on data`;
            
            alert(message);
            
            // Add button to auto-calculate thresholds if not already present
            if (!document.getElementById('auto-threshold-btn')) {
                const buttonContainer = document.querySelector('.control-group');
                if (buttonContainer) {
                    const autoThresholdBtn = document.createElement('button');
                    autoThresholdBtn.id = 'auto-threshold-btn';
                    autoThresholdBtn.className = 'btn';
                    autoThresholdBtn.textContent = '🎯 Auto-Calculate Thresholds';
                    autoThresholdBtn.onclick = autoCalculateAllThresholds;
                    autoThresholdBtn.style.background = 'linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant))';
                    buttonContainer.appendChild(autoThresholdBtn);
                }
            }
        }
        
        function showDataMappingModal(data, format, headers = null) {
            // Extract all possible column names from the data
            const columns = headers || (data.length > 0 ? Object.keys(data[0]) : []);
            
            // Get all questions from the tree
            const questions = [];
            treeBuilder.nodes.forEach(node => {
                if (!node.isTerminal) {
                    questions.push({
                        id: node.id,
                        question: node.question,
                        depth: node.depth
                    });
                }
            });
            
            // Create mapping modal
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; overflow-y: auto;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; width: 600px; max-height: 80vh; overflow-y: auto;';
            
            let html = `
                <h2>Map Data Columns to Survey Questions</h2>
                <p>Match your data columns to the decision tree questions:</p>
                <div style="margin: 20px 0;">
                    <label><strong>Respondent ID Column:</strong></label>
                    <select id="respondent-id-column" style="width: 100%; margin: 5px 0; padding: 5px;">
                        <option value="">-- Select ID Column --</option>
                        ${columns.map(col => `<option value="${col}">${col}</option>`).join('')}
                    </select>
                </div>
                <hr>
            `;
            
            questions.sort((a, b) => a.depth - b.depth).forEach(q => {
                html += `
                    <div style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                        <label><strong>Layer ${q.depth}: ${q.question}</strong></label>
                        <select data-question-id="${q.id}" class="column-mapping" style="width: 100%; margin: 5px 0; padding: 5px;">
                            <option value="">-- Skip This Question --</option>
                            ${columns.map(col => `<option value="${col}">${col}</option>`).join('')}
                        </select>
                    </div>
                `;
            });
            
            html += `
                <div style="margin-top: 20px; display: flex; gap: 10px;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="padding: 10px 20px; background: #ccc; border: none; border-radius: 5px; cursor: pointer;">Cancel</button>
                    <button onclick="applyDataMapping(${JSON.stringify(data).replace(/"/g, '&quot;')})" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Apply Mapping</button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function applyDataMapping(data) {
            const idColumn = document.getElementById('respondent-id-column').value;
            const mappings = {};
            
            document.querySelectorAll('.column-mapping').forEach(select => {
                const questionId = select.getAttribute('data-question-id');
                const column = select.value;
                if (column) {
                    mappings[questionId] = column;
                }
            });
            
            // Close modal
            document.querySelector('[style*="position: fixed"][style*="z-index: 3000"]').remove();
            
            // Process each response through the tree
            const results = [];
            data.forEach((response, index) => {
                const respondentId = idColumn ? response[idColumn] : `Respondent_${index + 1}`;
                const path = runSurveyWithData(response, mappings);
                results.push({
                    respondentId: respondentId,
                    response: response,
                    path: path
                });
            });
            
            // Show results
            displayBatchResults(results);
        }

        function runSurveyWithData(responseData, mappings) {
            const path = [];
            let currentNode = treeBuilder.layers[0]?.nodes[0]; // Start at root
            
            while (currentNode && !currentNode.isTerminal) {
                const column = mappings[currentNode.id];
                const score = column ? parseFloat(responseData[column]) : 0;
                
                if (isNaN(score)) {
                    // Skip if no valid score
                    break;
                }
                
                // Record this step
                const takesRightBranch = score >= currentNode.threshold;
                path.push({
                    nodeId: currentNode.id,
                    question: currentNode.question,
                    score: score,
                    threshold: currentNode.threshold,
                    decision: takesRightBranch ? 'right' : 'left'
                });
                
                // Move to next node
                currentNode = takesRightBranch ? currentNode.right : currentNode.left;
            }
            
            return path;
        }

        function displayBatchResults(results) {
            // Store results globally for visualization
            window.batchResults = results;
            
            // Create results display
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; overflow-y: auto;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 10%; left: 50%; transform: translateX(-50%); background: white; padding: 30px; border-radius: 15px; width: 80%; max-width: 900px; max-height: 80vh; overflow-y: auto; margin-bottom: 20px;';
            
            // Analyze results
            const pathCounts = {};
            const nodeScores = {};
            const edgeTraversals = {}; // Track how many times each edge was traversed
            
            results.forEach(result => {
                const pathKey = result.path.map(p => p.decision).join(' → ');
                pathCounts[pathKey] = (pathCounts[pathKey] || 0) + 1;
                
                result.path.forEach((step, index) => {
                    if (!nodeScores[step.nodeId]) {
                        nodeScores[step.nodeId] = {
                            question: step.question,
                            scores: []
                        };
                    }
                    nodeScores[step.nodeId].scores.push(step.score);
                    
                    // Track edge traversals for visualization
                    if (index < result.path.length - 1) {
                        const nextStep = result.path[index + 1];
                        const edgeKey = `${step.nodeId}_${nextStep.nodeId}`;
                        edgeTraversals[edgeKey] = (edgeTraversals[edgeKey] || 0) + 1;
                    }
                });
            });
            
            // Update visualization with path highlights
            visualizePathTraversals(edgeTraversals, results.length);
            
            let html = `
                <h2>Batch Survey Results</h2>
                <p><strong>Total Responses Processed:</strong> ${results.length}</p>
                
                <h3>Path Distribution</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Path</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Count</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Percentage</th>
                    </tr>
            `;
            
            Object.entries(pathCounts).sort((a, b) => b[1] - a[1]).forEach(([path, count]) => {
                const percentage = ((count / results.length) * 100).toFixed(1);
                html += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">${path}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${count}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${percentage}%</td>
                    </tr>
                `;
            });
            
            html += `</table>
                
                <h3>Question Statistics</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Question</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Responses</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Avg Score</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Min</th>
                        <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Max</th>
                    </tr>
            `;
            
            Object.entries(nodeScores).forEach(([nodeId, data]) => {
                const avg = (data.scores.reduce((a, b) => a + b, 0) / data.scores.length).toFixed(2);
                const min = Math.min(...data.scores).toFixed(1);
                const max = Math.max(...data.scores).toFixed(1);
                
                html += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">${data.question}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.scores.length}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${avg}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${min}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${max}</td>
                    </tr>
                `;
            });
            
            html += `</table>
                <div style="margin-top: 20px; display: flex; gap: 10px;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="padding: 10px 20px; background: #ccc; border: none; border-radius: 5px; cursor: pointer;">Close</button>
                    <button onclick="exportBatchResults(${JSON.stringify(results).replace(/"/g, '&quot;')})" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Export Results</button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function exportBatchResults(results) {
            const exportData = {
                timestamp: new Date().toISOString(),
                totalResponses: results.length,
                results: results
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `survey-batch-results-${Date.now()}.json`;
            a.click();
        }

        function visualizePathTraversals(edgeTraversals, totalResponses) {
            // Redraw the tree with path thickness based on traversal counts
            const container = document.getElementById('tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const svg = document.getElementById('tree-svg');
            
            // Clear and redraw with highlights
            svg.innerHTML = '';
            
            // Recalculate positions
            const layerHeight = height / (treeBuilder.layers.length + 1);
            
            if (treeBuilder.layers.length > 0 && treeBuilder.layers[0].nodes.length > 0) {
                treeBuilder.layers[0].nodes[0].x = width / 2;
                treeBuilder.layers[0].nodes[0].y = layerHeight;
            }
            
            for (let layerIndex = 1; layerIndex < treeBuilder.layers.length; layerIndex++) {
                const layer = treeBuilder.layers[layerIndex];
                const prevLayer = treeBuilder.layers[layerIndex - 1];
                
                layer.nodes.forEach(node => {
                    let positioned = false;
                    prevLayer.nodes.forEach(parent => {
                        if (parent.leftId === node.id) {
                            node.x = parent.x - (width / Math.pow(2, layerIndex + 1));
                            node.y = layerHeight * (layerIndex + 1);
                            positioned = true;
                        } else if (parent.rightId === node.id) {
                            node.x = parent.x + (width / Math.pow(2, layerIndex + 1));
                            node.y = layerHeight * (layerIndex + 1);
                            positioned = true;
                        }
                    });
                    
                    if (!positioned) {
                        const unconnectedIndex = layer.nodes.filter(n => !n.parentId).indexOf(node);
                        node.x = 50 + (unconnectedIndex * 150);
                        node.y = layerHeight * (layerIndex + 1);
                    }
                });
            }
            
            // Draw connections with varying thickness based on traversals
            treeBuilder.nodes.forEach(node => {
                if (node.left) {
                    const edgeKey = `${node.id}_${node.left.id}`;
                    const traversals = edgeTraversals[edgeKey] || 0;
                    const thickness = Math.max(1, Math.min(10, traversals / totalResponses * 20));
                    const opacity = Math.max(0.3, Math.min(1, traversals / totalResponses * 2));
                    
                    drawWeightedLink(svg, node, node.left, 'negative', `< ${node.threshold}`, thickness, opacity, traversals);
                }
                if (node.right) {
                    const edgeKey = `${node.id}_${node.right.id}`;
                    const traversals = edgeTraversals[edgeKey] || 0;
                    const thickness = Math.max(1, Math.min(10, traversals / totalResponses * 20));
                    const opacity = Math.max(0.3, Math.min(1, traversals / totalResponses * 2));
                    
                    drawWeightedLink(svg, node, node.right, 'positive', `≥ ${node.threshold}`, thickness, opacity, traversals);
                }
            });
            
            // Draw nodes with heat map colors based on average scores
            treeBuilder.nodes.forEach(node => {
                const nodeData = window.batchResults ? 
                    window.batchResults.reduce((acc, result) => {
                        const step = result.path.find(p => p.nodeId === node.id);
                        if (step) {
                            acc.scores.push(step.score);
                            acc.count++;
                        }
                        return acc;
                    }, {scores: [], count: 0}) : null;
                
                drawHeatmapNode(svg, node, 120, 60, nodeData);
            });
        }

        function drawWeightedLink(svg, fromNode, toNode, type, label, thickness, opacity, traversals) {
            const link = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            link.setAttribute('x1', String(fromNode.x));
            link.setAttribute('y1', String(fromNode.y));
            link.setAttribute('x2', String(toNode.x));
            link.setAttribute('y2', String(toNode.y));
            link.setAttribute('stroke', type === 'negative' ? '#f44336' : '#4CAF50');
            link.setAttribute('stroke-width', String(thickness));
            link.setAttribute('stroke-opacity', String(opacity));
            svg.appendChild(link);
            
            // Add label with traversal count
            const midX = (fromNode.x + toNode.x) / 2;
            const midY = (fromNode.y + toNode.y) / 2;
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', String(midX));
            text.setAttribute('y', String(midY - 5));
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', type === 'negative' ? '#f44336' : '#4CAF50');
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', 'bold');
            text.textContent = `${label} (${traversals})`;
            svg.appendChild(text);
        }

        function drawHeatmapNode(svg, node, width, height, nodeData) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'node');
            g.setAttribute('id', `node-${node.id}`);
            g.setAttribute('transform', `translate(${node.x - width/2}, ${node.y - height/2})`);
            
            // Calculate color based on average score if data exists
            let fillColor = '#888888';
            let avgScore = 0;
            if (nodeData && nodeData.scores.length > 0) {
                avgScore = nodeData.scores.reduce((a, b) => a + b, 0) / nodeData.scores.length;
                
                // Heat map coloring
                if (avgScore >= 3) fillColor = '#4CAF50';
                else if (avgScore >= 1) fillColor = '#8BC34A';
                else if (avgScore >= -1) fillColor = '#FFC107';
                else if (avgScore >= -3) fillColor = '#FF9800';
                else fillColor = '#f44336';
            }
            
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', String(width));
            rect.setAttribute('height', String(height));
            rect.setAttribute('rx', '5');
            rect.setAttribute('fill', fillColor);
            rect.setAttribute('stroke', '#fff');
            rect.setAttribute('stroke-width', '2');
            g.appendChild(rect);
            
            // Question text
            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('class', 'question');
            text1.setAttribute('x', String(width/2));
            text1.setAttribute('y', String(height/2 - 10));
            text1.setAttribute('text-anchor', 'middle');
            text1.setAttribute('fill', 'white');
            text1.textContent = node.question.substring(0, 20);
            g.appendChild(text1);
            
            // Stats text
            const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text2.setAttribute('class', 'score');
            text2.setAttribute('x', String(width/2));
            text2.setAttribute('y', String(height/2 + 5));
            text2.setAttribute('text-anchor', 'middle');
            text2.setAttribute('fill', 'white');
            if (nodeData && nodeData.count > 0) {
                text2.textContent = `Avg: ${avgScore.toFixed(1)} (n=${nodeData.count})`;
            } else {
                text2.textContent = `Thr: ${node.threshold}`;
            }
            g.appendChild(text2);
            
            g.addEventListener('click', () => handleNodeClick(node));
            svg.appendChild(g);
        }

        // Initialize batchResults if not exists
        if (!window.batchResults) {
            window.batchResults = [];
        }
        
        // Statistical Analysis Functions
        function showStatisticalAnalysis() {
            const stats = calculateComprehensiveStatistics();
            displayStatisticalAnalysisModal(stats);
        }

        function calculateComprehensiveStatistics() {
            const stats = {
                totalResponses: window.batchResults.length,
                pathAnalysis: {},
                nodeAnalysis: {},
                branchAnalysis: {},
                correlations: {},
                overallMetrics: {},
                treeStructure: analyzeTreeStructure()
            };

            // Path analysis
            const pathGroups = {};
            window.batchResults.forEach(result => {
                const pathKey = result.path.map(p => p.decision).join(' → ');
                if (!pathGroups[pathKey]) {
                    pathGroups[pathKey] = {
                        count: 0,
                        scores: [],
                        respondents: []
                    };
                }
                pathGroups[pathKey].count++;
                pathGroups[pathKey].respondents.push(result.respondentId);
                result.path.forEach(step => {
                    pathGroups[pathKey].scores.push(step.score);
                });
            });

            // Calculate path statistics
            Object.entries(pathGroups).forEach(([path, data]) => {
                const scores = data.scores;
                stats.pathAnalysis[path] = {
                    count: data.count,
                    percentage: (data.count / stats.totalResponses * 100).toFixed(2),
                    avgScore: (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2),
                    stdDev: calculateStdDev(scores).toFixed(2),
                    confidence95: calculateConfidenceInterval(scores, 0.95)
                };
            });

            // Node analysis
            treeBuilder.nodes.forEach(node => {
                const nodeScores = [];
                const branchDecisions = { left: 0, right: 0 };
                
                window.batchResults.forEach(result => {
                    const step = result.path.find(p => p.nodeId === node.id);
                    if (step) {
                        nodeScores.push(step.score);
                        if (step.decision === 'left') branchDecisions.left++;
                        else branchDecisions.right++;
                    }
                });

                if (nodeScores.length > 0) {
                    stats.nodeAnalysis[node.id] = {
                        question: node.question,
                        sampleSize: nodeScores.length,
                        mean: (nodeScores.reduce((a, b) => a + b, 0) / nodeScores.length).toFixed(2),
                        median: calculateMedian(nodeScores).toFixed(2),
                        mode: calculateMode(nodeScores),
                        stdDev: calculateStdDev(nodeScores).toFixed(2),
                        skewness: calculateSkewness(nodeScores).toFixed(3),
                        kurtosis: calculateKurtosis(nodeScores).toFixed(3),
                        min: Math.min(...nodeScores).toFixed(1),
                        max: Math.max(...nodeScores).toFixed(1),
                        quartiles: calculateQuartiles(nodeScores),
                        leftBranch: branchDecisions.left,
                        rightBranch: branchDecisions.right,
                        branchRatio: branchDecisions.right > 0 ? 
                            (branchDecisions.left / branchDecisions.right).toFixed(2) : 'N/A'
                    };
                }
            });

            // Overall metrics
            const allScores = [];
            window.batchResults.forEach(result => {
                result.path.forEach(step => {
                    allScores.push(step.score);
                });
            });

            stats.overallMetrics = {
                totalDataPoints: allScores.length,
                overallMean: (allScores.reduce((a, b) => a + b, 0) / allScores.length).toFixed(2),
                overallStdDev: calculateStdDev(allScores).toFixed(2),
                overallMedian: calculateMedian(allScores).toFixed(2),
                uniquePaths: Object.keys(pathGroups).length,
                avgPathLength: (window.batchResults.reduce((sum, r) => sum + r.path.length, 0) / window.batchResults.length).toFixed(2),
                completionRate: '100%' // All uploaded responses are complete
            };

            // Calculate correlations between sequential nodes
            stats.correlations = calculateNodeCorrelations();

            return stats;
        }

        function calculateStdDev(values) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            return Math.sqrt(variance);
        }

        function calculateMedian(values) {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }

        function calculateMode(values) {
            const counts = {};
            values.forEach(v => {
                const rounded = v.toFixed(1);
                counts[rounded] = (counts[rounded] || 0) + 1;
            });
            
            let maxCount = 0;
            let modes = [];
            Object.entries(counts).forEach(([value, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    modes = [value];
                } else if (count === maxCount) {
                    modes.push(value);
                }
            });
            
            return modes.join(', ');
        }

        function calculateQuartiles(values) {
            const sorted = [...values].sort((a, b) => a - b);
            const q1Index = Math.floor(sorted.length * 0.25);
            const q3Index = Math.floor(sorted.length * 0.75);
            
            return {
                q1: sorted[q1Index].toFixed(2),
                q3: sorted[q3Index].toFixed(2),
                iqr: (sorted[q3Index] - sorted[q1Index]).toFixed(2)
            };
        }

        function calculateSkewness(values) {
            const n = values.length;
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const m3 = values.reduce((a, b) => a + Math.pow(b - mean, 3), 0) / n;
            const m2 = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
            return m3 / Math.pow(m2, 1.5);
        }

        function calculateKurtosis(values) {
            const n = values.length;
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const m4 = values.reduce((a, b) => a + Math.pow(b - mean, 4), 0) / n;
            const m2 = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
            return (m4 / Math.pow(m2, 2)) - 3;
        }

        function calculateConfidenceInterval(values, confidence = 0.95) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const stdErr = calculateStdDev(values) / Math.sqrt(values.length);
            const z = 1.96; // For 95% confidence
            
            return {
                lower: (mean - z * stdErr).toFixed(2),
                upper: (mean + z * stdErr).toFixed(2)
            };
        }

        function calculateNodeCorrelations() {
            const correlations = {};
            
            // Find pairs of nodes that appear sequentially in paths
            const nodePairs = {};
            window.batchResults.forEach(result => {
                for (let i = 0; i < result.path.length - 1; i++) {
                    const node1 = result.path[i];
                    const node2 = result.path[i + 1];
                    const pairKey = `${node1.nodeId}_${node2.nodeId}`;
                    
                    if (!nodePairs[pairKey]) {
                        nodePairs[pairKey] = {
                            node1Scores: [],
                            node2Scores: [],
                            node1Question: node1.question,
                            node2Question: node2.question
                        };
                    }
                    
                    nodePairs[pairKey].node1Scores.push(node1.score);
                    nodePairs[pairKey].node2Scores.push(node2.score);
                }
            });
            
            // Calculate Pearson correlation for each pair
            Object.entries(nodePairs).forEach(([key, data]) => {
                if (data.node1Scores.length > 1) {
                    const correlation = calculatePearsonCorrelation(data.node1Scores, data.node2Scores);
                    correlations[key] = {
                        node1: data.node1Question,
                        node2: data.node2Question,
                        correlation: correlation.toFixed(3),
                        sampleSize: data.node1Scores.length,
                        significance: Math.abs(correlation) > 0.7 ? 'Strong' : 
                                    Math.abs(correlation) > 0.4 ? 'Moderate' : 'Weak'
                    };
                }
            });
            
            return correlations;
        }

        function calculatePearsonCorrelation(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
            const sumX2 = x.reduce((a, b) => a + b * b, 0);
            const sumY2 = y.reduce((a, b) => a + b * b, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }

        function displayStatisticalAnalysisModal(stats) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 4000; overflow-y: auto;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: white; padding: 30px; border-radius: 15px; width: 90%; max-width: 1000px; max-height: 90vh; overflow-y: auto; margin-bottom: 20px;';
            
            let html = `
                <h2>Statistical Analysis Report</h2>
                <p><strong>Total Responses:</strong> ${stats.totalResponses || 'No data yet - Run surveys or upload data'}</p>
                
                <h3>Tree Structure Analysis</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Total Nodes:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.treeStructure.totalNodes}</td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Total Layers:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.treeStructure.totalLayers}</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Possible Paths:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.treeStructure.possiblePaths}</td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Terminal Nodes:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.treeStructure.terminalNodes.length}</td>
                    </tr>
                </table>
                
                ${stats.totalResponses > 0 ? `<h3>Overall Metrics</h3>` : '<h3>Overall Metrics (No Data Yet)</h3>'}
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Total Data Points:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.overallMetrics.totalDataPoints}</td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Mean Score:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.overallMetrics.overallMean}</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Median Score:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.overallMetrics.overallMedian}</td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Std Deviation:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.overallMetrics.overallStdDev}</td>
                    </tr>
                    <tr style="background: #f5f5f5;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Unique Paths:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.overallMetrics.uniquePaths}</td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Avg Path Length:</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${stats.overallMetrics.avgPathLength}</td>
                    </tr>
                </table>
                
                <h3>Node-by-Node Analysis</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 12px;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Question</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">n</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Mean</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Median</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">StdDev</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Min/Max</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Q1/Q3</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Skewness</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Branch L/R</th>
                    </tr>
            `;
            
            Object.values(stats.nodeAnalysis).forEach(node => {
                html += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">${node.question.substring(0, 30)}...</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.sampleSize}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.mean}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.median}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.stdDev}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.min}/${node.max}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.quartiles.q1}/${node.quartiles.q3}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.skewness}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.leftBranch}/${node.rightBranch}</td>
                    </tr>
                `;
            });
            
            html += `</table>
                
                <h3>Path Analysis</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Path</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Count</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">%</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Avg Score</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Std Dev</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">95% CI</th>
                    </tr>
            `;
            
            Object.entries(stats.pathAnalysis)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10)
                .forEach(([path, data]) => {
                    html += `
                        <tr>
                            <td style="padding: 10px; border: 1px solid #ddd;">${path}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.count}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.percentage}%</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.avgScore}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.stdDev}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">[${data.confidence95.lower}, ${data.confidence95.upper}]</td>
                        </tr>
                    `;
                });
            
            html += `</table>
                
                <h3>Sequential Node Correlations</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Node 1</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Node 2</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Correlation</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Strength</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">n</th>
                    </tr>
            `;
            
            Object.values(stats.correlations).forEach(corr => {
                html += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">${corr.node1.substring(0, 25)}...</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">${corr.node2.substring(0, 25)}...</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${corr.correlation}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${corr.significance}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${corr.sampleSize}</td>
                    </tr>
                `;
            });
            
            html += `</table>
                <div style="margin-top: 20px; display: flex; gap: 10px;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="padding: 10px 20px; background: #ccc; border: none; border-radius: 5px; cursor: pointer;">Close</button>
                    <button onclick="exportStatisticalAnalysis(${JSON.stringify(stats).replace(/"/g, '&quot;')})" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Export Analysis</button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Add close X button after setting innerHTML
            const closeX = document.createElement('button');
            closeX.innerHTML = '×';
            closeX.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeX.onmouseover = () => { closeX.style.background = '#e0e0e0'; closeX.style.color = '#000'; };
            closeX.onmouseout = () => { closeX.style.background = '#f0f0f0'; closeX.style.color = '#666'; };
            closeX.onclick = function() { 
                const parentModal = this.closest('[style*="position: fixed"]');
                if (parentModal) parentModal.remove(); 
            };
            content.appendChild(closeX);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function exportStatisticalAnalysis(stats) {
            const blob = new Blob([JSON.stringify(stats, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `statistical-analysis-${Date.now()}.json`;
            a.click();
        }
        
        function analyzeTreeStructure() {
            const structure = {
                totalNodes: treeBuilder.nodes.size,
                totalLayers: treeBuilder.layers.length,
                nodesPerLayer: {},
                branchingFactor: {},
                terminalNodes: [],
                possiblePaths: 0,
                nodeDetails: []
            };
            
            // Analyze each layer
            treeBuilder.layers.forEach((layer, index) => {
                structure.nodesPerLayer[`Layer ${index}`] = layer.nodes.length;
                
                let childCount = 0;
                let nodeWithChildren = 0;
                
                layer.nodes.forEach(node => {
                    let children = 0;
                    if (node.left) children++;
                    if (node.right) children++;
                    
                    if (children > 0) {
                        childCount += children;
                        nodeWithChildren++;
                    }
                    
                    if (node.isTerminal) {
                        structure.terminalNodes.push(node.question);
                    }
                    
                    structure.nodeDetails.push({
                        id: node.id,
                        question: node.question,
                        layer: index,
                        threshold: node.threshold,
                        hasLeft: !!node.left,
                        hasRight: !!node.right,
                        isTerminal: node.isTerminal
                    });
                });
                
                if (nodeWithChildren > 0) {
                    structure.branchingFactor[`Layer ${index}`] = (childCount / nodeWithChildren).toFixed(2);
                }
            });
            
            // Count possible paths through the tree
            function countPaths(node) {
                if (!node || node.isTerminal) return 1;
                let paths = 0;
                if (node.left) paths += countPaths(node.left);
                if (node.right) paths += countPaths(node.right);
                if (!node.left && !node.right) paths = 1; // Leaf node
                return paths;
            }
            
            if (treeBuilder.layers[0]?.nodes[0]) {
                structure.possiblePaths = countPaths(treeBuilder.layers[0].nodes[0]);
            }
            
            return structure;
        }

        // Save/Load Tree Configuration Functions
        function saveTreeConfiguration() {
            const configuration = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                tree: {
                    layers: treeBuilder.layers.map(layer => ({
                        index: layer.index,
                        nodes: layer.nodes.map(node => ({
                            id: node.id,
                            question: node.question,
                            depth: node.depth,
                            threshold: node.threshold,
                            score: node.score,
                            isTerminal: node.isTerminal,
                            x: node.x,
                            y: node.y,
                            parentId: node.parentId,
                            leftId: node.leftId,
                            rightId: node.rightId
                        }))
                    }))
                },
                surveyData: window.batchResults || [],
                mappings: window.columnMappings || {},
                metadata: {
                    totalNodes: treeBuilder.nodes.size,
                    totalLayers: treeBuilder.layers.length,
                    hasData: !!window.batchResults,
                    dataCount: window.batchResults ? window.batchResults.length : 0
                }
            };

            const blob = new Blob([JSON.stringify(configuration, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tree-configuration-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            alert('Tree configuration saved successfully!');
        }

        function loadTreeConfiguration() {
            const fileInput = document.getElementById('tree-config-file');
            fileInput.click();
        }

        function processTreeConfigFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const configuration = JSON.parse(e.target.result);
                    
                    // Validate configuration
                    if (!configuration.version || !configuration.tree) {
                        throw new Error('Invalid configuration file format');
                    }

                    // Clear existing tree
                    treeBuilder.layers = [];
                    treeBuilder.nodes.clear();

                    // Reconstruct tree from configuration
                    configuration.tree.layers.forEach(layerData => {
                        const layer = {
                            index: layerData.index,
                            nodes: []
                        };

                        layerData.nodes.forEach(nodeData => {
                            const node = new DecisionNode(
                                nodeData.question,
                                nodeData.depth,
                                nodeData.id,
                                nodeData.threshold,
                                nodeData.score
                            );
                            
                            // Restore all node properties
                            node.isTerminal = nodeData.isTerminal || false;
                            node.x = nodeData.x || 0;
                            node.y = nodeData.y || 0;
                            node.parentId = nodeData.parentId || null;
                            node.leftId = nodeData.leftId || null;
                            node.rightId = nodeData.rightId || null;

                            layer.nodes.push(node);
                            treeBuilder.nodes.set(node.id, node);
                        });

                        treeBuilder.layers.push(layer);
                    });

                    // Restore node connections
                    treeBuilder.nodes.forEach(node => {
                        if (node.leftId) {
                            node.left = treeBuilder.nodes.get(node.leftId);
                        }
                        if (node.rightId) {
                            node.right = treeBuilder.nodes.get(node.rightId);
                        }
                    });

                    // Restore survey data if present
                    if (configuration.surveyData && configuration.surveyData.length > 0) {
                        window.batchResults = configuration.surveyData;
                    }

                    // Restore column mappings if present
                    if (configuration.mappings) {
                        window.columnMappings = configuration.mappings;
                    }

                    // Update UI
                    treeBuilder.updateLayersDisplay();
                    visualizeTree();

                    // Display metadata
                    const metadata = configuration.metadata || {};
                    alert(`Tree configuration loaded successfully!\n\n` +
                          `Tree: ${metadata.totalNodes || 0} nodes across ${metadata.totalLayers || 0} layers\n` +
                          `Data: ${metadata.dataCount || 0} survey responses\n` +
                          `Saved: ${new Date(configuration.timestamp).toLocaleString()}`);

                } catch (error) {
                    alert('Error loading configuration file: ' + error.message);
                    console.error('Load error:', error);
                }
            };

            reader.readAsText(file);
            
            // Reset file input for future loads
            event.target.value = '';
        }

        // Shannon Information Theory Analysis
        function showShannonAnalysis() {
            const shannonAnalysis = calculateShannonMetrics();
            displayShannonAnalysisModal(shannonAnalysis);
        }

        function calculateShannonMetrics() {
            const analysis = {
                nodeEntropy: {},
                pathEntropy: 0,
                informationGain: {},
                mutualInformation: {},
                conditionalEntropy: {},
                jointEntropy: {},
                totalInformation: 0,
                redundancy: 0,
                surprise: {},
                averageSurprise: 0,
                treeComplexity: calculateTreeComplexity()
            };

            // Calculate node-level entropy
            treeBuilder.nodes.forEach(node => {
                const nodeData = collectNodeData(node.id);
                if (nodeData.scores.length > 0) {
                    analysis.nodeEntropy[node.id] = {
                        question: node.question,
                        entropy: calculateEntropy(nodeData.scores),
                        maxPossibleEntropy: Math.log2(11), // 11 bins for scores from -5 to 5 with 1.0 intervals
                        normalizedEntropy: 0,
                        branchProbabilities: nodeData.branchProbs,
                        branchEntropy: calculateBranchEntropy(nodeData.branchProbs)
                    };
                    analysis.nodeEntropy[node.id].normalizedEntropy = 
                        analysis.nodeEntropy[node.id].entropy / analysis.nodeEntropy[node.id].maxPossibleEntropy;
                }
            });

            // Calculate path entropy
            const pathDistribution = {};
            window.batchResults.forEach(result => {
                const pathKey = result.path.map(p => p.nodeId).join('->');
                pathDistribution[pathKey] = (pathDistribution[pathKey] || 0) + 1;
            });
            
            const pathProbabilities = Object.values(pathDistribution).map(count => 
                count / window.batchResults.length
            );
            analysis.pathEntropy = -pathProbabilities.reduce((sum, p) => 
                sum + (p > 0 ? p * Math.log2(p) : 0), 0
            );

            // Calculate surprise for each score value and path
            const scoreOccurrences = {};
            const pathSurprises = {};
            let totalSurprise = 0;
            let surpriseCount = 0;

            // Calculate surprise for individual score values
            window.batchResults.forEach(result => {
                result.path.forEach(step => {
                    const scoreBin = Math.round(step.score);
                    scoreOccurrences[scoreBin] = (scoreOccurrences[scoreBin] || 0) + 1;
                });
            });

            // Total number of score observations
            const totalScores = window.batchResults.reduce((sum, r) => sum + r.path.length, 0);

            // Calculate surprise for each score value
            Object.entries(scoreOccurrences).forEach(([score, count]) => {
                const probability = count / totalScores;
                const surprise = -Math.log2(probability);
                analysis.surprise[`score_${score}`] = {
                    value: parseInt(score),
                    probability: probability,
                    surprise: surprise,
                    occurrences: count,
                    interpretation: surprise > 4 ? 'Very surprising' : 
                                  surprise > 2 ? 'Moderately surprising' : 
                                  surprise > 1 ? 'Slightly surprising' : 'Expected'
                };
                totalSurprise += surprise * count;
                surpriseCount += count;
            });

            // Calculate surprise for each path
            Object.entries(pathDistribution).forEach(([path, count]) => {
                const probability = count / window.batchResults.length;
                const surprise = -Math.log2(probability);
                pathSurprises[path] = {
                    probability: probability,
                    surprise: surprise,
                    occurrences: count,
                    interpretation: surprise > 5 ? 'Extremely rare path' :
                                  surprise > 3 ? 'Uncommon path' :
                                  surprise > 1 ? 'Moderate frequency' : 'Common path'
                };
            });

            // Calculate surprise for branch decisions at each node
            treeBuilder.nodes.forEach(node => {
                const nodeData = collectNodeData(node.id);
                if (nodeData.scores.length > 0) {
                    const leftProb = nodeData.branchProbs.left;
                    const rightProb = nodeData.branchProbs.right;
                    
                    if (leftProb > 0) {
                        const leftSurprise = -Math.log2(leftProb);
                        analysis.surprise[`${node.id}_left`] = {
                            node: node.question,
                            branch: 'left',
                            probability: leftProb,
                            surprise: leftSurprise,
                            interpretation: leftSurprise > 2 ? 'Unexpected choice' : 'Expected choice'
                        };
                    }
                    
                    if (rightProb > 0) {
                        const rightSurprise = -Math.log2(rightProb);
                        analysis.surprise[`${node.id}_right`] = {
                            node: node.question,
                            branch: 'right',
                            probability: rightProb,
                            surprise: rightSurprise,
                            interpretation: rightSurprise > 2 ? 'Unexpected choice' : 'Expected choice'
                        };
                    }
                }
            });

            analysis.averageSurprise = surpriseCount > 0 ? totalSurprise / surpriseCount : 0;
            analysis.pathSurprises = pathSurprises;

            // Calculate information gain for each node
            treeBuilder.nodes.forEach(parentNode => {
                if (parentNode.left || parentNode.right) {
                    const parentData = collectNodeData(parentNode.id);
                    if (parentData.scores.length === 0) return;

                    const parentEntropy = calculateEntropy(parentData.scores);
                    let weightedChildEntropy = 0;

                    // Calculate weighted entropy of children
                    if (parentNode.left) {
                        const leftData = collectNodeData(parentNode.left.id);
                        if (leftData.scores.length > 0) {
                            const leftWeight = leftData.scores.length / parentData.scores.length;
                            const leftEntropy = calculateEntropy(leftData.scores);
                            weightedChildEntropy += leftWeight * leftEntropy;
                        }
                    }

                    if (parentNode.right) {
                        const rightData = collectNodeData(parentNode.right.id);
                        if (rightData.scores.length > 0) {
                            const rightWeight = rightData.scores.length / parentData.scores.length;
                            const rightEntropy = calculateEntropy(rightData.scores);
                            weightedChildEntropy += rightWeight * rightEntropy;
                        }
                    }

                    analysis.informationGain[parentNode.id] = {
                        question: parentNode.question,
                        gain: parentEntropy - weightedChildEntropy,
                        parentEntropy: parentEntropy,
                        weightedChildEntropy: weightedChildEntropy,
                        efficiency: parentEntropy > 0 ? 
                            (parentEntropy - weightedChildEntropy) / parentEntropy : 0
                    };
                }
            });

            // Calculate mutual information between sequential nodes
            const sequentialPairs = getSequentialNodePairs();
            sequentialPairs.forEach(pair => {
                const mi = calculateMutualInformation(pair.node1Id, pair.node2Id);
                if (mi !== null) {
                    analysis.mutualInformation[`${pair.node1Id}_${pair.node2Id}`] = {
                        node1: pair.node1Question,
                        node2: pair.node2Question,
                        mutualInfo: mi.mutualInfo,
                        node1Entropy: mi.entropy1,
                        node2Entropy: mi.entropy2,
                        jointEntropy: mi.jointEntropy,
                        correlation: mi.correlation
                    };
                }
            });

            // Calculate conditional entropy H(Y|X) for each parent-child relationship
            treeBuilder.nodes.forEach(parentNode => {
                if (parentNode.left || parentNode.right) {
                    const children = [];
                    if (parentNode.left) children.push(parentNode.left);
                    if (parentNode.right) children.push(parentNode.right);

                    children.forEach(childNode => {
                        const ce = calculateConditionalEntropy(parentNode.id, childNode.id);
                        if (ce !== null) {
                            analysis.conditionalEntropy[`${parentNode.id}|${childNode.id}`] = {
                                parent: parentNode.question,
                                child: childNode.question,
                                conditionalEntropy: ce,
                                interpretation: ce < 0.5 ? 'Strong dependency' : 
                                              ce < 1.0 ? 'Moderate dependency' : 'Weak dependency'
                            };
                        }
                    });
                }
            });

            // Calculate total information content
            const allScores = [];
            window.batchResults.forEach(result => {
                result.path.forEach(step => {
                    allScores.push(step.score);
                });
            });
            analysis.totalInformation = calculateEntropy(allScores) * allScores.length;

            // Calculate redundancy (how much information is repeated across nodes)
            const uniqueInformation = Object.values(analysis.nodeEntropy)
                .reduce((sum, node) => sum + node.entropy, 0);
            const theoreticalMaxInfo = Math.log2(11) * treeBuilder.nodes.size;
            analysis.redundancy = 1 - (uniqueInformation / theoreticalMaxInfo);

            // Add summary metrics
            analysis.summary = {
                averageNodeEntropy: uniqueInformation / Object.keys(analysis.nodeEntropy).length,
                maxNodeEntropy: Math.max(...Object.values(analysis.nodeEntropy).map(n => n.entropy)),
                minNodeEntropy: Math.min(...Object.values(analysis.nodeEntropy).map(n => n.entropy)),
                averageInfoGain: Object.values(analysis.informationGain).length > 0 ?
                    Object.values(analysis.informationGain).reduce((sum, ig) => sum + ig.gain, 0) / 
                    Object.values(analysis.informationGain).length : 0,
                pathDiversity: analysis.pathEntropy / Math.log2(Object.keys(pathDistribution).length || 1),
                decisionEfficiency: Object.values(analysis.informationGain)
                    .reduce((sum, ig) => sum + ig.efficiency, 0) / 
                    (Object.values(analysis.informationGain).length || 1)
            };

            return analysis;
        }

        function collectNodeData(nodeId) {
            const scores = [];
            const branches = { left: 0, right: 0 };
            
            window.batchResults.forEach(result => {
                const step = result.path.find(p => p.nodeId === nodeId);
                if (step) {
                    scores.push(step.score);
                    if (step.decision === 'left') branches.left++;
                    else if (step.decision === 'right') branches.right++;
                }
            });

            const total = branches.left + branches.right;
            const branchProbs = {
                left: total > 0 ? branches.left / total : 0,
                right: total > 0 ? branches.right / total : 0
            };

            return { scores, branches, branchProbs };
        }

        function calculateEntropy(values) {
            if (values.length === 0) return 0;

            // Create bins for the values
            const bins = {};
            values.forEach(value => {
                const bin = Math.round(value); // Round to nearest integer for binning
                bins[bin] = (bins[bin] || 0) + 1;
            });

            // Calculate probabilities
            const total = values.length;
            const probabilities = Object.values(bins).map(count => count / total);

            // Calculate entropy: H = -Σ p(x) * log2(p(x))
            return -probabilities.reduce((sum, p) => 
                sum + (p > 0 ? p * Math.log2(p) : 0), 0
            );
        }

        function calculateBranchEntropy(branchProbs) {
            const probs = [branchProbs.left, branchProbs.right].filter(p => p > 0);
            if (probs.length === 0) return 0;
            
            return -probs.reduce((sum, p) => sum + p * Math.log2(p), 0);
        }

        function getSequentialNodePairs() {
            const pairs = new Map();
            
            window.batchResults.forEach(result => {
                for (let i = 0; i < result.path.length - 1; i++) {
                    const node1 = result.path[i];
                    const node2 = result.path[i + 1];
                    const pairKey = `${node1.nodeId}_${node2.nodeId}`;
                    
                    if (!pairs.has(pairKey)) {
                        pairs.set(pairKey, {
                            node1Id: node1.nodeId,
                            node2Id: node2.nodeId,
                            node1Question: node1.question,
                            node2Question: node2.question
                        });
                    }
                }
            });
            
            return Array.from(pairs.values());
        }

        function calculateMutualInformation(node1Id, node2Id) {
            const joint = [];
            const node1Scores = [];
            const node2Scores = [];
            
            window.batchResults.forEach(result => {
                const node1Step = result.path.find(p => p.nodeId === node1Id);
                const node2Step = result.path.find(p => p.nodeId === node2Id);
                
                if (node1Step && node2Step) {
                    node1Scores.push(Math.round(node1Step.score));
                    node2Scores.push(Math.round(node2Step.score));
                    joint.push([Math.round(node1Step.score), Math.round(node2Step.score)]);
                }
            });
            
            if (joint.length === 0) return null;

            // Calculate individual entropies
            const entropy1 = calculateEntropy(node1Scores);
            const entropy2 = calculateEntropy(node2Scores);

            // Calculate joint entropy
            const jointCounts = {};
            joint.forEach(([v1, v2]) => {
                const key = `${v1},${v2}`;
                jointCounts[key] = (jointCounts[key] || 0) + 1;
            });
            
            const jointProbs = Object.values(jointCounts).map(count => count / joint.length);
            const jointEntropy = -jointProbs.reduce((sum, p) => 
                sum + (p > 0 ? p * Math.log2(p) : 0), 0
            );

            // Mutual information: I(X;Y) = H(X) + H(Y) - H(X,Y)
            const mutualInfo = entropy1 + entropy2 - jointEntropy;

            // Calculate normalized correlation (mutual info / min entropy)
            const correlation = Math.min(entropy1, entropy2) > 0 ? 
                mutualInfo / Math.min(entropy1, entropy2) : 0;

            return {
                mutualInfo,
                entropy1,
                entropy2,
                jointEntropy,
                correlation
            };
        }

        function calculateConditionalEntropy(parentId, childId) {
            const conditionalData = {};
            
            window.batchResults.forEach(result => {
                const parentStep = result.path.find(p => p.nodeId === parentId);
                const childStep = result.path.find(p => p.nodeId === childId);
                
                if (parentStep && childStep) {
                    const parentBin = Math.round(parentStep.score);
                    if (!conditionalData[parentBin]) {
                        conditionalData[parentBin] = [];
                    }
                    conditionalData[parentBin].push(Math.round(childStep.score));
                }
            });
            
            if (Object.keys(conditionalData).length === 0) return null;

            // Calculate H(Y|X) = Σ p(x) * H(Y|X=x)
            let totalSamples = 0;
            Object.values(conditionalData).forEach(samples => {
                totalSamples += samples.length;
            });

            let conditionalEntropy = 0;
            Object.entries(conditionalData).forEach(([parentValue, childValues]) => {
                const weight = childValues.length / totalSamples;
                const entropy = calculateEntropy(childValues);
                conditionalEntropy += weight * entropy;
            });

            return conditionalEntropy;
        }

        function displayShannonAnalysisModal(analysis) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 5000; overflow-y: auto;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: white; padding: 30px; border-radius: 15px; width: 90%; max-width: 1200px; max-height: 90vh; overflow-y: auto; margin-bottom: 20px;';
            
            let html = `
                <h2>Shannon Information Theory Analysis</h2>
                
                <div style="background: #f0f8ff; padding: 15px; border-radius: 10px; margin: 20px 0;">
                    <h3>Tree Complexity Metrics</h3>
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <td style="padding: 10px;"><strong>Structural Entropy:</strong></td>
                            <td style="padding: 10px;">${analysis.treeComplexity.structuralEntropy.toFixed(3)} bits</td>
                            <td style="padding: 10px;"><strong>Branching Entropy:</strong></td>
                            <td style="padding: 10px;">${analysis.treeComplexity.branchingEntropy.toFixed(3)} bits</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><strong>Depth Complexity:</strong></td>
                            <td style="padding: 10px;">${analysis.treeComplexity.depthComplexity.toFixed(3)} bits</td>
                            <td style="padding: 10px;"><strong>Balance Score:</strong></td>
                            <td style="padding: 10px;">${(analysis.treeComplexity.balanceScore * 100).toFixed(1)}%</td>
                        </tr>
                    </table>
                </div>
                
                ${window.batchResults && window.batchResults.length > 0 ? `
                <div style="background: #f0f8ff; padding: 15px; border-radius: 10px; margin: 20px 0;">
                    <h3>Data-Based Summary Metrics</h3>` : '<div style="background: #ffe0e0; padding: 15px; border-radius: 10px; margin: 20px 0;"><p><strong>No survey data yet</strong> - Run surveys or upload data to see entropy, surprise, and information gain metrics based on actual responses.</p></div><div style="background: #f0f8ff; padding: 15px; border-radius: 10px; margin: 20px 0; display:none;"><h3>Summary Metrics</h3>'}
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <td style="padding: 10px;"><strong>Average Node Entropy:</strong></td>
                            <td style="padding: 10px;">${analysis.summary.averageNodeEntropy.toFixed(3)} bits</td>
                            <td style="padding: 10px;"><strong>Path Diversity:</strong></td>
                            <td style="padding: 10px;">${(analysis.summary.pathDiversity * 100).toFixed(1)}%</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><strong>Max Node Entropy:</strong></td>
                            <td style="padding: 10px;">${analysis.summary.maxNodeEntropy.toFixed(3)} bits</td>
                            <td style="padding: 10px;"><strong>Decision Efficiency:</strong></td>
                            <td style="padding: 10px;">${(analysis.summary.decisionEfficiency * 100).toFixed(1)}%</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><strong>Path Entropy:</strong></td>
                            <td style="padding: 10px;">${analysis.pathEntropy.toFixed(3)} bits</td>
                            <td style="padding: 10px;"><strong>Information Redundancy:</strong></td>
                            <td style="padding: 10px;">${(analysis.redundancy * 100).toFixed(1)}%</td>
                        </tr>
                    </table>
                </div>
                
                <h3>Node Entropy Analysis</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 12px;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Question</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Entropy (bits)</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Normalized</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Branch Entropy</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Left Prob</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Right Prob</th>
                    </tr>
            `;
            
            Object.values(analysis.nodeEntropy).forEach(node => {
                html += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">${node.question.substring(0, 40)}...</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.entropy.toFixed(3)}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${(node.normalizedEntropy * 100).toFixed(1)}%</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${node.branchEntropy.toFixed(3)}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${(node.branchProbabilities.left * 100).toFixed(1)}%</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${(node.branchProbabilities.right * 100).toFixed(1)}%</td>
                    </tr>
                `;
            });
            
            html += `</table>
                
                <h3>Information Gain at Decision Points</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Decision Node</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Info Gain</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Parent Entropy</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Child Entropy</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Efficiency</th>
                    </tr>
            `;
            
            Object.values(analysis.informationGain)
                .sort((a, b) => b.gain - a.gain)
                .forEach(ig => {
                    html += `
                        <tr>
                            <td style="padding: 10px; border: 1px solid #ddd;">${ig.question.substring(0, 40)}...</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: ${ig.gain > 0.5 ? '#4CAF50' : '#FF9800'};">${ig.gain.toFixed(3)}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${ig.parentEntropy.toFixed(3)}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${ig.weightedChildEntropy.toFixed(3)}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${(ig.efficiency * 100).toFixed(1)}%</td>
                        </tr>
                    `;
                });
            
            html += `</table>
                
                <h3>Surprise Analysis (Self-Information)</h3>
                <p style="margin: 10px 0;"><strong>Average Surprise:</strong> ${analysis.averageSurprise.toFixed(3)} bits</p>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Score Value</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Probability</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Surprise (bits)</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Occurrences</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Interpretation</th>
                    </tr>
            `;
            
            // Sort surprise values by surprise amount (most surprising first)
            const scoreSurprises = Object.entries(analysis.surprise)
                .filter(([key, val]) => key.startsWith('score_'))
                .sort((a, b) => b[1].surprise - a[1].surprise)
                .slice(0, 10);
                
            scoreSurprises.forEach(([key, data]) => {
                const color = data.surprise > 3 ? '#ff4444' : data.surprise > 2 ? '#ff9800' : '#4CAF50';
                html += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.value}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${(data.probability * 100).toFixed(2)}%</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: ${color};">${data.surprise.toFixed(3)}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.occurrences}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.interpretation}</td>
                    </tr>
                `;
            });
            
            html += `</table>
                
                <h3>Path Surprise Analysis</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Path</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Probability</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Surprise (bits)</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Interpretation</th>
                    </tr>
            `;
            
            // Show most surprising paths
            Object.entries(analysis.pathSurprises || {})
                .sort((a, b) => b[1].surprise - a[1].surprise)
                .slice(0, 5)
                .forEach(([path, data]) => {
                    const color = data.surprise > 4 ? '#ff4444' : data.surprise > 2 ? '#ff9800' : '#4CAF50';
                    html += `
                        <tr>
                            <td style="padding: 10px; border: 1px solid #ddd; font-size: 11px;">${path.substring(0, 50)}...</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${(data.probability * 100).toFixed(2)}%</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: ${color};">${data.surprise.toFixed(3)}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${data.interpretation}</td>
                        </tr>
                    `;
                });
            
            html += `</table>
                
                <h3>Mutual Information Between Sequential Nodes</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Node 1</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Node 2</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Mutual Info</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Correlation</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Joint Entropy</th>
                    </tr>
            `;
            
            Object.values(analysis.mutualInformation)
                .sort((a, b) => b.mutualInfo - a.mutualInfo)
                .slice(0, 10)
                .forEach(mi => {
                    html += `
                        <tr>
                            <td style="padding: 10px; border: 1px solid #ddd;">${mi.node1.substring(0, 25)}...</td>
                            <td style="padding: 10px; border: 1px solid #ddd;">${mi.node2.substring(0, 25)}...</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center; font-weight: bold;">${mi.mutualInfo.toFixed(3)}</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: ${mi.correlation > 0.5 ? '#4CAF50' : '#FF9800'};">${(mi.correlation * 100).toFixed(1)}%</td>
                            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${mi.jointEntropy.toFixed(3)}</td>
                        </tr>
                    `;
                });
            
            html += `</table>
                
                <div style="margin-top: 30px; padding: 15px; background: #fffbf0; border-radius: 10px;">
                    <h4>Interpretation Guide</h4>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li><strong>Entropy:</strong> Measures uncertainty/randomness. Higher entropy = more diverse responses</li>
                        <li><strong>Surprise (Self-Information):</strong> I(x) = -log₂(p). Rare events have high surprise (many bits needed to encode)</li>
                        <li><strong>Information Gain:</strong> How much uncertainty is reduced by splitting at a node</li>
                        <li><strong>Mutual Information:</strong> How much knowing one node tells us about another</li>
                        <li><strong>Path Diversity:</strong> How varied the paths through the tree are (0-100%)</li>
                        <li><strong>Decision Efficiency:</strong> How well nodes split the data (0-100%)</li>
                        <li><strong>Average Surprise:</strong> Expected surprise across all events (equals entropy when properly weighted)</li>
                    </ul>
                </div>
                
                <div style="margin-top: 20px; display: flex; gap: 10px;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="padding: 10px 20px; background: #ccc; border: none; border-radius: 5px; cursor: pointer;">Close</button>
                    <button onclick="exportShannonAnalysis(${JSON.stringify(analysis).replace(/"/g, '&quot;')})" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Export Analysis</button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Add close X button after setting innerHTML
            const closeX = document.createElement('button');
            closeX.innerHTML = '×';
            closeX.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeX.onmouseover = () => { closeX.style.background = '#e0e0e0'; closeX.style.color = '#000'; };
            closeX.onmouseout = () => { closeX.style.background = '#f0f0f0'; closeX.style.color = '#666'; };
            closeX.onclick = function() { 
                const parentModal = this.closest('[style*="position: fixed"]');
                if (parentModal) parentModal.remove(); 
            };
            content.appendChild(closeX);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function exportShannonAnalysis(analysis) {
            const blob = new Blob([JSON.stringify(analysis, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `shannon-analysis-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function calculateTreeComplexity() {
            const complexity = {
                structuralEntropy: 0,
                depthComplexity: 0,
                branchingEntropy: 0,
                theoreticalMaxEntropy: 0,
                balanceScore: 0
            };
            
            // Calculate structural entropy based on tree shape
            const totalNodes = treeBuilder.nodes.size;
            if (totalNodes > 0) {
                // Tree structure entropy based on possible configurations
                complexity.structuralEntropy = Math.log2(totalNodes);
                
                // Depth complexity
                complexity.depthComplexity = treeBuilder.layers.length > 0 ? 
                    Math.log2(treeBuilder.layers.length) : 0;
                
                // Branching entropy - how evenly distributed are the branches
                const branchCounts = [];
                treeBuilder.nodes.forEach(node => {
                    let branches = 0;
                    if (node.left) branches++;
                    if (node.right) branches++;
                    branchCounts.push(branches);
                });
                
                if (branchCounts.length > 0) {
                    const branchProbs = [0, 0, 0]; // 0, 1, or 2 branches
                    branchCounts.forEach(count => {
                        branchProbs[count]++;
                    });
                    
                    const total = branchCounts.length;
                    complexity.branchingEntropy = -branchProbs
                        .map(count => count / total)
                        .filter(p => p > 0)
                        .reduce((sum, p) => sum + p * Math.log2(p), 0);
                }
                
                // Theoretical maximum entropy for a balanced binary tree
                complexity.theoreticalMaxEntropy = Math.log2(Math.pow(2, treeBuilder.layers.length) - 1);
                
                // Balance score - how balanced is the tree (0-1, 1 being perfectly balanced)
                const actualPaths = countAllPaths(treeBuilder.layers[0]?.nodes[0]);
                const maxPossiblePaths = Math.pow(2, treeBuilder.layers.length - 1);
                complexity.balanceScore = actualPaths / maxPossiblePaths;
            }
            
            return complexity;
        }
        
        function countAllPaths(node) {
            if (!node) return 0;
            if (!node.left && !node.right) return 1;
            let paths = 0;
            if (node.left) paths += countAllPaths(node.left);
            if (node.right) paths += countAllPaths(node.right);
            return paths;
        }

        // Advanced Tree Generation from Survey Data
        function showTreeGenerationOptions(data) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; display: flex; align-items: center; justify-content: center;';
            
            const content = document.createElement('div');
            content.style.cssText = 'background: white; padding: 30px; border-radius: 20px; width: 600px; max-width: 90%; box-shadow: 0 20px 40px rgba(0, 57, 166, 0.3);';
            
            content.innerHTML = `
                <h2 style="margin-bottom: 20px; background: linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">Generate Tree from Data</h2>
                <p style="color: #666; margin-bottom: 20px;">No tree structure found. Choose a method to automatically generate a tree from your survey data:</p>
                
                <div style="display: flex; flex-direction: column; gap: 15px; margin: 20px 0;">
                    <button onclick="generateTreeFromData('correlation')" style="padding: 15px; background: linear-gradient(135deg, var(--gsu-primary), var(--gsu-vibrant)); color: white; border: none; border-radius: 10px; cursor: pointer; text-align: left;">
                        <strong>Correlation Graph → MST</strong><br>
                        <small style="opacity: 0.9;">Build minimum spanning tree from correlation matrix (best for related questions)</small>
                    </button>
                    
                    <button onclick="generateTreeFromData('information')" style="padding: 15px; background: linear-gradient(135deg, var(--gsu-vibrant), var(--gsu-light-blue)); color: white; border: none; border-radius: 10px; cursor: pointer; text-align: left;">
                        <strong>Information Gain Splitting</strong><br>
                        <small style="opacity: 0.9;">Use Shannon entropy to find optimal decision boundaries (best for predictive trees)</small>
                    </button>
                    
                    <button onclick="generateTreeFromData('clustering')" style="padding: 15px; background: linear-gradient(135deg, var(--gsu-success), #0ec775); color: white; border: none; border-radius: 10px; cursor: pointer; text-align: left;">
                        <strong>Spectral Clustering</strong><br>
                        <small style="opacity: 0.9;">Group similar response patterns hierarchically (best for exploratory analysis)</small>
                    </button>
                    
                    <button onclick="generateTreeFromData('hybrid')" style="padding: 15px; background: linear-gradient(135deg, #FF6B6B, #FFE66D); color: white; border: none; border-radius: 10px; cursor: pointer; text-align: left;">
                        <strong>Hybrid KNN + Graph Theory</strong><br>
                        <small style="opacity: 0.9;">Combine correlation, information gain, and k-nearest neighbors (most comprehensive)</small>
                    </button>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove(); processSurveyDataBatch(window.uploadedSurveyData);" style="flex: 1; padding: 10px; background: #ccc; color: white; border: none; border-radius: 8px; cursor: pointer;">Use Empty Tree</button>
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove();" style="flex: 1; padding: 10px; background: #666; color: white; border: none; border-radius: 8px; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            // Need to set position relative for absolute positioning to work
            content.style.position = 'relative';
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        // Generate tree using selected method
        function generateTreeFromData(method) {
            const data = window.uploadedSurveyData;
            if (!data || data.length === 0) {
                alert('No data available');
                return;
            }

            // Close the modal
            const modal = document.querySelector('[style*="position: fixed"][style*="z-index: 3000"]');
            if (modal) modal.remove();

            // Clear existing tree
            treeBuilder.layers = [];
            treeBuilder.nodes.clear();

            switch(method) {
                case 'correlation':
                    generateCorrelationTree(data);
                    break;
                case 'information':
                    generateInformationGainTree(data);
                    break;
                case 'clustering':
                    generateClusteringTree(data);
                    break;
                case 'hybrid':
                    generateHybridTree(data);
                    break;
            }

            // Make sure builder panel is visible to see the tree
            const builderPanel = document.getElementById('builder-panel');
            if (builderPanel && builderPanel.style.display === 'none') {
                builderPanel.style.display = 'block';
            }
            
            // Update display
            treeBuilder.updateLayersDisplay();
            
            // Force visualization update
            visualizeTree();
            
            // Process the data with new tree
            processSurveyDataBatch(data);
            
            alert(`Tree generated using ${method} method with ${treeBuilder.nodes.size} nodes!`);
        }

        // Method 1: Correlation-based Minimum Spanning Tree
        function generateCorrelationTree(data) {
            const columns = Object.keys(data[0]).filter(key => typeof data[0][key] === 'number');
            
            // Calculate correlation matrix
            const correlations = {};
            for (let i = 0; i < columns.length; i++) {
                for (let j = i + 1; j < columns.length; j++) {
                    const col1 = columns[i];
                    const col2 = columns[j];
                    const vals1 = data.map(row => row[col1] || 0);
                    const vals2 = data.map(row => row[col2] || 0);
                    
                    const corr = calculateCorrelation(vals1, vals2);
                    correlations[`${col1}|${col2}`] = Math.abs(corr);
                }
            }

            // Build MST using Kruskal's algorithm
            const edges = Object.entries(correlations)
                .map(([key, weight]) => {
                    const [from, to] = key.split('|');
                    return { from, to, weight: 1 - weight }; // Convert correlation to distance
                })
                .sort((a, b) => a.weight - b.weight);

            const parent = {};
            const find = (x) => {
                if (parent[x] !== x) parent[x] = find(parent[x]);
                return parent[x];
            };
            
            columns.forEach(col => parent[col] = col);
            
            const mstEdges = [];
            for (const edge of edges) {
                const rootFrom = find(edge.from);
                const rootTo = find(edge.to);
                if (rootFrom !== rootTo) {
                    mstEdges.push(edge);
                    parent[rootFrom] = rootTo;
                    if (mstEdges.length === columns.length - 1) break;
                }
            }

            // Convert MST to tree structure
            const root = columns[0];
            const visited = new Set();
            const adjacency = {};
            
            mstEdges.forEach(edge => {
                if (!adjacency[edge.from]) adjacency[edge.from] = [];
                if (!adjacency[edge.to]) adjacency[edge.to] = [];
                adjacency[edge.from].push(edge.to);
                adjacency[edge.to].push(edge.from);
            });

            // BFS to create layers
            const queue = [{ node: root, depth: 0 }];
            visited.add(root);
            const layerNodes = {};
            
            while (queue.length > 0) {
                const { node, depth } = queue.shift();
                if (!layerNodes[depth]) layerNodes[depth] = [];
                
                // Calculate threshold based on data distribution
                const values = data.map(row => row[node] || 0);
                const threshold = calculateMedian(values);
                
                const treeNode = new DecisionNode(
                    node,
                    depth,
                    null,
                    threshold,
                    calculateMean(values)
                );
                
                layerNodes[depth].push(treeNode);
                treeBuilder.nodes.set(treeNode.id, treeNode);
                
                // Add children
                const children = (adjacency[node] || []).filter(child => !visited.has(child));
                children.forEach((child, index) => {
                    visited.add(child);
                    queue.push({ node: child, depth: depth + 1 });
                    
                    if (index === 0) treeNode.leftId = child;
                    else if (index === 1) treeNode.rightId = child;
                });
            }

            // Create layers and link nodes properly
            Object.keys(layerNodes).sort((a, b) => a - b).forEach(depth => {
                treeBuilder.layers.push({
                    index: parseInt(depth),
                    nodes: layerNodes[depth]
                });
            });
            
            // Link the nodes properly after creation
            treeBuilder.nodes.forEach(node => {
                if (node.leftId) {
                    const leftNodes = treeBuilder.nodes;
                    leftNodes.forEach(n => {
                        if (n.question === node.leftId) {
                            node.left = n;
                            node.leftId = n.id;
                        }
                    });
                }
                if (node.rightId) {
                    const rightNodes = treeBuilder.nodes;
                    rightNodes.forEach(n => {
                        if (n.question === node.rightId) {
                            node.right = n;
                            node.rightId = n.id;
                        }
                    });
                }
            });
        }

        // Method 2: Information Gain Tree
        function generateInformationGainTree(data) {
            const columns = Object.keys(data[0]).filter(key => typeof data[0][key] === 'number');
            
            // Recursive function to build tree
            function buildInfoGainNode(remainingCols, dataSubset, depth = 0) {
                if (remainingCols.length === 0 || dataSubset.length < 5 || depth > 5) {
                    return null;
                }

                // Find column with highest information gain
                let bestCol = null;
                let bestGain = -Infinity;
                let bestThreshold = 0;

                for (const col of remainingCols) {
                    const values = dataSubset.map(row => row[col] || 0);
                    const thresholds = [...new Set(values)].sort((a, b) => a - b);
                    
                    for (let i = 0; i < thresholds.length - 1; i++) {
                        const threshold = (thresholds[i] + thresholds[i + 1]) / 2;
                        const gain = calculateInformationGain(dataSubset, col, threshold);
                        
                        if (gain > bestGain) {
                            bestGain = gain;
                            bestCol = col;
                            bestThreshold = threshold;
                        }
                    }
                }

                if (!bestCol) return null;

                const values = dataSubset.map(row => row[bestCol] || 0);
                const node = new DecisionNode(
                    bestCol,
                    depth,
                    null,
                    bestThreshold,
                    calculateMean(values)
                );

                // Split data
                const leftData = dataSubset.filter(row => (row[bestCol] || 0) < bestThreshold);
                const rightData = dataSubset.filter(row => (row[bestCol] || 0) >= bestThreshold);

                // Recursive build
                const newRemaining = remainingCols.filter(c => c !== bestCol);
                if (leftData.length > 0) {
                    const leftChild = buildInfoGainNode(newRemaining, leftData, depth + 1);
                    if (leftChild) {
                        node.left = leftChild;
                        node.leftId = leftChild.id;
                    }
                }
                if (rightData.length > 0) {
                    const rightChild = buildInfoGainNode(newRemaining, rightData, depth + 1);
                    if (rightChild) {
                        node.right = rightChild;
                        node.rightId = rightChild.id;
                    }
                }

                return node;
            }

            const root = buildInfoGainNode(columns, data);
            if (root) {
                // Convert to layer structure
                const layerMap = {};
                const queue = [root];
                
                while (queue.length > 0) {
                    const node = queue.shift();
                    if (!layerMap[node.depth]) layerMap[node.depth] = [];
                    layerMap[node.depth].push(node);
                    treeBuilder.nodes.set(node.id, node);
                    
                    if (node.left) queue.push(node.left);
                    if (node.right) queue.push(node.right);
                }

                Object.keys(layerMap).sort((a, b) => a - b).forEach(depth => {
                    treeBuilder.layers.push({
                        index: parseInt(depth),
                        nodes: layerMap[depth]
                    });
                });
                
                // Connect nodes properly using their IDs
                treeBuilder.nodes.forEach(node => {
                    if (node.leftId && node.left) {
                        node.leftId = node.left.id;
                    }
                    if (node.rightId && node.right) {
                        node.rightId = node.right.id;
                    }
                });
            }
        }

        // Helper functions for tree generation
        function calculateCorrelation(x, y) {
            const n = x.length;
            const meanX = x.reduce((a, b) => a + b, 0) / n;
            const meanY = y.reduce((a, b) => a + b, 0) / n;
            
            let num = 0, denomX = 0, denomY = 0;
            for (let i = 0; i < n; i++) {
                const dx = x[i] - meanX;
                const dy = y[i] - meanY;
                num += dx * dy;
                denomX += dx * dx;
                denomY += dy * dy;
            }
            
            return denomX * denomY === 0 ? 0 : num / Math.sqrt(denomX * denomY);
        }

        function calculateMedian(values) {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }

        function calculateMean(values) {
            return values.reduce((a, b) => a + b, 0) / values.length;
        }

        function calculateVariance(values) {
            const mean = calculateMean(values);
            return values.reduce((sum, val) => sum + (val - mean) ** 2, 0) / values.length;
        }

        function calculatePercentile(values, p) {
            const sorted = [...values].sort((a, b) => a - b);
            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index % 1;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        function calculateInformationGain(data, column, threshold) {
            const total = data.length;
            if (total === 0) return 0;

            // Parent entropy
            const parentValues = data.map(row => row[column] || 0);
            const parentEntropy = calculateEntropy(parentValues);

            // Split data
            const leftData = data.filter(row => (row[column] || 0) < threshold);
            const rightData = data.filter(row => (row[column] || 0) >= threshold);

            // Weighted child entropy
            const leftWeight = leftData.length / total;
            const rightWeight = rightData.length / total;

            const leftEntropy = leftData.length > 0 ? 
                calculateEntropy(leftData.map(row => row[column] || 0)) : 0;
            const rightEntropy = rightData.length > 0 ? 
                calculateEntropy(rightData.map(row => row[column] || 0)) : 0;

            return parentEntropy - (leftWeight * leftEntropy + rightWeight * rightEntropy);
        }

        // Simplified versions of clustering and hybrid methods
        function generateClusteringTree(data) {
            // Simplified hierarchical clustering
            generateInformationGainTree(data); // Fallback to info gain for now
        }

        function generateHybridTree(data) {
            // Use information gain as base with KNN enhancement
            generateInformationGainTree(data);
        }

        function processSurveyDataBatch(data) {
            if (!data || !Array.isArray(data)) return;
            
            window.batchResults = [];
            
            data.forEach((response, index) => {
                const result = {
                    respondentId: response.respondentId || `respondent_${index + 1}`,
                    path: [],
                    totalScore: 0
                };
                
                // Get all available keys from response (excluding respondentId)
                const scoreKeys = Object.keys(response).filter(key => key !== 'respondentId');
                
                // Traverse the tree
                let currentNode = treeBuilder.layers[0]?.nodes[0];
                let keyIndex = 0;
                
                while (currentNode && keyIndex < scoreKeys.length) {
                    // Try to find a matching score in the response
                    let score = null;
                    
                    // First try exact match with node question
                    if (response[currentNode.question] !== undefined) {
                        score = parseFloat(response[currentNode.question]);
                    }
                    // Then try using keys in order
                    else if (scoreKeys[keyIndex]) {
                        score = parseFloat(response[scoreKeys[keyIndex]]);
                        keyIndex++;
                    }
                    
                    // Default to 0 if no score found
                    if (score === null || isNaN(score)) {
                        score = 0;
                    }
                    
                    result.path.push({
                        nodeId: currentNode.id,
                        question: currentNode.question,
                        score: score,
                        threshold: currentNode.threshold
                    });
                    
                    result.totalScore += score;
                    
                    // Move to next node based on threshold
                    if (score >= currentNode.threshold) {
                        currentNode = currentNode.right || treeBuilder.nodes.get(currentNode.rightId);
                    } else {
                        currentNode = currentNode.left || treeBuilder.nodes.get(currentNode.leftId);
                    }
                }
                
                window.batchResults.push(result);
            });
            
            // Update visualization if needed
            if (window.currentVisualizationMode) {
                changeVisualization();
            }
            
            // Trigger stats update if we have results
            if (window.batchResults && window.batchResults.length > 0) {
                // Auto-show stats if this is first data load
                if (!window.statsShownOnce) {
                    window.statsShownOnce = true;
                    // Give tree generation time to complete then show stats
                    setTimeout(() => {
                        showStatisticalAnalysis();
                    }, 500);
                }
            }
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initializeSampleTree();
            updateColorLegend();
            
            // Setup import tree file listener
            const importFileInput = document.getElementById('import-file');
            if (importFileInput) {
                importFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            
                            // Clear existing tree first
                            treeBuilder.layers = [];
                            treeBuilder.nodes.clear();
                            
                            // Check if this is tree data or survey data
                            if (data.layers) {
                                // This is tree structure data
                                treeBuilder.importTreeData(data);
                            } else if (data.tree && data.tree.layers) {
                                // Handle format from Save Tree button
                                treeBuilder.importTreeData(data.tree);
                            } else if (Array.isArray(data) || data.responses) {
                                // This is survey data - process it
                                const responses = Array.isArray(data) ? data : data.responses;
                                processUploadedData(responses);
                                alert(`Loaded ${responses.length} survey responses!`);
                                e.target.value = '';
                                return;
                            } else {
                                // Try to detect if it's survey data by checking for numeric fields
                                const firstItem = Array.isArray(data) ? data[0] : data;
                                const hasNumericFields = Object.values(firstItem || {}).some(v => typeof v === 'number');
                                
                                if (hasNumericFields) {
                                    // Treat as survey data
                                    processUploadedData([firstItem]);
                                    alert('Loaded survey data!');
                                    e.target.value = '';
                                    return;
                                }
                                
                                throw new Error('Invalid data format - expected tree structure or survey responses');
                            }
                            
                            // Make sure builder panel is visible
                            const builderPanel = document.getElementById('builder-panel');
                            if (builderPanel && builderPanel.style.display === 'none') {
                                builderPanel.style.display = 'block';
                            }
                            
                            alert('Tree imported successfully!');
                            // Reset file input for future imports
                            e.target.value = '';
                        } catch (error) {
                            alert('Error importing tree: ' + error.message);
                            console.error('Import error:', error);
                        }
                    };
                    reader.readAsText(file);
                });
            }
        });
        
        // Initialize subtitle on page load
        window.addEventListener('DOMContentLoaded', function() {
            const subtitle = document.getElementById('scale-subtitle');
            if (subtitle && scaleDescriptions[currentScaleRange]) {
                subtitle.textContent = scaleDescriptions[currentScaleRange];
            }
        });

        // Settings Panel Functions
        let nodeSize = 120;
        let animationSpeed = 500;
        let autoSaveInterval = null;

        window.exportVisualizationAsPNG = function() {
            const svg = document.getElementById('tree-svg');
            const svgData = new XMLSerializer().serializeToString(svg);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            canvas.width = 1200;
            canvas.height = 800;
            
            img.onload = function() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                
                canvas.toBlob(function(blob) {
                    const link = document.createElement('a');
                    link.download = `tree-visualization-${Date.now()}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                });
            };
            
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            img.src = URL.createObjectURL(blob);
        };

        window.exportVisualizationAsPDF = () => alert('PDF export coming soon! Use PNG export for now.');
        window.exportFullReport = () => alert('Full report generation coming soon!');
        window.compareDatasets = () => alert('Dataset comparison coming soon!');
        window.showAdvancedMetrics = () => alert('Advanced metrics dashboard coming soon!');

        window.shareTree = function() {
            const treeData = treeBuilder.exportTreeData();
            const encoded = btoa(JSON.stringify(treeData));
            const url = window.location.origin + window.location.pathname + '#tree=' + encoded;
            
            navigator.clipboard.writeText(url).then(() => {
                alert('Shareable link copied to clipboard!');
            }).catch(() => {
                prompt('Copy this link to share:', url);
            });
        };

        window.exportForCollaboration = function() {
            const exportData = {
                tree: treeBuilder.exportTreeData(),
                settings: {
                    scale: currentScaleRange,
                    allowDecimals: allowDecimals,
                    colorScale: currentColorScale
                },
                surveyData: window.surveyData || [],
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `tree-collaboration-${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };

        window.showNodeSearch = function() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 20px; width: 500px;';
            
            content.innerHTML = `
                <h2 style="margin-bottom: 20px; color: #0039A6;">Search Nodes</h2>
                <input type="text" id="node-search-input" placeholder="Enter search term..." 
                    style="width: 100%; padding: 10px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 8px; margin-bottom: 20px;">
                <div id="search-results" style="max-height: 300px; overflow-y: auto;"></div>
                <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" 
                    style="margin-top: 20px; padding: 10px 20px; background: #ccc; border: none; border-radius: 8px; cursor: pointer;">
                    Close
                </button>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            const searchInput = document.getElementById('node-search-input');
            searchInput.addEventListener('input', function(e) {
                const searchTerm = e.target.value.toLowerCase();
                const results = document.getElementById('search-results');
                results.innerHTML = '';
                
                if (searchTerm.length > 0) {
                    treeBuilder.nodes.forEach(node => {
                        if (node.question.toLowerCase().includes(searchTerm)) {
                            const resultDiv = document.createElement('div');
                            resultDiv.style.cssText = 'padding: 10px; border: 1px solid #ddd; margin-bottom: 5px; border-radius: 5px; cursor: pointer;';
                            resultDiv.textContent = `${node.question} (Layer ${node.depth})`;
                            resultDiv.onclick = () => {
                                treeBuilder.selectNode(node.id);
                                modal.remove();
                                document.getElementById('builder-panel').style.display = 'block';
                                document.getElementById('settings-panel').style.display = 'none';
                            };
                            results.appendChild(resultDiv);
                        }
                    });
                    
                    if (results.innerHTML === '') {
                        results.innerHTML = '<p style="color: #999;">No nodes found</p>';
                    }
                }
            });
            
            searchInput.focus();
        };

        window.updateNodeSize = function(size) {
            nodeSize = parseInt(size);
            // Update visualization with new node size
            visualizeTree();
        };

        window.updateAnimationSpeed = function(speed) {
            animationSpeed = parseInt(speed);
        };

        window.toggleTooltips = function() {
            const showTooltips = document.getElementById('show-tooltips').checked;
            console.log('Tooltips:', showTooltips ? 'enabled' : 'disabled');
        };

        window.toggleGrid = function() {
            const showGrid = document.getElementById('show-grid').checked;
            const svg = document.getElementById('tree-svg');
            
            if (showGrid) {
                let defs = svg.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    svg.appendChild(defs);
                }
                
                if (!defs.querySelector('#grid')) {
                    const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                    pattern.setAttribute('id', 'grid');
                    pattern.setAttribute('width', '50');
                    pattern.setAttribute('height', '50');
                    pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                    pattern.innerHTML = '<path d="M 50 0 L 0 0 0 50" fill="none" stroke="#e0e0e0" stroke-width="1"/>';
                    defs.appendChild(pattern);
                }
                
                if (!svg.querySelector('#grid-background')) {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('width', '100%');
                    rect.setAttribute('height', '100%');
                    rect.setAttribute('fill', 'url(#grid)');
                    rect.setAttribute('id', 'grid-background');
                    svg.insertBefore(rect, svg.firstChild);
                }
            } else {
                const grid = svg.querySelector('#grid-background');
                if (grid) grid.remove();
            }
        };

        window.toggleAutoSave = function() {
            const checkbox = document.getElementById('auto-save');
            if (checkbox.checked) {
                autoSaveInterval = setInterval(() => {
                    saveTreeConfiguration();
                    console.log('Auto-saved at', new Date().toLocaleTimeString());
                }, 30000);
            } else {
                if (autoSaveInterval) {
                    clearInterval(autoSaveInterval);
                    autoSaveInterval = null;
                }
            }
        };

        window.undoAction = function() {
            console.log('Undo functionality will be implemented soon');
        };

        window.redoAction = function() {
            console.log('Redo functionality will be implemented soon');
        };

        // ============= UI Functions for New Features =============
        
        // Feature 1: Tree Templates UI
        function showTreeTemplates() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; overflow-y: auto;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 20px; width: 700px; max-height: 85vh; overflow-y: auto;';
            
            let html = `
                <h2 style="margin-bottom: 20px; color: #0039A6;">📋 Tree Templates</h2>
                <p style="margin-bottom: 20px; color: #666;">Select a pre-built template to quickly start your decision tree:</p>
                <div style="display: grid; gap: 15px;">
            `;
            
            Object.entries(treeTemplates).forEach(([key, template]) => {
                html += `
                    <div style="padding: 20px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 10px; background: linear-gradient(135deg, rgba(0, 57, 166, 0.05), rgba(0, 174, 239, 0.05)); cursor: pointer; transition: all 0.3s;"
                         onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0, 57, 166, 0.3)';"
                         onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                         onclick="loadTreeTemplate('${key}')">
                        <h3 style="margin-bottom: 10px; color: #0039A6;">${template.name}</h3>
                        <p style="color: #666; font-size: 14px; margin-bottom: 10px;">${template.description}</p>
                        <div style="display: flex; gap: 10px; font-size: 12px; color: #999;">
                            <span>📊 Scale: ${template.scale}</span>
                            <span>🌳 Layers: ${template.tree.layers.length}</span>
                            <span>📍 Nodes: ${template.tree.layers.reduce((sum, layer) => sum + layer.nodes.length, 0)}</span>
                        </div>
                    </div>
                `;
            });
            
            html += `
                </div>
                <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid #eee;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" 
                        style="padding: 12px 24px; background: #ccc; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function loadTreeTemplate(templateKey) {
            const template = treeTemplates[templateKey];
            if (!template) return;
            
            if (treeBuilder.nodes.size > 0) {
                if (!confirm('Loading a template will replace your current tree. Continue?')) {
                    return;
                }
            }
            
            // Clear current tree
            treeBuilder.layers = [];
            treeBuilder.nodes.clear();
            
            // Apply template scale
            document.getElementById('scale-type').value = template.scale;
            updateScaleType();
            
            // Load template tree structure
            template.tree.layers.forEach(layerData => {
                const layer = treeBuilder.addLayer();
                layerData.nodes.forEach(nodeData => {
                    const node = new DecisionNode(
                        nodeData.id,
                        nodeData.question,
                        layerData.index,
                        nodeData.threshold,
                        nodeData.score
                    );
                    node.leftId = nodeData.leftId || null;
                    node.rightId = nodeData.rightId || null;
                    node.isTerminal = nodeData.isTerminal || false;
                    
                    layer.nodes.push(node);
                    treeBuilder.nodes.set(node.id, node);
                });
            });
            
            // Link nodes
            treeBuilder.layers.forEach((layer, layerIndex) => {
                layer.nodes.forEach(node => {
                    if (node.leftId) {
                        node.left = treeBuilder.nodes.get(node.leftId);
                    }
                    if (node.rightId) {
                        node.right = treeBuilder.nodes.get(node.rightId);
                    }
                });
            });
            
            // Close modal
            document.querySelector('[style*="position: fixed"][style*="z-index: 3000"]').remove();
            
            // Update visualization
            visualizeTree();
            
            // Show success message
            alert(`Template "${template.name}" loaded successfully!`);
        }
        
        // Feature 2: A/B Testing UI
        function showABTestingPanel() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; overflow-y: auto;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 20px; width: 800px; max-height: 85vh; overflow-y: auto;';
            
            let html = `
                <h2 style="margin-bottom: 20px; color: #0039A6;">🔬 A/B Testing Dashboard</h2>
                <div style="display: flex; gap: 20px; margin-bottom: 25px;">
                    <button onclick="showCreateABTest()" 
                        style="padding: 10px 20px; background: linear-gradient(135deg, #00AEEF, #0039A6); color: white; border: none; border-radius: 8px; cursor: pointer;">
                        ➕ Create New Test
                    </button>
                    <button onclick="refreshABTestDashboard()" 
                        style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        🔄 Refresh Results
                    </button>
                </div>
            `;
            
            // Active Tests Section
            html += `<h3 style="margin-top: 20px; color: #0039A6;">Active Tests</h3>`;
            const activeTests = abTestManager.activeTests;
            
            if (activeTests.size === 0) {
                html += `<p style="color: #999; padding: 20px; background: #f5f5f5; border-radius: 8px;">No active A/B tests</p>`;
            } else {
                html += `<div style="display: grid; gap: 15px; margin-bottom: 30px;">`;
                activeTests.forEach((test, nodeId) => {
                    const node = treeBuilder.nodes.get(nodeId);
                    const stats = abTestManager.calculateStatistics(nodeId);
                    
                    html += `
                        <div style="padding: 20px; border: 2px solid #00AEEF; border-radius: 10px; background: linear-gradient(135deg, rgba(0, 174, 239, 0.05), rgba(0, 57, 166, 0.05));">
                            <h4 style="margin-bottom: 10px;">${node ? node.question : 'Unknown Node'}</h4>
                            <p style="font-size: 12px; color: #666; margin-bottom: 15px;">Started: ${test.startTime.toLocaleString()}</p>
                            <div style="display: grid; grid-template-columns: repeat(${test.variants.length}, 1fr); gap: 15px;">
                    `;
                    
                    stats.variants.forEach(variant => {
                        const bgColor = variant.isWinning ? '#4CAF50' : '#2196F3';
                        html += `
                            <div style="padding: 10px; background: ${bgColor}; color: white; border-radius: 8px;">
                                <strong>Variant ${variant.name}</strong>
                                <div style="font-size: 12px; margin-top: 5px;">
                                    Threshold: ${variant.threshold}<br>
                                    Impressions: ${variant.impressions}<br>
                                    Conversion: ${(variant.conversionRate * 100).toFixed(1)}%<br>
                                    Avg Score: ${variant.avgScore.toFixed(2)}<br>
                                    CI: [${(variant.confidence.lower * 100).toFixed(1)}%, ${(variant.confidence.upper * 100).toFixed(1)}%]
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                            <div style="margin-top: 15px; display: flex; gap: 10px;">
                                <button onclick="endABTest('${nodeId}', false)" 
                                    style="padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                    End Test
                                </button>
                                <button onclick="endABTest('${nodeId}', true)" 
                                    style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                    End & Apply Winner
                                </button>
                            </div>
                        </div>
                    `;
                });
                html += `</div>`;
            }
            
            // Completed Tests Section
            html += `<h3 style="margin-top: 30px; color: #0039A6;">Completed Tests</h3>`;
            const completedTests = abTestManager.testResults;
            
            if (completedTests.size === 0) {
                html += `<p style="color: #999; padding: 20px; background: #f5f5f5; border-radius: 8px;">No completed tests</p>`;
            } else {
                html += `<div style="max-height: 300px; overflow-y: auto;">`;
                completedTests.forEach((result, nodeId) => {
                    const node = treeBuilder.nodes.get(nodeId);
                    html += `
                        <div style="padding: 15px; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 10px;">
                            <strong>${node ? node.question : 'Unknown Node'}</strong>
                            <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                Duration: ${result.test.startTime.toLocaleString()} - ${result.test.endTime.toLocaleString()}<br>
                                Winner: ${result.stats.hasWinner ? `Variant ${result.stats.variants.find(v => v.isWinning).name}` : 'No significant winner'}<br>
                                P-value: ${result.stats.significance ? result.stats.significance.pValue.toFixed(4) : 'N/A'}
                            </div>
                        </div>
                    `;
                });
                html += `</div>`;
            }
            
            html += `
                <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid #eee;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" 
                        style="padding: 12px 24px; background: #ccc; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function showCreateABTest() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 3500;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 20px; width: 500px;';
            
            // Get non-terminal nodes
            const eligibleNodes = [];
            treeBuilder.nodes.forEach(node => {
                if (!node.isTerminal) {
                    eligibleNodes.push(node);
                }
            });
            
            let html = `
                <h3 style="margin-bottom: 20px; color: #0039A6;">Create A/B Test</h3>
                
                <label style="display: block; margin-bottom: 15px;">
                    <strong>Select Node to Test:</strong>
                    <select id="ab-test-node" style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 8px;">
                        ${eligibleNodes.map(node => 
                            `<option value="${node.id}">${node.question} (Current: ${node.threshold})</option>`
                        ).join('')}
                    </select>
                </label>
                
                <label style="display: block; margin-bottom: 15px;">
                    <strong>Test Threshold (Variant B):</strong>
                    <input type="number" id="ab-test-threshold" step="0.1" 
                        style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 8px;"
                        placeholder="Enter new threshold to test">
                </label>
                
                <label style="display: block; margin-bottom: 15px;">
                    <strong>Traffic Allocation:</strong>
                    <select id="ab-test-allocation" style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 8px;">
                        <option value="50-50">50% / 50%</option>
                        <option value="75-25">75% Control / 25% Test</option>
                        <option value="25-75">25% Control / 75% Test</option>
                        <option value="90-10">90% Control / 10% Test</option>
                    </select>
                </label>
                
                <div style="display: flex; gap: 10px; margin-top: 25px;">
                    <button onclick="createABTest()" 
                        style="flex: 1; padding: 12px; background: linear-gradient(135deg, #00AEEF, #0039A6); color: white; border: none; border-radius: 8px; cursor: pointer;">
                        Start Test
                    </button>
                    <button onclick="this.closest('[style*=\"z-index: 3500\"]').remove()" 
                        style="flex: 1; padding: 12px; background: #ccc; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function createABTest() {
            const nodeId = document.getElementById('ab-test-node').value;
            const testThreshold = parseFloat(document.getElementById('ab-test-threshold').value);
            const allocation = document.getElementById('ab-test-allocation').value;
            
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) {
                alert('Invalid node selected');
                return;
            }
            
            if (isNaN(testThreshold)) {
                alert('Please enter a valid threshold value');
                return;
            }
            
            // Parse allocation
            let allocationArray;
            switch(allocation) {
                case '75-25': allocationArray = [0.75, 0.25]; break;
                case '25-75': allocationArray = [0.25, 0.75]; break;
                case '90-10': allocationArray = [0.9, 0.1]; break;
                default: allocationArray = [0.5, 0.5];
            }
            
            // Create the test
            abTestManager.createTest(nodeId, {
                originalThreshold: node.threshold,
                testThreshold: testThreshold,
                allocation: allocationArray
            });
            
            // Close modals
            document.querySelector('[style*="z-index: 3500"]').remove();
            document.querySelector('[style*="z-index: 3000"]').remove();
            
            // Reopen dashboard
            showABTestingPanel();
            
            alert(`A/B test created for "${node.question}"!\nControl: ${node.threshold} vs Test: ${testThreshold}`);
        }
        
        function endABTest(nodeId, applyWinner) {
            const stats = abTestManager.endTest(nodeId, applyWinner);
            
            if (stats && stats.hasWinner && applyWinner) {
                const winner = stats.variants.find(v => v.isWinning);
                alert(`Test ended. Winner applied: Threshold ${winner.threshold} with ${(winner.conversionRate * 100).toFixed(1)}% conversion rate`);
            } else if (stats) {
                alert('Test ended. Results archived.');
            }
            
            // Refresh dashboard
            refreshABTestDashboard();
        }
        
        function refreshABTestDashboard() {
            document.querySelector('[style*="z-index: 3000"]').remove();
            showABTestingPanel();
        }
        
        // Feature 3: Data Mapping Templates UI
        function showMappingTemplates() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; overflow-y: auto;';
            
            const content = document.createElement('div');
            content.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 20px; width: 700px; max-height: 85vh; overflow-y: auto;';
            
            const templates = dataMappingTemplates.getTemplateList();
            
            let html = `
                <h2 style="margin-bottom: 20px; color: #0039A6;">🗂️ Data Import Templates</h2>
                <p style="margin-bottom: 20px; color: #666;">Manage and apply saved field mapping templates for consistent data imports:</p>
                
                <div style="margin-bottom: 25px;">
                    <button onclick="importMappingTemplate()" 
                        style="padding: 10px 20px; background: linear-gradient(135deg, #0039A6, #97CAEB); color: white; border: none; border-radius: 8px; cursor: pointer; margin-right: 10px;">
                        📥 Import Template
                    </button>
                    <input type="file" id="import-mapping-file" style="display: none;" accept=".json">
                </div>
            `;
            
            if (templates.length === 0) {
                html += `
                    <div style="padding: 40px; text-align: center; background: #f5f5f5; border-radius: 10px;">
                        <p style="color: #999; margin-bottom: 20px;">No saved templates yet</p>
                        <p style="color: #666; font-size: 14px;">Templates will be created automatically when you import data and can be reused for similar data formats.</p>
                    </div>
                `;
            } else {
                html += `<div style="display: grid; gap: 15px;">`;
                templates.forEach(template => {
                    const date = new Date(template.created);
                    html += `
                        <div style="padding: 20px; border: 2px solid rgba(0, 57, 166, 0.2); border-radius: 10px; background: linear-gradient(135deg, rgba(0, 57, 166, 0.05), rgba(151, 202, 235, 0.05));">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <h3 style="margin-bottom: 10px; color: #0039A6;">${template.name}</h3>
                                    <p style="font-size: 12px; color: #999; margin-bottom: 10px;">Created: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}</p>
                                    <div style="display: flex; gap: 15px; font-size: 13px; color: #666;">
                                        <span>📊 Scale: ${template.scale}</span>
                                        <span>🔢 Fields: ${template.scoreFields.length}</span>
                                        <span>${template.allowDecimals ? '✓ Decimals' : '✗ Integers only'}</span>
                                    </div>
                                    <div style="margin-top: 10px; padding: 10px; background: #f9f9f9; border-radius: 6px; font-size: 12px;">
                                        <strong>Score Fields:</strong> ${template.scoreFields.slice(0, 5).join(', ')}${template.scoreFields.length > 5 ? '...' : ''}
                                    </div>
                                </div>
                                <div style="display: flex; flex-direction: column; gap: 8px;">
                                    <button onclick="applyMappingTemplate('${template.name}')" 
                                        style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                        Apply
                                    </button>
                                    <button onclick="exportMappingTemplate('${template.name}')" 
                                        style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                        Export
                                    </button>
                                    <button onclick="deleteMappingTemplate('${template.name}')" 
                                        style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += `</div>`;
            }
            
            html += `
                <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid #eee;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" 
                        style="padding: 12px 24px; background: #ccc; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Add X close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = 'position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: #f0f0f0; border-radius: 50%; font-size: 24px; cursor: pointer; color: #666; font-weight: bold; line-height: 1; display: flex; align-items: center; justify-content: center;';
            closeBtn.onmouseover = () => { closeBtn.style.background = '#e0e0e0'; closeBtn.style.color = '#000'; };
            closeBtn.onmouseout = () => { closeBtn.style.background = '#f0f0f0'; closeBtn.style.color = '#666'; };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function applyMappingTemplate(templateName) {
            if (!window.uploadedSurveyData) {
                alert('Please upload survey data first, then apply the template');
                document.getElementById('survey-data-file').click();
                return;
            }
            
            const processedData = dataMappingTemplates.applyTemplate(templateName, window.uploadedSurveyData);
            if (processedData) {
                surveyData = processedData;
                continueProcessingData(processedData);
                document.querySelector('[style*="position: fixed"][style*="z-index: 3000"]').remove();
                alert(`Template "${templateName}" applied successfully!`);
            }
        }
        
        function exportMappingTemplate(name) {
            dataMappingTemplates.exportTemplate(name);
        }
        
        function deleteMappingTemplate(name) {
            if (confirm(`Delete template "${name}"?`)) {
                dataMappingTemplates.deleteTemplate(name);
                refreshMappingTemplates();
            }
        }
        
        function importMappingTemplate() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    const template = dataMappingTemplates.importTemplate(event.target.result);
                    if (template) {
                        refreshMappingTemplates();
                        alert(`Template "${template.name}" imported successfully!`);
                    } else {
                        alert('Failed to import template');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        function refreshMappingTemplates() {
            document.querySelector('[style*="z-index: 3000"]').remove();
            showMappingTemplates();
        }
        
        // Modify the existing showFieldSelector to save templates
        const originalShowFieldSelector = window.showFieldSelector;
        window.showFieldSelector = function(rawData) {
            // Call original function
            originalShowFieldSelector.call(this, rawData);
            
            // Add save template button to the field selector modal
            setTimeout(() => {
                const processBtn = document.getElementById('process-fields-btn');
                if (processBtn) {
                    const saveTemplateBtn = document.createElement('button');
                    saveTemplateBtn.textContent = '💾 Save as Template';
                    saveTemplateBtn.style.cssText = 'flex: 1; padding: 12px; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; border-radius: 10px; cursor: pointer;';
                    saveTemplateBtn.onclick = function() {
                        const idField = document.getElementById('id-field-selector').value;
                        const scoreFields = [];
                        const fields = Object.keys(rawData[0]);
                        
                        fields.forEach(field => {
                            const sanitizedField = field.replace(/[^a-zA-Z0-9]/g, '_');
                            const checkbox = document.getElementById(`score-field-${sanitizedField}`);
                            if (checkbox && checkbox.checked) {
                                scoreFields.push(field);
                            }
                        });
                        
                        if (scoreFields.length === 0) {
                            alert('Please select at least one score field');
                            return;
                        }
                        
                        const templateName = prompt('Enter a name for this mapping template:');
                        if (templateName) {
                            dataMappingTemplates.saveTemplate(templateName, {
                                idField: idField,
                                scoreFields: scoreFields,
                                scale: currentScaleRange,
                                allowDecimals: allowDecimals,
                                sampleData: rawData[0]
                            });
                            alert(`Template "${templateName}" saved successfully!`);
                        }
                    };
                    
                    // Insert before the Cancel button
                    processBtn.parentElement.insertBefore(saveTemplateBtn, processBtn.nextSibling);
                }
            }, 100);
        };
        
        // Integrate A/B testing with survey processing
        const originalSubmitScore = window.submitScore;
        window.submitScore = function() {
            const score = parseFloat(document.getElementById('score-input').value);
            
            if (currentSurveyNode && abTestManager.activeTests.has(currentSurveyNode.id)) {
                // Get variant assignment for this respondent
                const respondentId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const variant = abTestManager.assignVariant(currentSurveyNode.id, respondentId);
                
                if (variant) {
                    // Use variant threshold instead of original
                    const originalThreshold = currentSurveyNode.threshold;
                    currentSurveyNode.threshold = variant.threshold;
                    
                    // Call original submit
                    originalSubmitScore.call(this);
                    
                    // Record conversion
                    const decision = score >= variant.threshold ? 'right' : 'left';
                    abTestManager.recordConversion(currentSurveyNode.id, variant.name, score, decision);
                    
                    // Restore original threshold
                    currentSurveyNode.threshold = originalThreshold;
                    
                    return;
                }
            }
            
            // No A/B test, proceed normally
            originalSubmitScore.call(this);
        };
    </script>
</body>
</html>
