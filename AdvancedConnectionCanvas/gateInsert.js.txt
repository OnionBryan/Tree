// ============================================================================
        // Gate Insertion and Chaining Functions
        // ============================================================================

        function insertGateBefore(nodeId) {
            const targetNode = treeBuilder.nodes.get(nodeId);
            if (!targetNode) return;

            // Show gate selection dialog with callback
            showGateSelector((gateType, params) => {
                if (!gateType) return;

                // Create new gate node with parameters
                const gateNode = createGateNode(gateType, targetNode, params);

                // Find parent connections to targetNode
                const parents = findNodeParents(nodeId);

                // Insert gate between parents and target
                parents.forEach(parent => {
                    // Find which branch index connects to target
                    let branchIndex = 0;
                    if (parent.childIds) {
                        branchIndex = parent.childIds.indexOf(nodeId);
                        if (branchIndex === -1) branchIndex = 0;
                    }

                    disconnectNodes(parent.id, nodeId, branchIndex);
                    connectNodes(parent.id, gateNode.id, branchIndex);
                });

                // Connect gate to target
                connectNodes(gateNode.id, nodeId);

                // Update advanced node if exists
                if (window.AdvancedTreeLogic && window.AdvancedTreeLogic.graph) {
                    const advancedGate = window.AdvancedTreeLogic.graph.nodes.get(gateNode.id);
                    if (advancedGate) {
                        advancedGate.parameters = params;
                    }
                }

                // Refresh displays
                treeBuilder.updateLayersDisplay();
                visualizeTree();
            });
        }

        function insertGateAfter(nodeId) {
            const sourceNode = treeBuilder.nodes.get(nodeId);
            if (!sourceNode) return;

            // Show gate selection dialog with callback
            showGateSelector((gateType, params) => {
                if (!gateType) return;

                // Create new gate node with parameters
                const gateNode = createGateNode(gateType, sourceNode, params);

                // Store existing children connections
                const childConnections = [];
                if (sourceNode.childIds) {
                    sourceNode.childIds.forEach((childId, branchIndex) => {
                        if (childId) {
                            childConnections.push({ childId, branchIndex });
                        }
                    });
                }

                // Determine which branch to connect gate to
                let sourceBranchIndex = 0;
                if (sourceNode.branchCount > 1) {
                    // For multi-branch nodes, could prompt user or use first available
                    sourceBranchIndex = sourceNode.childIds ? sourceNode.childIds.findIndex(id => !id) : 0;
                    if (sourceBranchIndex === -1) sourceBranchIndex = 0;
                }

                // Disconnect all children from source
                childConnections.forEach(({ childId, branchIndex }) => {
                    disconnectNodes(nodeId, childId, branchIndex);
                });

                // Connect source to gate
                connectNodes(nodeId, gateNode.id, sourceBranchIndex);

                // Reconnect children to gate outputs
                childConnections.forEach(({ childId }, index) => {
                    const gateBranchIndex = Math.min(index, (gateNode.branchCount || 2) - 1);
                    connectNodes(gateNode.id, childId, gateBranchIndex);
                });

                // Update advanced node if exists
                if (window.AdvancedTreeLogic && window.AdvancedTreeLogic.graph) {
                    const advancedGate = window.AdvancedTreeLogic.graph.nodes.get(gateNode.id);
                    if (advancedGate) {
                        advancedGate.parameters = params;
                    }
                }

                // Refresh displays
                treeBuilder.updateLayersDisplay();
                visualizeTree();
            });
        }

        function showGateSelector(callback) {
            // Create modal backdrop
            const backdrop = document.createElement('div');
            backdrop.id = 'gate-selector-backdrop';
            backdrop.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999;';

            // Create gate selection modal
            const modal = document.createElement('div');
            modal.id = 'gate-selector-modal';
            modal.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 10000; min-width: 400px;';

            // Gate types with configurations
            const gateTypes = [
                { type: 'and', label: 'AND', color: '#8B5CF6', outputs: 2 },
                { type: 'or', label: 'OR', color: '#6366F1', outputs: 2 },
                { type: 'xor', label: 'XOR', color: '#EC4899', outputs: 2 },
                { type: 'nand', label: 'NAND', color: '#F59E0B', outputs: 2 },
                { type: 'nor', label: 'NOR', color: '#10B981', outputs: 2 },
                { type: 'not', label: 'NOT', color: '#EF4444', outputs: 2 },
                { type: 'majority', label: 'MAJORITY', color: '#3B82F6', outputs: 2 },
                { type: 'threshold', label: 'THRESHOLD', color: '#14B8A6', outputs: 'variable' },
                { type: 'fuzzy_and', label: 'FUZZY AND', color: '#A855F7', outputs: 'continuous' },
                { type: 'fuzzy_or', label: 'FUZZY OR', color: '#0EA5E9', outputs: 'continuous' },
                { type: 'router', label: 'ROUTER', color: '#F97316', outputs: 'variable' },
                { type: 'merge', label: 'MERGE', color: '#84CC16', outputs: 1 }
            ];

            let buttonsHTML = gateTypes.map(g =>
                `<button class="gate-select-btn" data-gate-type="${g.type}" data-outputs="${g.outputs}" style="background: ${g.color};">${g.label}</button>`
            ).join('');

            modal.innerHTML = `
                <h3 style="margin-bottom: 15px; color: #6366F1; font-family: system-ui;">Select Logic Gate</h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 15px;">
                    ${buttonsHTML}
                </div>
                <div id="gate-config" style="margin-bottom: 15px; display: none;">
                    <label style="display: block; margin-bottom: 5px; color: #374151;">Gate Configuration:</label>
                    <input type="text" id="gate-params" placeholder="Parameters (e.g., threshold values)" style="width: 100%; padding: 8px; border: 1px solid #D1D5DB; border-radius: 4px;">
                </div>
                <button id="cancel-gate-selector" style="padding: 8px 16px; background: #EF4444; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
            `;

            // Add backdrop and modal to DOM
            document.body.appendChild(backdrop);
            document.body.appendChild(modal);

            // Add event handlers
            const buttons = modal.querySelectorAll('.gate-select-btn');
            buttons.forEach(btn => {
                btn.addEventListener('click', function() {
                    const gateType = this.dataset.gateType;
                    const outputs = this.dataset.outputs;

                    // Show config for variable output gates
                    if (outputs === 'variable' || gateType === 'threshold' || gateType === 'router') {
                        const configDiv = document.getElementById('gate-config');
                        configDiv.style.display = 'block';
                        document.getElementById('gate-params').placeholder =
                            gateType === 'threshold' ? 'Enter threshold values (e.g., -5,2,5)' :
                            gateType === 'router' ? 'Enter number of outputs (e.g., 4)' :
                            'Enter parameters';

                        // Wait for parameter input
                        document.getElementById('gate-params').focus();
                        document.getElementById('gate-params').addEventListener('keypress', function(e) {
                            if (e.key === 'Enter') {
                                const params = this.value;
                                closeGateSelectorModal();
                                if (callback) callback(gateType, params);
                            }
                        });
                    } else {
                        closeGateSelectorModal();
                        if (callback) callback(gateType, null);
                    }
                });
            });

            // Cancel button
            document.getElementById('cancel-gate-selector').addEventListener('click', function() {
                closeGateSelectorModal();
                if (callback) callback(null, null);
            });

            // Close on backdrop click
            backdrop.addEventListener('click', function() {
                closeGateSelectorModal();
                if (callback) callback(null, null);
            });

            // Add styles
            if (!document.getElementById('gate-selector-styles')) {
                const style = document.createElement('style');
                style.id = 'gate-selector-styles';
                style.textContent = `
                    .gate-select-btn {
                        padding: 10px;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 600;
                        transition: transform 0.2s, box-shadow 0.2s;
                    }
                    .gate-select-btn:hover {
                        transform: scale(1.05);
                        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    }
                    .gate-select-btn:active {
                        transform: scale(0.98);
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function closeGateSelectorModal() {
            const backdrop = document.getElementById('gate-selector-backdrop');
            const modal = document.getElementById('gate-selector-modal');
            if (backdrop) backdrop.remove();
            if (modal) modal.remove();
        }

        function createGateNode(gateType, referenceNode, params) {
            const layer = treeBuilder.getNodeLayer(referenceNode.id);
            const newNode = treeBuilder.addNodeToLayer(layer);

            // Configure as gate
            newNode.nodeType = 'logic_gate';
            newNode.logicType = gateType;
            newNode.parameters = params;

            // Parse parameters for special gates
            let branchCount = 2;
            let branchLabels = ['False', 'True'];
            let gateLabel = gateType.toUpperCase();

            if (gateType === 'threshold' && params) {
                // Parse threshold values
                const thresholds = params.split(',').map(v => parseFloat(v.trim()));
                branchCount = thresholds.length + 1;
                branchLabels = ['< ' + thresholds[0]];
                for (let i = 0; i < thresholds.length - 1; i++) {
                    branchLabels.push(`${thresholds[i]} - ${thresholds[i+1]}`);
                }
                branchLabels.push('> ' + thresholds[thresholds.length - 1]);
                gateLabel = `THRESHOLD [${params}]`;
                newNode.thresholds = thresholds;
            } else if (gateType === 'router' && params) {
                // Router with N outputs
                branchCount = parseInt(params) || 2;
                branchLabels = [];
                for (let i = 0; i < branchCount; i++) {
                    branchLabels.push(`Output ${i + 1}`);
                }
                gateLabel = `ROUTER (${branchCount}-way)`;
                newNode.routerOutputs = branchCount;
            } else if (gateType === 'merge') {
                // Merge node has single output
                branchCount = 1;
                branchLabels = ['Merged Output'];
                newNode.acceptsMultipleInputs = true;
            } else if (gateType === 'majority') {
                branchCount = 2;
                branchLabels = ['Minority', 'Majority'];
            } else if (['fuzzy_and', 'fuzzy_or'].includes(gateType)) {
                // Fuzzy gates can have continuous output
                branchCount = 3;
                branchLabels = ['Low', 'Medium', 'High'];
                newNode.fuzzyOutput = true;
            }

            newNode.question = gateLabel + ' Gate';
            newNode.branchCount = branchCount;
            newNode.branchLabels = branchLabels;

            // Initialize child arrays
            newNode.childIds = new Array(branchCount).fill(null);
            newNode.children = new Array(branchCount).fill(null);

            // Create advanced node
            if (window.AdvancedTreeLogic && window.AdvancedTreeLogic.graph) {
                const advancedNode = new AdvancedNode({
                    id: newNode.id,
                    name: newNode.question,
                    nodeType: 'logic_gate',
                    logicType: gateType,
                    layer: layer,
                    branchCount: branchCount,
                    parameters: params
                });

                // Add gate-specific evaluation logic
                advancedNode.evaluateGate = function(inputs) {
                    switch(gateType) {
                        case 'and':
                            return inputs.every(i => i) ? 1 : 0;
                        case 'or':
                            return inputs.some(i => i) ? 1 : 0;
                        case 'xor':
                            return inputs.filter(i => i).length % 2 ? 1 : 0;
                        case 'nand':
                            return inputs.every(i => i) ? 0 : 1;
                        case 'nor':
                            return inputs.some(i => i) ? 0 : 1;
                        case 'not':
                            return inputs[0] ? 0 : 1;
                        case 'majority':
                            return inputs.filter(i => i).length > inputs.length / 2 ? 1 : 0;
                        case 'threshold':
                            const value = inputs.reduce((a, b) => a + b, 0);
                            for (let i = 0; i < this.thresholds.length; i++) {
                                if (value < this.thresholds[i]) return i;
                            }
                            return this.thresholds.length;
                        case 'router':
                            // Route based on input value modulo output count
                            return Math.abs(inputs[0]) % this.routerOutputs;
                        case 'merge':
                            // Combine multiple inputs into single output
                            return inputs.reduce((a, b) => a || b, 0) ? 0 : 0;
                        case 'fuzzy_and':
                            const minVal = Math.min(...inputs.map(i => i || 0));
                            return minVal < 0.33 ? 0 : minVal < 0.67 ? 1 : 2;
                        case 'fuzzy_or':
                            const maxVal = Math.max(...inputs.map(i => i || 0));
                            return maxVal < 0.33 ? 0 : maxVal < 0.67 ? 1 : 2;
                        default:
                            return 0;
                    }
                };

                window.AdvancedTreeLogic.graph.addNode(advancedNode);
            }

            return newNode;
        }

        function findNodeParents(nodeId) {
            const parents = [];
            treeBuilder.nodes.forEach((node, id) => {
                if (node.childIds && node.childIds.includes(nodeId)) {
                    parents.push(node);
                }
            });
            return parents;
        }

        function disconnectNodes(sourceId, targetId, branchIndex = null) {
            const sourceNode = treeBuilder.nodes.get(sourceId);
            if (!sourceNode) return;

            if (branchIndex !== null && sourceNode.childIds) {
                sourceNode.childIds[branchIndex] = null;
                sourceNode.children[branchIndex] = null;
            } else if (sourceNode.childIds) {
                const index = sourceNode.childIds.indexOf(targetId);
                if (index !== -1) {
                    sourceNode.childIds[index] = null;
                    sourceNode.children[index] = null;
                }
            }
        }

        function connectNodes(sourceId, targetId, branchIndex = 0) {
            const sourceNode = treeBuilder.nodes.get(sourceId);
            const targetNode = treeBuilder.nodes.get(targetId);
            if (!sourceNode || !targetNode) return;

            if (!sourceNode.childIds) {
                sourceNode.childIds = new Array(sourceNode.branchCount || 2).fill(null);
                sourceNode.children = new Array(sourceNode.branchCount || 2).fill(null);
            }

            sourceNode.childIds[branchIndex] = targetId;
            sourceNode.children[branchIndex] = targetNode;
        }

        // ============================================================================
        // Advanced Routing Functions
        // ============================================================================

        function updateConnectionMode(nodeId, mode) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            node.connectionMode = mode;

            // Update visual indicators
            const modeIndicator = document.getElementById(`connection-mode-indicator-${nodeId}`);
            if (modeIndicator) {
                const modeIcons = {
                    'forward': '‚Üí',
                    'backward': '‚Üê',
                    'skip': '‚§µ',
                    'lateral': '‚Üî',
                    'self': '‚Üª',
                    'merge': '‚≠É',
                    'split': '‚≠Ñ'
                };
                modeIndicator.textContent = modeIcons[mode] || '';
            }

            // Enable/disable loop detection based on mode
            if (mode === 'backward' || mode === 'self') {
                enableLoopMode(nodeId);
            }
        }

        function enableLoopMode(nodeId) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            // Mark as loop node
            node.isLoopNode = true;
            node.maxIterations = 10; // Default max iterations

            // Add visual indicator
            const nodeDiv = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (nodeDiv) {
                nodeDiv.style.border = '2px dashed #EF4444';
            }
        }

        function applyRoutingPattern(nodeId, pattern) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            switch(pattern) {
                case 'diamond':
                    createDiamondPattern(nodeId);
                    break;
                case 'star':
                    createStarPattern(nodeId);
                    break;
                case 'cascade':
                    createCascadePattern(nodeId);
                    break;
                case 'pipeline':
                    createPipelinePattern(nodeId);
                    break;
                case 'parallel':
                    createParallelPattern(nodeId);
                    break;
                case 'feedback':
                    createFeedbackPattern(nodeId);
                    break;
            }

            treeBuilder.updateLayersDisplay();
            visualizeTree();
        }

        function createDiamondPattern(nodeId) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            const layer = treeBuilder.getNodeLayer(nodeId);

            // Create split nodes
            const leftPath = treeBuilder.addNodeToLayer(layer + 1);
            leftPath.question = "Diamond Left Path";
            const rightPath = treeBuilder.addNodeToLayer(layer + 1);
            rightPath.question = "Diamond Right Path";

            // Create merge node
            const mergeNode = treeBuilder.addNodeToLayer(layer + 2);
            mergeNode.question = "Diamond Merge";
            mergeNode.nodeType = 'merge';
            mergeNode.acceptsMultipleInputs = true;

            // Connect diamond pattern
            connectNodes(nodeId, leftPath.id, 0);
            connectNodes(nodeId, rightPath.id, 1);
            connectNodes(leftPath.id, mergeNode.id);
            connectNodes(rightPath.id, mergeNode.id);
        }

        function createStarPattern(nodeId) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            const layer = treeBuilder.getNodeLayer(nodeId);
            const spokes = 4; // Number of spokes

            // Set node as hub
            node.branchCount = spokes;
            node.nodeType = 'hub';
            updateNodeBranches(nodeId, spokes);

            // Create spoke nodes
            for (let i = 0; i < spokes; i++) {
                const spokeNode = treeBuilder.addNodeToLayer(layer + 1);
                spokeNode.question = `Spoke ${i + 1}`;
                connectNodes(nodeId, spokeNode.id, i);
            }
        }

        function createFeedbackPattern(nodeId) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            const layer = treeBuilder.getNodeLayer(nodeId);

            // Create processing node
            const processNode = treeBuilder.addNodeToLayer(layer + 1);
            processNode.question = "Process";

            // Create feedback check node
            const feedbackNode = treeBuilder.addNodeToLayer(layer + 2);
            feedbackNode.question = "Feedback Check";
            feedbackNode.nodeType = 'logic_gate';
            feedbackNode.logicType = 'threshold';

            // Connect forward path
            connectNodes(nodeId, processNode.id);
            connectNodes(processNode.id, feedbackNode.id);

            // Create feedback loop
            feedbackNode.connectionMode = 'backward';
            feedbackNode.isLoopNode = true;
            connectNodes(feedbackNode.id, nodeId, 1); // Feedback on branch 1
        }

        function openAdvancedConnectionEditor(nodeId) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            // Create advanced editor modal
            const modal = document.createElement('div');
            modal.id = 'connection-editor-modal';
            modal.style.cssText = `
                position: fixed;
                top: 10%;
                left: 10%;
                width: 80%;
                height: 80%;
                background: white;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                z-index: 10000;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            `;

            modal.innerHTML = `
                <div style="padding: 20px; background: linear-gradient(135deg, #8B5CF6, #6366F1); color: white;">
                    <h2>Advanced Connection Editor - ${node.question}</h2>
                    <button onclick="closeConnectionEditor()" style="float: right; background: white; color: #8B5CF6; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">‚úï Close</button>
                </div>

                <div style="flex: 1; display: flex; overflow: hidden;">
                    <!-- Gate Palette -->
                    <div style="width: 200px; padding: 20px; background: #F9FAFB; border-right: 1px solid #E5E7EB; overflow-y: auto;">
                        <h3 style="margin-bottom: 15px; color: #374151;">Tools & Gates</h3>

                        <!-- Connection Tools -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="margin-bottom: 10px; color: #6B7280; font-size: 14px;">Connection Tools</h4>
                            <button onclick="showConnectionBuilder()" style="
                                width: 100%;
                                padding: 10px;
                                background: linear-gradient(135deg, #10B981, #059669);
                                color: white;
                                border: none;
                                border-radius: 6px;
                                cursor: pointer;
                                font-weight: 600;
                                margin-bottom: 8px;
                            ">
                                üîó Build Connection
                            </button>
                            <button id="edge-tool-btn" onclick="toggleEdgeMode()" style="
                                width: 100%;
                                padding: 10px;
                                background: linear-gradient(135deg, #3B82F6, #6366F1);
                                color: white;
                                border: none;
                                border-radius: 6px;
                                cursor: pointer;
                                font-weight: 600;
                                margin-bottom: 8px;
                            ">
                                ‚úèÔ∏è Draw Edge Mode
                            </button>
                            <button onclick="clearAllConnections()" style="
                                width: 100%;
                                padding: 8px;
                                background: #EF4444;
                                color: white;
                                border: none;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 12px;
                            ">
                                Clear All Edges
                            </button>
                        </div>

                        <!-- Gate Palette -->
                        <h4 style="margin-bottom: 10px; color: #6B7280; font-size: 14px;">Logic Gates</h4>
                        <div id="gate-palette" style="display: flex; flex-direction: column; gap: 8px;">
                            <div class="palette-gate" draggable="true" data-gate="and">AND Gate</div>
                            <div class="palette-gate" draggable="true" data-gate="or">OR Gate</div>
                            <div class="palette-gate" draggable="true" data-gate="xor">XOR Gate</div>
                            <div class="palette-gate" draggable="true" data-gate="nand">NAND Gate</div>
                            <div class="palette-gate" draggable="true" data-gate="threshold">Threshold</div>
                            <div class="palette-gate" draggable="true" data-gate="fuzzy">Fuzzy Gate</div>
                            <div class="palette-gate" draggable="true" data-gate="merge">Merge Node</div>
                            <div class="palette-gate" draggable="true" data-gate="router">Router Node</div>
                        </div>
                    </div>

                    <!-- Canvas Area -->
                    <div style="flex: 1; position: relative; background: white;">
                        <canvas id="connection-canvas" style="width: 100%; height: 100%;"></canvas>
                    </div>

                    <!-- Properties Panel -->
                    <div style="width: 250px; padding: 20px; background: #F9FAFB; border-left: 1px solid #E5E7EB; overflow-y: auto;">
                        <h3 style="margin-bottom: 15px; color: #374151;">Properties</h3>
                        <div id="properties-panel">
                            <p style="color: #9CA3AF;">Select a node or connection to edit properties</p>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Add styles
            const style = document.createElement('style');
            style.textContent = `
                .palette-gate {
                    padding: 8px 12px;
                    background: white;
                    border: 1px solid #D1D5DB;
                    border-radius: 6px;
                    cursor: move;
                    transition: all 0.2s;
                }
                .palette-gate:hover {
                    background: #F3F4F6;
                    border-color: #8B5CF6;
                }
                .palette-gate.dragging {
                    opacity: 0.5;
                }
            `;
            document.head.appendChild(style);

            // Initialize drag and drop
            initializeDragAndDrop();

            // Initialize canvas
            initializeConnectionCanvas(nodeId);

            window.connectionEditorModal = modal;
        }

        window.closeConnectionEditor = function() {
            // Try multiple methods to close the modal
            const modal = document.getElementById('connection-editor-modal') ||
                          document.querySelector('[style*="z-index: 10000"]') ||
                          window.connectionEditorModal;

            if (modal) {
                modal.remove();
            }

            window.connectionEditorModal = null;
        }

        // Connection Builder UI - Comprehensive system for building connections
        window.showConnectionBuilder = function() {
            // Validate canvas nodes exist
            if (!window.canvasNodes || window.canvasNodes.size === 0) {
                alert('No nodes available. Add nodes to the canvas first.');
                return;
            }

            // Create builder popup with comprehensive controls
            const popup = document.createElement('div');
            popup.id = 'connection-builder-popup';
            popup.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border: 3px solid #6366F1;
                border-radius: 16px;
                padding: 30px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                z-index: 10001;
                width: 600px;
                max-height: 80vh;
                overflow-y: auto;
            `;

            // Build node selection options
            let nodeOptions = '<option value="">-- Select Node --</option>';
            window.canvasNodes.forEach(node => {
                nodeOptions += `<option value="${node.id}">${node.type} (${node.id})</option>`;
            });

            popup.innerHTML = `
                <h2 style="margin: 0 0 20px 0; color: #6366F1;">Connection Builder</h2>

                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #374151;">Source Node:</h3>
                    <select id="conn-from-node" style="width: 100%; padding: 10px; border: 2px solid #E5E7EB; border-radius: 8px; margin-bottom: 10px;">
                        ${nodeOptions}
                    </select>
                    <div id="from-ports" style="display: none; margin-top: 10px;">
                        <label style="color: #6B7280;">Output Port:</label>
                        <select id="conn-from-port" style="width: 100%; padding: 8px; border: 1px solid #E5E7EB; border-radius: 6px;">
                        </select>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #374151;">Target Node:</h3>
                    <select id="conn-to-node" style="width: 100%; padding: 10px; border: 2px solid #E5E7EB; border-radius: 8px; margin-bottom: 10px;">
                        ${nodeOptions}
                    </select>
                    <div id="to-ports" style="display: none; margin-top: 10px;">
                        <label style="color: #6B7280;">Input Port:</label>
                        <select id="conn-to-port" style="width: 100%; padding: 8px; border: 1px solid #E5E7EB; border-radius: 6px;">
                        </select>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #374151;">Connection Properties:</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #6B7280;">Threshold Value:</label>
                        <input type="number" id="conn-threshold" value="0" step="0.1"
                               style="width: 100%; padding: 10px; border: 2px solid #E5E7EB; border-radius: 8px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #6B7280;">Connection Type:</label>
                        <select id="conn-type" style="width: 100%; padding: 10px; border: 2px solid #E5E7EB; border-radius: 8px;">
                            <option value="normal">Normal Flow</option>
                            <option value="conditional">Conditional (Threshold-based)</option>
                            <option value="feedback">Feedback Loop</option>
                            <option value="bypass">Bypass</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #6B7280;">Edge Label:</label>
                        <input type="text" id="conn-label" placeholder="Optional label"
                               style="width: 100%; padding: 10px; border: 2px solid #E5E7EB; border-radius: 8px;">
                    </div>
                </div>

                <div style="display: flex; gap: 15px;">
                    <button onclick="createConnectionFromBuilder()"
                            style="flex: 1; padding: 12px; background: linear-gradient(135deg, #10B981, #059669);
                                   color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px;">
                        Create Connection
                    </button>
                    <button onclick="document.getElementById('connection-builder-popup').remove()"
                            style="flex: 1; padding: 12px; background: #EF4444;
                                   color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px;">
                        Cancel
                    </button>
                </div>
            `;
            document.body.appendChild(popup);

            // Add event handlers for dynamic port selection
            document.getElementById('conn-from-node').addEventListener('change', function() {
                const nodeId = this.value;
                if (nodeId) {
                    const node = window.canvasNodes.get(nodeId);
                    if (node && node.outputs) {
                        const portSelect = document.getElementById('conn-from-port');
                        portSelect.innerHTML = '';
                        node.outputs.forEach((port, index) => {
                            portSelect.innerHTML += `<option value="${index}">Output ${index + 1}</option>`;
                        });
                        document.getElementById('from-ports').style.display = 'block';
                    }
                } else {
                    document.getElementById('from-ports').style.display = 'none';
                }
            });

            document.getElementById('conn-to-node').addEventListener('change', function() {
                const nodeId = this.value;
                if (nodeId) {
                    const node = window.canvasNodes.get(nodeId);
                    if (node && node.inputs) {
                        const portSelect = document.getElementById('conn-to-port');
                        portSelect.innerHTML = '';
                        node.inputs.forEach((port, index) => {
                            portSelect.innerHTML += `<option value="${index}">Input ${index + 1}</option>`;
                        });
                        document.getElementById('to-ports').style.display = 'block';
                    }
                } else {
                    document.getElementById('to-ports').style.display = 'none';
                }
            });
        }

        function createConnectionFromBuilder() {
            const fromNode = document.getElementById('conn-from-node').value;
            const toNode = document.getElementById('conn-to-node').value;
            const fromPort = parseInt(document.getElementById('conn-from-port').value || 0);
            const toPort = parseInt(document.getElementById('conn-to-port').value || 0);
            const threshold = parseFloat(document.getElementById('conn-threshold').value || 0);
            const connType = document.getElementById('conn-type').value;
            const label = document.getElementById('conn-label').value;

            // Validation
            if (!fromNode || !toNode) {
                alert('Please select both source and target nodes');
                return;
            }

            if (fromNode === toNode) {
                alert('Cannot connect a node to itself directly. Use feedback loop type for self-connections.');
                return;
            }

            // Initialize connections array if needed
            if (!window.canvasConnections) window.canvasConnections = [];

            // Create connection object
            const connection = {
                from: fromNode,
                to: toNode,
                fromPort: fromPort,
                toPort: toPort,
                threshold: threshold,
                type: connType,
                label: label,
                id: 'conn-' + Date.now()
            };

            window.canvasConnections.push(connection);

            // Redraw canvas to show new connection
            if (window.redrawCanvas) redrawCanvas();

            // Close popup
            document.getElementById('connection-builder-popup').remove();

            // Show success notification
            const successMsg = document.createElement('div');
            successMsg.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: linear-gradient(135deg, #10B981, #059669);
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 10002;
            `;
            successMsg.innerHTML = `‚úì Connection created: ${window.canvasNodes.get(fromNode).type} ‚Üí ${window.canvasNodes.get(toNode).type}`;
            document.body.appendChild(successMsg);
            setTimeout(() => successMsg.remove(), 3000);
        }

        // Edge drawing mode variables
        let edgeDrawMode = false;
        let edgeStartNode = null;

        function toggleEdgeMode() {
            // Simplified - just changes cursor to indicate you can drag from ports
            edgeDrawMode = !edgeDrawMode;
            const btn = document.getElementById('edge-tool-btn');
            const canvas = document.getElementById('connection-canvas');

            if (edgeDrawMode) {
                btn.style.background = 'linear-gradient(135deg, #10B981, #059669)';
                btn.innerHTML = '‚úì Drawing Mode - Drag from ports';
                if (canvas) canvas.style.cursor = 'crosshair';
            } else {
                btn.style.background = 'linear-gradient(135deg, #3B82F6, #6366F1)';
                btn.innerHTML = 'üîó Draw Edge Mode';
                if (canvas) canvas.style.cursor = 'default';
            }
        }

        function clearAllConnections() {
            if (confirm('Clear all connections?')) {
                window.canvasConnections = [];
                redrawCanvas();
            }
        }

        // Store selected port info
        let selectedStartPort = null;

        function showPortSelector(node, nodeId, isStartNode, event) {
            // Remove any existing popup
            const existingPopup = document.getElementById('port-selector-popup');
            if (existingPopup) existingPopup.remove();

            // Stop event propagation to prevent immediate closure
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }

            const popup = document.createElement('div');
            popup.id = 'port-selector-popup';
            popup.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border: 2px solid #6366F1;
                border-radius: 12px;
                padding: 20px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
                z-index: 10000;
                min-width: 300px;
            `;

            let content = `
                <h3 style="margin: 0 0 15px 0; color: #6366F1; font-size: 18px;">
                    Select ${isStartNode ? 'Output' : 'Input'} Port
                </h3>
                <p style="margin: 0 0 15px 0; color: #666;">
                    Node: <strong>${node.type || 'Node'}</strong>
                </p>
                <div style="display: flex; flex-direction: column; gap: 8px;">
            `;

            const ports = isStartNode ? node.outputs : node.inputs;
            const portType = isStartNode ? 'Output' : 'Input';

            ports.forEach((port, index) => {
                content += `
                    <button onclick="selectPort('${nodeId}', ${index}, ${isStartNode})"
                            style="padding: 10px; background: linear-gradient(135deg, #6366F1, #8B5CF6);
                                   color: white; border: none; border-radius: 6px; cursor: pointer;
                                   font-size: 14px; transition: all 0.3s;">
                        ${portType} Port ${index + 1}
                    </button>
                `;
            });

            // Add single port button if only one port
            if (ports.length === 1) {
                content = `
                    <h3 style="margin: 0 0 15px 0; color: #6366F1; font-size: 18px;">
                        Confirm Connection
                    </h3>
                    <p style="margin: 0 0 15px 0; color: #666;">
                        Node: <strong>${node.type || 'Node'}</strong><br>
                        Using ${portType} Port 1 (only port available)
                    </p>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="selectPort('${nodeId}', 0, ${isStartNode})"
                                style="flex: 1; padding: 10px; background: linear-gradient(135deg, #10B981, #059669);
                                       color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Confirm
                        </button>
                        <button onclick="cancelPortSelection()"
                                style="flex: 1; padding: 10px; background: #EF4444;
                                       color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                `;
            } else {
                content += `
                    <button onclick="cancelPortSelection()"
                            style="margin-top: 10px; padding: 10px; background: #EF4444;
                                   color: white; border: none; border-radius: 6px; cursor: pointer;">
                        Cancel
                    </button>
                `;
            }

            content += `</div>`;
            popup.innerHTML = content;
            document.body.appendChild(popup);
        }

        window.selectPort = function(nodeId, portIndex, isStartNode) {
            const popup = document.getElementById('port-selector-popup');
            if (popup) popup.remove();

            if (isStartNode) {
                // Selecting output port of start node
                edgeStartNode = nodeId;
                selectedStartPort = portIndex;

                const node = window.canvasNodes.get(nodeId);
                const btn = document.getElementById('edge-tool-btn');
                btn.innerHTML = `‚úì Selected: ${node.type} Port ${portIndex + 1} - Click target`;
                btn.style.background = 'linear-gradient(135deg, #F59E0B, #D97706)';
            } else {
                // Show threshold input popup before creating connection
                const popup = document.createElement('div');
                popup.id = 'threshold-input-popup';
                popup.style.cssText = `
                    position: fixed;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    background: white;
                    border: 2px solid #6366F1;
                    border-radius: 12px;
                    padding: 20px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
                    z-index: 10001;
                    min-width: 350px;
                `;

                const fromNode = window.canvasNodes.get(edgeStartNode);
                const toNode = window.canvasNodes.get(nodeId);

                popup.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #6366F1; font-size: 18px;">
                        Set Connection Threshold
                    </h3>
                    <p style="margin: 0 0 10px 0; color: #666;">
                        From: <strong>${fromNode ? fromNode.type : 'Node'} (Port ${(selectedStartPort || 0) + 1})</strong><br>
                        To: <strong>${toNode ? toNode.type : 'Node'} (Port ${portIndex + 1})</strong>
                    </p>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #333;">Threshold Value:</label>
                        <input type="number" id="new-threshold-value" value="0" step="0.1"
                               style="width: 100%; padding: 8px; border: 1px solid #6366F1; border-radius: 6px;">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="
                            const threshold = parseFloat(document.getElementById('new-threshold-value').value) || 0;
                            window.canvasConnections.push({
                                from: '${edgeStartNode}',
                                to: '${nodeId}',
                                fromPort: ${selectedStartPort || 0},
                                toPort: ${portIndex},
                                threshold: threshold
                            });
                            edgeStartNode = null;
                            selectedStartPort = null;
                            const btn = document.getElementById('edge-tool-btn');
                            btn.innerHTML = '‚úì Edge Created! Click for new edge';
                            btn.style.background = 'linear-gradient(135deg, #10B981, #059669)';
                            redrawCanvas();
                            this.parentElement.parentElement.remove();
                        " style="flex: 1; padding: 10px; background: linear-gradient(135deg, #10B981, #059669);
                               color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Create Connection
                        </button>
                        <button onclick="
                            edgeStartNode = null;
                            selectedStartPort = null;
                            const btn = document.getElementById('edge-tool-btn');
                            btn.innerHTML = 'üîó Draw Edge Mode';
                            btn.style.background = 'linear-gradient(135deg, #3B82F6, #6366F1)';
                            this.parentElement.parentElement.remove();
                        " style="flex: 1; padding: 10px; background: #EF4444;
                               color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                `;
                document.body.appendChild(popup);

                // Focus the threshold input
                setTimeout(() => {
                    const input = document.getElementById('new-threshold-value');
                    if (input) input.focus();
                }, 100);
            }
        };

        window.cancelPortSelection = function() {
            const popup = document.getElementById('port-selector-popup');
            if (popup) popup.remove();

            // Reset if canceling start node selection
            if (!selectedStartPort && !edgeStartNode) {
                const btn = document.getElementById('edge-tool-btn');
                btn.innerHTML = 'üîó Draw Edge Mode';
            }
        };

        function handleEdgeModeClick(node, event) {
            if (!edgeDrawMode) return false;
            if (!node) return false;

            // Make sure we have the node object
            const nodeId = node.id;

            if (!edgeStartNode) {
                // First click - show port selector for output ports
                showPortSelector(node, nodeId, true, event);
                return true;
            } else if (edgeStartNode !== nodeId) {
                // Second click - show port selector for input ports
                showPortSelector(node, nodeId, false, event);
                return true;
            }

            return false;
        }

        function initializeDragAndDrop() {
            const paletteItems = document.querySelectorAll('.palette-gate');
            const canvas = document.getElementById('connection-canvas');

            paletteItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('gate-type', item.dataset.gate);
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                });
            });

            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                const gateType = e.dataTransfer.getData('gate-type');
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                addGateToCanvas(gateType, x, y);
            });
        }

        function initializeConnectionCanvas(nodeId) {
            const canvas = document.getElementById('connection-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Initialize canvas nodes and connections - sync with tree builder
            if (!window.canvasNodes) window.canvasNodes = new Map();
            if (!window.canvasConnections) window.canvasConnections = [];

            // Sync canvas nodes with tree builder nodes
            if (window.treeBuilder && window.treeBuilder.nodes) {
                window.treeBuilder.nodes.forEach((node, nodeId) => {
                    if (!window.canvasNodes.has(nodeId)) {
                        // Create canvas representation of tree node
                        window.canvasNodes.set(nodeId, {
                            id: nodeId,
                            type: node.nodeType || 'decision',
                            x: node.x || 100,
                            y: node.y || 100,
                            inputs: [{ x: (node.x || 100) - 40, y: node.y || 100 }],
                            outputs: Array(node.branchCount || 2).fill(null).map((_, i) => ({
                                x: (node.x || 100) + 40,
                                y: (node.y || 100) - 10 + (i * 20),
                                value: 0
                            })),
                            treeNode: node // Reference to actual tree node
                        });
                    }
                });
            }

            // Setup mouse tracking - store in window for global access
            window.canvasState = {
                isDragging: false,
                isConnecting: false,
                draggedNode: null,
                connectionStart: null,
                mousePos: { x: 0, y: 0 },
                freeDrawMode: false,
                freeFormEdges: []
            };

            // Draw function - make it globally accessible
            window.canvasDraw = function draw() {
                // Get state variables
                const { isDragging, isConnecting, draggedNode, connectionStart, mousePos } = window.canvasState;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                ctx.strokeStyle = '#E5E7EB';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 20) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                }
                for (let y = 0; y < canvas.height; y += 20) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                }
                ctx.stroke();

                // Draw connections FIRST (so they appear behind nodes)
                ctx.strokeStyle = '#6366F1';
                ctx.lineWidth = 2;
                window.canvasConnections.forEach((conn, index) => {
                    const fromNode = window.canvasNodes.get(conn.from);
                    const toNode = window.canvasNodes.get(conn.to);
                    if (fromNode && toNode) {
                        ctx.beginPath();
                        const fromPort = fromNode.outputs[conn.fromPort] || { x: fromNode.x + 40, y: fromNode.y };
                        const toPort = toNode.inputs[conn.toPort] || { x: toNode.x - 40, y: toNode.y };

                        // Draw bezier curve
                        const cp1x = fromPort.x + 50;
                        const cp2x = toPort.x - 50;
                        ctx.moveTo(fromPort.x, fromPort.y);
                        ctx.bezierCurveTo(cp1x, fromPort.y, cp2x, toPort.y, toPort.x, toPort.y);
                        ctx.stroke();

                        // Calculate midpoint on the bezier curve for label placement
                        const t = 0.5; // midpoint parameter
                        const midX = Math.pow(1-t, 3) * fromPort.x +
                                    3 * Math.pow(1-t, 2) * t * cp1x +
                                    3 * (1-t) * Math.pow(t, 2) * cp2x +
                                    Math.pow(t, 3) * toPort.x;
                        const midY = Math.pow(1-t, 3) * fromPort.y +
                                    3 * Math.pow(1-t, 2) * t * fromPort.y +
                                    3 * (1-t) * Math.pow(t, 2) * toPort.y +
                                    Math.pow(t, 3) * toPort.y;

                        // Add threshold label
                        ctx.save();
                        ctx.fillStyle = 'white';
                        ctx.fillRect(midX - 25, midY - 10, 50, 20);
                        ctx.strokeStyle = '#6366F1';
                        ctx.strokeRect(midX - 25, midY - 10, 50, 20);

                        ctx.fillStyle = '#6366F1';
                        ctx.font = '11px system-ui, -apple-system, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Determine threshold label based on connection
                        let label = '';
                        if (conn.threshold !== undefined) {
                            label = conn.threshold;
                        } else if (conn.fromPort === 0) {
                            label = '< T';
                        } else if (conn.fromPort === 1) {
                            label = '‚â• T';
                        } else {
                            label = `Port ${conn.fromPort + 1}`;
                        }

                        ctx.fillText(label, midX, midY);
                        ctx.restore();

                        // Draw arrow
                        ctx.save();
                        ctx.translate(toPort.x, toPort.y);
                        ctx.rotate(Math.PI);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(8, -4);
                        ctx.lineTo(8, 4);
                        ctx.closePath();
                        ctx.fillStyle = '#6366F1';
                        ctx.fill();
                        ctx.restore();

                        // Make connection clickable (store for hit detection)
                        if (!window.canvasConnectionBounds) {
                            window.canvasConnectionBounds = [];
                        }
                        window.canvasConnectionBounds[index] = {
                            x: midX - 25,
                            y: midY - 10,
                            width: 50,
                            height: 20,
                            connection: conn,
                            fromNode: fromNode,
                            toNode: toNode
                        };
                    }
                });

                // Draw temporary connection while dragging
                if (isConnecting && connectionStart && mousePos) {
                    ctx.strokeStyle = '#8B5CF6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();

                    // Handle both node object and node ID
                    let startNode;
                    if (typeof connectionStart.nodeId === 'object') {
                        startNode = connectionStart.nodeId;
                    } else {
                        // Find node by ID
                        window.canvasNodes.forEach(n => {
                            if (n.id === connectionStart.nodeId) startNode = n;
                        });
                    }

                    if (startNode && startNode.outputs[connectionStart.portIndex]) {
                        const port = startNode.outputs[connectionStart.portIndex];
                        ctx.moveTo(port.x, port.y);
                        ctx.lineTo(mousePos.x, mousePos.y);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }

                // Draw temporary connection for edge mode with port selection
                if (edgeDrawMode && edgeStartNode && selectedStartPort !== null && mousePos) {
                    const startNode = window.canvasNodes.get(edgeStartNode);
                    if (startNode && startNode.outputs[selectedStartPort]) {
                        // Draw connection line
                        ctx.strokeStyle = '#F59E0B';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([8, 4]);
                        ctx.beginPath();
                        const startPort = startNode.outputs[selectedStartPort];
                        ctx.moveTo(startPort.x, startPort.y);
                        ctx.lineTo(mousePos.x, mousePos.y);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Highlight the selected start port
                        ctx.fillStyle = '#F59E0B';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(startPort.x, startPort.y, 6, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                }

                // Draw nodes
                window.canvasNodes.forEach(node => {
                    // Node shadow
                    ctx.shadowColor = 'rgba(0,0,0,0.1)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;

                    // Node body
                    const gateColors = {
                        'and': '#8B5CF6',
                        'or': '#6366F1',
                        'xor': '#EC4899',
                        'nand': '#F59E0B',
                        'nor': '#10B981',
                        'not': '#EF4444',
                        'majority': '#3B82F6',
                        'threshold': '#14B8A6',
                        'router': '#F97316',
                        'merge': '#84CC16'
                    };

                    ctx.fillStyle = gateColors[node.type] || '#6366F1';
                    ctx.fillRect(node.x - 40, node.y - 20, 80, 40);

                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;

                    // Node label
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px system-ui';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.type.toUpperCase(), node.x, node.y);

                    // Draw ports with value indicators
                    // Input ports
                    node.inputs.forEach((port, i) => {
                        const value = port.value || 0;
                        ctx.fillStyle = value > 0 ? '#10B981' : '#374151';
                        ctx.beginPath();
                        ctx.arc(port.x, port.y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Show value label
                        if (value !== 0) {
                            ctx.fillStyle = '#10B981';
                            ctx.font = '10px system-ui';
                            ctx.textAlign = 'right';
                            ctx.fillText(value.toFixed(1), port.x - 8, port.y - 8);
                        }
                    });

                    // Output ports
                    node.outputs.forEach((port, i) => {
                        const value = port.value || 0;
                        ctx.fillStyle = value > 0 ? '#F59E0B' : '#374151';
                        ctx.beginPath();
                        ctx.arc(port.x, port.y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Show value label
                        if (value !== 0) {
                            ctx.fillStyle = '#F59E0B';
                            ctx.font = '10px system-ui';
                            ctx.textAlign = 'left';
                            ctx.fillText(value.toFixed(1), port.x + 8, port.y - 8);
                        }
                    });
                });
            }

            // Mouse event handlers
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if clicking on a threshold label
                if (window.canvasConnectionBounds) {
                    for (let i = 0; i < window.canvasConnectionBounds.length; i++) {
                        const bounds = window.canvasConnectionBounds[i];
                        if (bounds &&
                            x >= bounds.x && x <= bounds.x + bounds.width &&
                            y >= bounds.y && y <= bounds.y + bounds.height) {

                            // Show threshold editing popup
                            const popup = document.createElement('div');
                            popup.style.cssText = `
                                position: fixed;
                                left: ${e.clientX + 10}px;
                                top: ${e.clientY + 10}px;
                                background: white;
                                border: 2px solid #6366F1;
                                border-radius: 8px;
                                padding: 12px;
                                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                                z-index: 9999;
                            `;
                            popup.innerHTML = `
                                <h3 style="margin: 0 0 8px 0; color: #6366F1;">Edge Threshold</h3>
                                <div style="margin-bottom: 8px;">
                                    <label>From: ${bounds.fromNode.type || 'Node'}</label><br>
                                    <label>To: ${bounds.toNode.type || 'Node'}</label>
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <label>Threshold Value:</label><br>
                                    <input type="number" id="threshold-input" value="${bounds.connection.threshold || 0}"
                                           style="width: 100%; padding: 4px; border: 1px solid #6366F1; border-radius: 4px;">
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button onclick="this.parentElement.parentElement.remove()"
                                            style="flex: 1; padding: 6px; background: #EF4444; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                        Cancel
                                    </button>
                                    <button onclick="
                                        const value = document.getElementById('threshold-input').value;
                                        window.canvasConnections[${i}].threshold = value;
                                        redrawCanvas();
                                        this.parentElement.parentElement.remove();
                                    " style="flex: 1; padding: 6px; background: #10B981; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                        Save
                                    </button>
                                </div>
                            `;
                            document.body.appendChild(popup);

                            // Stop the current event from propagating
                            e.stopPropagation();
                            e.preventDefault();

                            // Auto-close on click outside - use mousedown for next interaction
                            setTimeout(() => {
                                const removePopup = function(evt) {
                                    if (!popup.contains(evt.target)) {
                                        popup.remove();
                                        document.removeEventListener('mousedown', removePopup);
                                    }
                                };
                                document.addEventListener('mousedown', removePopup);
                            }, 10);

                            return; // Don't process other clicks
                        }
                    }
                }

                // Check if clicking on a node
                window.canvasNodes.forEach(node => {
                    if (x >= node.x - 40 && x <= node.x + 40 &&
                        y >= node.y - 20 && y <= node.y + 20) {

                        // Handle edge drawing mode with port selector
                        if (edgeDrawMode) {
                            if (handleEdgeModeClick(node, e)) {
                                return; // Handled by edge mode
                            }
                        }

                        // Check if clicking on output port for direct dragging
                        if (!edgeDrawMode) {
                            for (let i = 0; i < node.outputs.length; i++) {
                                const port = node.outputs[i];
                                const dist = Math.sqrt((x - port.x) ** 2 + (y - port.y) ** 2);
                                if (dist < 8) {
                                    window.canvasState.isConnecting = true;
                                    window.canvasState.connectionStart = { nodeId: node.id || node, portIndex: i };
                                    return;
                                }
                            }
                        }

                        // Otherwise start dragging the node (if not in edge mode)
                        if (!edgeDrawMode) {
                            window.canvasState.isDragging = true;
                            window.canvasState.draggedNode = node;
                            window.canvasState.draggedNode.dragOffset = {
                                x: x - node.x,
                                y: y - node.y
                            };
                        }
                    }
                });
            });

            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                window.canvasState.mousePos.x = e.clientX - rect.left;
                window.canvasState.mousePos.y = e.clientY - rect.top;

                if (window.canvasState.isDragging && window.canvasState.draggedNode) {
                    const draggedNode = window.canvasState.draggedNode;
                    draggedNode.x = window.canvasState.mousePos.x - draggedNode.dragOffset.x;
                    draggedNode.y = window.canvasState.mousePos.y - draggedNode.dragOffset.y;

                    // Update port positions
                    draggedNode.inputs = [{ x: draggedNode.x - 40, y: draggedNode.y }];
                    const outputCount = draggedNode.outputs.length;
                    draggedNode.outputs = [];
                    for (let i = 0; i < outputCount; i++) {
                        const portY = outputCount === 1 ? draggedNode.y : draggedNode.y - 10 + (i * 20);
                        draggedNode.outputs.push({ x: draggedNode.x + 40, y: portY });
                    }

                    window.canvasDraw();
                } else if (window.canvasState.isConnecting) {
                    window.canvasDraw();
                } else if (edgeDrawMode && edgeStartNode && selectedStartPort !== null) {
                    // Redraw to show visual feedback line following mouse
                    window.canvasDraw();
                }

                // Update cursor
                let hoveringNode = false;
                window.canvasNodes.forEach(node => {
                    if (mousePos.x >= node.x - 40 && mousePos.x <= node.x + 40 &&
                        mousePos.y >= node.y - 20 && mousePos.y <= node.y + 20) {
                        hoveringNode = true;
                    }
                });
                canvas.style.cursor = hoveringNode ? 'grab' : 'crosshair';
            });

            canvas.addEventListener('mouseup', function(e) {
                if (window.canvasState.isConnecting && window.canvasState.connectionStart) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Check if releasing on an input port
                    window.canvasNodes.forEach(targetNode => {
                        const startNodeId = typeof window.canvasState.connectionStart.nodeId === 'object' ? window.canvasState.connectionStart.nodeId.id : window.canvasState.connectionStart.nodeId;
                        if (targetNode.id !== startNodeId) {
                            targetNode.inputs.forEach((port, portIndex) => {
                                const dist = Math.sqrt((x - port.x) ** 2 + (y - port.y) ** 2);
                                if (dist < 8) {
                                    // Show threshold popup
                                    const popup = document.createElement('div');
                                    popup.style.cssText = `
                                        position: fixed;
                                        left: 50%;
                                        top: 50%;
                                        transform: translate(-50%, -50%);
                                        background: white;
                                        border: 2px solid #6366F1;
                                        border-radius: 12px;
                                        padding: 20px;
                                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
                                        z-index: 10001;
                                        min-width: 350px;
                                    `;

                                    // Find start node for display
                                    let startNode = null;
                                    window.canvasNodes.forEach(n => {
                                        if (n.id === startNodeId) startNode = n;
                                    });

                                    popup.innerHTML = `
                                        <h3 style="margin: 0 0 15px 0; color: #6366F1;">Set Connection Threshold</h3>
                                        <p style="margin: 0 0 10px 0; color: #666;">
                                            From: <strong>${startNode ? startNode.type : 'Node'} (Port ${window.canvasState.connectionStart.portIndex + 1})</strong><br>
                                            To: <strong>${targetNode.type || 'Node'} (Port ${portIndex + 1})</strong>
                                        </p>
                                        <div style="margin-bottom: 15px;">
                                            <label style="display: block; margin-bottom: 5px;">Threshold:</label>
                                            <input type="number" id="drag-threshold-value" value="0" step="0.1"
                                                   style="width: 100%; padding: 8px; border: 1px solid #6366F1; border-radius: 6px;">
                                        </div>
                                        <div style="display: flex; gap: 10px;">
                                            <button onclick="
                                                const threshold = parseFloat(document.getElementById('drag-threshold-value').value) || 0;
                                                window.canvasConnections.push({
                                                    from: '${startNodeId}',
                                                    fromPort: ${window.canvasState.connectionStart.portIndex},
                                                    to: '${targetNode.id}',
                                                    toPort: ${portIndex},
                                                    threshold: threshold
                                                });
                                                redrawCanvas();
                                                this.parentElement.parentElement.remove();
                                            " style="flex: 1; padding: 10px; background: #10B981;
                                                   color: white; border: none; border-radius: 6px; cursor: pointer;">
                                                Create
                                            </button>
                                            <button onclick="this.parentElement.parentElement.remove()"
                                                    style="flex: 1; padding: 10px; background: #EF4444;
                                                           color: white; border: none; border-radius: 6px; cursor: pointer;">
                                                Cancel
                                            </button>
                                        </div>
                                    `;
                                    document.body.appendChild(popup);
                                    setTimeout(() => {
                                        const input = document.getElementById('drag-threshold-value');
                                        if (input) input.focus();
                                    }, 100);
                                }
                            });
                        }
                    });
                }

                window.canvasState.isDragging = false;
                window.canvasState.draggedNode = null;
                window.canvasState.isConnecting = false;
                window.canvasState.connectionStart = null;
                window.canvasDraw();
            });

            // Initial draw with existing node
            drawExistingConnections(ctx, nodeId);
            window.canvasDraw();
        }

        // Comprehensive gate configuration table
        const GATE_CONFIGURATIONS = {
            'and': {
                inputPorts: 2,
                outputPorts: 1,
                truthTable: { '00': 0, '01': 0, '10': 0, '11': 1 },
                evaluate: (inputs) => inputs.every(i => Boolean(i)),
                color: '#8B5CF6',
                label: 'AND'
            },
            'or': {
                inputPorts: 2,
                outputPorts: 1,
                truthTable: { '00': 0, '01': 1, '10': 1, '11': 1 },
                evaluate: (inputs) => inputs.some(i => Boolean(i)),
                color: '#6366F1',
                label: 'OR'
            },
            'xor': {
                inputPorts: 2,
                outputPorts: 1,
                truthTable: { '00': 0, '01': 1, '10': 1, '11': 0 },
                evaluate: (inputs) => inputs.filter(i => Boolean(i)).length % 2 === 1,
                color: '#EC4899',
                label: 'XOR'
            },
            'nand': {
                inputPorts: 2,
                outputPorts: 1,
                truthTable: { '00': 1, '01': 1, '10': 1, '11': 0 },
                evaluate: (inputs) => !inputs.every(i => Boolean(i)),
                color: '#F59E0B',
                label: 'NAND'
            },
            'nor': {
                inputPorts: 2,
                outputPorts: 1,
                truthTable: { '00': 1, '01': 0, '10': 0, '11': 0 },
                evaluate: (inputs) => !inputs.some(i => Boolean(i)),
                color: '#10B981',
                label: 'NOR'
            },
            'not': {
                inputPorts: 1,
                outputPorts: 1,
                truthTable: { '0': 1, '1': 0 },
                evaluate: (inputs) => !Boolean(inputs[0]),
                color: '#EF4444',
                label: 'NOT'
            },
            'majority': {
                inputPorts: 3,
                outputPorts: 1,
                evaluate: (inputs) => inputs.filter(i => Boolean(i)).length > inputs.length / 2,
                color: '#3B82F6',
                label: 'MAJ'
            },
            'threshold': {
                inputPorts: 'variable',
                outputPorts: 'variable',
                evaluate: (inputs, params) => {
                    const sum = inputs.reduce((a, b) => Number(a) + Number(b), 0);
                    if (!params.thresholds) return 0;
                    for (let i = 0; i < params.thresholds.length; i++) {
                        if (sum < params.thresholds[i]) return i;
                    }
                    return params.thresholds.length;
                },
                color: '#14B8A6',
                label: 'THRESH'
            },
            'fuzzy': {
                inputPorts: 2,
                outputPorts: 3,
                evaluate: (inputs) => {
                    const avg = inputs.reduce((a, b) => Number(a) + Number(b), 0) / inputs.length;
                    if (avg < 0.33) return 0;
                    if (avg < 0.67) return 1;
                    return 2;
                },
                color: '#A855F7',
                label: 'FUZZY'
            },
            'router': {
                inputPorts: 1,
                outputPorts: 'variable',
                evaluate: (inputs, params) => Math.floor(Number(inputs[0])) % (params.outputs || 2),
                color: '#F97316',
                label: 'ROUTE'
            },
            'merge': {
                inputPorts: 'variable',
                outputPorts: 1,
                evaluate: (inputs) => inputs.some(i => Boolean(i)),
                color: '#84CC16',
                label: 'MERGE'
            }
        };

        // Store globally for access
        window.GATE_CONFIGURATIONS = GATE_CONFIGURATIONS;

        // Gate Evaluation Engine - processes the logic network
        class CanvasGateEvaluator {
            constructor() {
                this.evaluationOrder = [];
                this.cycleDetected = false;
            }

            // Evaluate entire network
            evaluateNetwork() {
                if (!window.canvasNodes || !window.canvasConnections) return;

                // Build evaluation order (topological sort)
                this.buildEvaluationOrder();

                // Evaluate each gate in order
                for (const nodeId of this.evaluationOrder) {
                    this.evaluateGate(nodeId);
                }

                // Trigger redraw to show updated values
                if (window.canvasDraw) window.canvasDraw();
            }

            // Evaluate a single gate
            evaluateGate(nodeId) {
                const node = window.canvasNodes.get(nodeId);
                if (!node || !node.config) return;

                // Collect input values from connections
                const inputValues = this.collectInputValues(nodeId);

                // Store input values
                node.state.inputValues = inputValues;

                // Evaluate gate logic
                const result = node.config.evaluate(inputValues, node.parameters);

                // Handle multi-output gates
                if (node.outputs.length === 1) {
                    node.state.outputValues = [result];
                    node.outputs[0].value = result;
                } else if (typeof result === 'number' && node.type === 'threshold') {
                    // Threshold gate - activate specific output
                    node.state.outputValues = new Array(node.outputs.length).fill(0);
                    if (result >= 0 && result < node.outputs.length) {
                        node.state.outputValues[result] = 1;
                        node.outputs[result].value = 1;
                    }
                } else if (node.type === 'fuzzy') {
                    // Fuzzy gate - distribute to outputs
                    node.state.outputValues = new Array(node.outputs.length).fill(0);
                    if (result >= 0 && result < node.outputs.length) {
                        node.state.outputValues[result] = 1;
                        node.outputs[result].value = 1;
                    }
                } else if (Array.isArray(result)) {
                    // Direct array output
                    node.state.outputValues = result;
                    result.forEach((val, i) => {
                        if (i < node.outputs.length) {
                            node.outputs[i].value = val;
                        }
                    });
                } else {
                    // Default single output
                    node.state.outputValues = [result];
                    if (node.outputs[0]) node.outputs[0].value = result;
                }

                node.state.lastEvaluation = Date.now();
            }

            // Collect input values from incoming connections
            collectInputValues(nodeId) {
                const node = window.canvasNodes.get(nodeId);
                if (!node) return [];

                const inputValues = new Array(node.inputs.length).fill(0);

                // Find connections targeting this node
                window.canvasConnections.forEach(conn => {
                    if (conn.to === nodeId) {
                        const sourceNode = window.canvasNodes.get(conn.from);
                        if (sourceNode && sourceNode.outputs[conn.fromPort]) {
                            const value = sourceNode.outputs[conn.fromPort].value || 0;

                            // Apply threshold if specified
                            let processedValue = value;
                            if (conn.threshold !== undefined && conn.threshold !== null) {
                                processedValue = value >= conn.threshold ? 1 : 0;
                            }

                            // Set input value
                            if (conn.toPort < inputValues.length) {
                                inputValues[conn.toPort] = processedValue;
                                node.inputs[conn.toPort].value = processedValue;
                            }
                        }
                    }
                });

                return inputValues;
            }

            // Build topological evaluation order
            buildEvaluationOrder() {
                const visited = new Set();
                const stack = [];
                const inProgress = new Set();
                this.cycleDetected = false;

                // DFS to build topological order
                const visit = (nodeId) => {
                    if (visited.has(nodeId)) return;
                    if (inProgress.has(nodeId)) {
                        this.cycleDetected = true;
                        return;
                    }

                    inProgress.add(nodeId);

                    // Visit dependencies first
                    window.canvasConnections.forEach(conn => {
                        if (conn.to === nodeId) {
                            visit(conn.from);
                        }
                    });

                    inProgress.delete(nodeId);
                    visited.add(nodeId);
                    stack.push(nodeId);
                };

                // Visit all nodes
                window.canvasNodes.forEach((node, nodeId) => {
                    visit(nodeId);
                });

                this.evaluationOrder = stack;
            }

            // Set input value for testing
            setInputValue(nodeId, portIndex, value) {
                const node = window.canvasNodes.get(nodeId);
                if (node && node.inputs[portIndex]) {
                    node.inputs[portIndex].value = value;
                    node.state.inputValues[portIndex] = value;
                    this.evaluateNetwork();
                }
            }

            // Get output value
            getOutputValue(nodeId, portIndex = 0) {
                const node = window.canvasNodes.get(nodeId);
                if (node && node.outputs[portIndex]) {
                    return node.outputs[portIndex].value;
                }
                return 0;
            }
        }

        // Create global evaluator instance
        window.canvasGateEvaluator = new CanvasGateEvaluator();

        function addGateToCanvas(gateType, x, y) {
            // Create a new gate node at this position
            if (!window.canvasNodes) {
                window.canvasNodes = new Map();
            }
            const nodeId = 'canvas-node-' + Date.now();

            // Get gate configuration
            const config = GATE_CONFIGURATIONS[gateType] || {
                inputPorts: 2,
                outputPorts: 1,
                color: '#6366F1',
                label: gateType.toUpperCase(),
                evaluate: (inputs) => false
            };

            // Determine port counts
            let inputCount = config.inputPorts === 'variable' ? 2 : config.inputPorts;
            let outputCount = config.outputPorts === 'variable' ? 2 : config.outputPorts;

            // Create input port positions
            const inputs = [];
            for (let i = 0; i < inputCount; i++) {
                const portY = inputCount === 1 ? y : y - (inputCount - 1) * 10 + i * 20;
                inputs.push({
                    x: x - 40,
                    y: portY,
                    value: 0,
                    connected: false
                });
            }

            // Create output port positions
            const outputs = [];
            for (let i = 0; i < outputCount; i++) {
                const portY = outputCount === 1 ? y : y - (outputCount - 1) * 10 + i * 20;
                outputs.push({
                    x: x + 40,
                    y: portY,
                    value: 0,
                    connected: false
                });
            }

            // Store complete node data
            const nodeData = {
                id: nodeId,
                type: gateType,
                config: config,
                x: x,
                y: y,
                width: 80,
                height: 40,
                inputs: inputs,
                outputs: outputs,
                parameters: {
                    thresholds: gateType === 'threshold' ? [-5, 0, 5] : null,
                    outputs: gateType === 'router' ? 4 : null
                },
                state: {
                    inputValues: new Array(inputCount).fill(0),
                    outputValues: new Array(outputCount).fill(0),
                    lastEvaluation: null
                }
            };

            window.canvasNodes.set(nodeId, nodeData);

            // Initialize port connections tracking
            if (!window.portConnections) {
                window.portConnections = new Map();
            }

            // Draw the gate on canvas
            const canvas = document.getElementById('connection-canvas');
            const ctx = canvas.getContext('2d');

            // Gate colors based on type
            const gateColors = {
                'and': '#8B5CF6',
                'or': '#6366F1',
                'xor': '#EC4899',
                'nand': '#F59E0B',
                'nor': '#10B981',
                'not': '#EF4444',
                'majority': '#3B82F6',
                'threshold': '#14B8A6',
                'fuzzy_and': '#A855F7',
                'fuzzy_or': '#0EA5E9',
                'router': '#F97316',
                'merge': '#84CC16'
            };

            // Draw gate box with shadow
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fillStyle = gateColors[gateType] || '#8B5CF6';
            ctx.fillRect(x - 40, y - 20, 80, 40);

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Draw text label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(gateType.toUpperCase(), x, y);

            // Draw input/output ports
            ctx.fillStyle = '#374151';
            // Input port on left
            ctx.beginPath();
            ctx.arc(x - 40, y, 4, 0, 2 * Math.PI);
            ctx.fill();
            // Output ports on right
            const outputCount = gateType === 'merge' ? 1 : 2;
            for (let i = 0; i < outputCount; i++) {
                const portY = outputCount === 1 ? y : y - 10 + (i * 20);
                ctx.beginPath();
                ctx.arc(x + 40, portY, 4, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Store port positions
            nodeData.inputs = [{ x: x - 40, y: y }];
            nodeData.outputs = [];
            for (let i = 0; i < outputCount; i++) {
                const portY = outputCount === 1 ? y : y - 10 + (i * 20);
                nodeData.outputs.push({ x: x + 40, y: portY, label: i === 0 ? 'False' : 'True' });
            }

            // Make node draggable
            enableNodeDragging(canvas, nodeData);

            return nodeId;
        }

        function drawExistingConnections(ctx, nodeId) {
            // Draw existing node connections on the canvas
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            const canvas = ctx.canvas;
            const centerX = canvas.width / 2;
            const centerY = 100;

            // Draw the main node
            ctx.fillStyle = '#6366F1';
            ctx.fillRect(centerX - 50, centerY - 25, 100, 50);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.question || 'Node', centerX, centerY);

            // Draw child connections
            if (node.childIds && node.childIds.length > 0) {
                const spacing = 150;
                const startX = centerX - (spacing * (node.childIds.length - 1) / 2);

                node.childIds.forEach((childId, index) => {
                    if (!childId) return;

                    const childNode = treeBuilder.nodes.get(childId);
                    if (!childNode) return;

                    const childX = startX + (index * spacing);
                    const childY = centerY + 100;

                    // Draw connection line
                    ctx.strokeStyle = '#94A3B8';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 25);
                    ctx.lineTo(childX, childY - 25);
                    ctx.stroke();

                    // Draw branch label
                    if (node.branchLabels && node.branchLabels[index]) {
                        ctx.fillStyle = '#64748B';
                        ctx.font = '12px system-ui';
                        const midX = (centerX + childX) / 2;
                        const midY = (centerY + 25 + childY - 25) / 2;
                        ctx.fillText(node.branchLabels[index], midX, midY - 10);
                    }

                    // Draw child node
                    ctx.fillStyle = childNode.nodeType === 'logic_gate' ? '#8B5CF6' : '#0EA5E9';
                    ctx.fillRect(childX - 50, childY - 25, 100, 50);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText(childNode.question || 'Child', childX, childY);

                    // Recursively draw grandchildren (limited depth)
                    if (childNode.childIds && childNode.childIds.some(id => id)) {
                        ctx.fillStyle = '#E2E8F0';
                        ctx.font = '10px system-ui';
                        ctx.fillText('...', childX, childY + 40);
                    }
                });
            }

            // Draw parent connections if looking backward
            const parents = findNodeParents(nodeId);
            if (parents.length > 0) {
                const parentY = centerY - 100;
                const parentSpacing = 150;
                const parentStartX = centerX - (parentSpacing * (parents.length - 1) / 2);

                parents.forEach((parent, index) => {
                    const parentX = parentStartX + (index * parentSpacing);

                    // Draw connection line
                    ctx.strokeStyle = '#CBD5E1';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(parentX, parentY + 25);
                    ctx.lineTo(centerX, centerY - 25);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw parent node
                    ctx.fillStyle = '#94A3B8';
                    ctx.fillRect(parentX - 40, parentY - 20, 80, 40);
                    ctx.fillStyle = 'white';
                    ctx.font = '11px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText('Parent', parentX, parentY);
                });
            }
        }

        function enableNodeDragging(canvas, nodeData) {
            // Add mouse event listeners for dragging
            if (!window.canvasDragHandlers) {
                let isDragging = false;
                let draggedNode = null;
                let dragOffset = { x: 0, y: 0 };

                canvas.addEventListener('mousedown', function(e) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Check if clicking on a node
                    window.canvasNodes.forEach(node => {
                        if (x >= node.x - 40 && x <= node.x + 40 &&
                            y >= node.y - 20 && y <= node.y + 20) {
                            isDragging = true;
                            draggedNode = node;
                            dragOffset.x = x - node.x;
                            dragOffset.y = y - node.y;
                            canvas.style.cursor = 'grabbing';
                        }
                    });
                });

                canvas.addEventListener('mousemove', function(e) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (isDragging && draggedNode) {
                        // Update node position
                        draggedNode.x = x - dragOffset.x;
                        draggedNode.y = y - dragOffset.y;

                        // Update port positions to follow the node
                        draggedNode.inputs = [{ x: draggedNode.x - 40, y: draggedNode.y }];
                        const outputCount = draggedNode.outputs.length;
                        draggedNode.outputs = [];
                        for (let i = 0; i < outputCount; i++) {
                            const portY = outputCount === 1 ? draggedNode.y : draggedNode.y - 10 + (i * 20);
                            draggedNode.outputs.push({ x: draggedNode.x + 40, y: portY });
                        }

                        // Redraw canvas
                        redrawCanvas();
                    } else {
                        // Check if hovering over a node
                        let hoveringNode = false;
                        window.canvasNodes.forEach(node => {
                            if (x >= node.x - 40 && x <= node.x + 40 &&
                                y >= node.y - 20 && y <= node.y + 20) {
                                hoveringNode = true;
                            }
                        });
                        canvas.style.cursor = hoveringNode ? 'grab' : 'crosshair';
                    }
                });

                canvas.addEventListener('mouseup', function() {
                    isDragging = false;
                    draggedNode = null;
                    canvas.style.cursor = 'crosshair';
                });

                window.canvasDragHandlers = true;
            }
        }

        function redrawCanvas() {
            // If we have the global draw function, use it
            if (window.canvasDraw) {
                window.canvasDraw();
                return;
            }
            const canvas = document.getElementById('connection-canvas');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#E5E7EB';
            ctx.lineWidth = 0.5;
            for (let x = 0; x < canvas.width; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Redraw all nodes
            if (window.canvasNodes) {
                window.canvasNodes.forEach(node => {
                    // Draw node
                    const gateColors = {
                        'and': '#8B5CF6',
                        'or': '#6366F1',
                        'xor': '#EC4899',
                        'nand': '#F59E0B',
                        'nor': '#10B981',
                        'not': '#EF4444',
                        'majority': '#3B82F6',
                        'threshold': '#14B8A6'
                    };

                    ctx.fillStyle = gateColors[node.type] || '#8B5CF6';
                    ctx.fillRect(node.x - 40, node.y - 20, 80, 40);

                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px system-ui';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.type.toUpperCase(), node.x, node.y);

                    // Draw ports
                    ctx.fillStyle = '#374151';
                    node.inputs.forEach(port => {
                        ctx.beginPath();
                        ctx.arc(port.x, port.y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                    node.outputs.forEach(port => {
                        ctx.beginPath();
                        ctx.arc(port.x, port.y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });
            }

            // Draw connections
            if (window.canvasConnections) {
                ctx.strokeStyle = '#6366F1';
                ctx.lineWidth = 2;
                window.canvasConnections.forEach(conn => {
                    ctx.beginPath();
                    ctx.moveTo(conn.from.x, conn.from.y);
                    ctx.lineTo(conn.to.x, conn.to.y);
                    ctx.stroke();
                });
            }
        }

        function updateIntegrationStatus(status) {
            const indicator = document.getElementById('integrationStatus');
            if (!indicator) return;

            const messages = {
                'ready': '‚úÖ Advanced Logic Ready',
                'loading': '‚è≥ Loading Advanced Logic...',
                'error': '‚ùå Integration Error'
            };

            indicator.textContent = messages[status] || 'Unknown Status';

            // Update color based on status
            if (status === 'ready') {
                indicator.style.color = '#10B981';
            } else if (status === 'error') {
                indicator.style.color = '#EF4444';
            } else {
                indicator.style.color = '#666';
            }
        }
        window.onNodeSelected = function(node) {
            if (!window.AdvancedTreeLogic.graph) return;
            const advancedNode = window.AdvancedTreeLogic.graph.nodes.get(node.id);
            if (advancedNode) {
                window.AdvancedTreeLogic.currentNode = advancedNode;
                const display = document.getElementById('nodeConfigDisplay');
                display.innerHTML = `
                    <div style="font-size: 14px; color: #0039A6; font-weight: 600; margin-bottom: 8px;">
                        ${advancedNode.name}
                    </div>
                    <div style="font-size: 12px; color: #666;">
                        Type: ${advancedNode.nodeType}<br>
                        Logic: ${advancedNode.logicType}<br>
                        Branches: ${advancedNode.branchCount}
                    </div>
                `;
                document.getElementById('branchCount').value = advancedNode.branchCount;
                updateBranchCount(advancedNode.branchCount);
            }
        };
        window.evaluateWithAdvancedLogic = function(node, inputs) {
            if (!window.AdvancedTreeLogic.graph) {
                return node.evaluate ? node.evaluate() : null;
            }

            const advancedNode = window.AdvancedTreeLogic.graph.nodes.get(node.id);
            if (!advancedNode) {
                // If not an advanced node, check if node has gate type
                if (node.gateType || node.logicType) {
                    const gateType = node.gateType || node.logicType;

                    // Use fuzzy evaluator for fuzzy gates
                    if (gateType.startsWith('fuzzy_') && window.AdvancedTreeLogic.fuzzyEvaluator) {
                        const result = window.AdvancedTreeLogic.fuzzyEvaluator.evaluate(gateType, inputs, node.metadata || {});
                        return result;
                    }

                    // Use standard gate evaluator for logic gates
                    if (window.AdvancedTreeLogic.evaluator) {
                        const result = window.AdvancedTreeLogic.evaluator.evaluate(gateType, inputs, node.metadata || {});
                        return result;
                    }
                }
                return node.evaluate ? node.evaluate() : null;
            }

            // Use advanced node methods with proper evaluators
            switch (advancedNode.nodeType) {
                case 'logic_gate':
                    if (window.AdvancedTreeLogic.evaluator) {
                        return window.AdvancedTreeLogic.evaluator.evaluate(
                            advancedNode.logicType || 'and',
                            inputs,
                            advancedNode.metadata
                        );
                    }
                    return advancedNode.evaluateLogicGate(inputs);

                case 'fuzzy_gate':
                    if (window.AdvancedTreeLogic.fuzzyEvaluator) {
                        return window.AdvancedTreeLogic.fuzzyEvaluator.evaluate(
                            advancedNode.logicType || 'fuzzy_and',
                            inputs,
                            advancedNode.metadata
                        );
                    }
                    return advancedNode.evaluateFuzzyGate(inputs);

                case 'probabilistic':
                    return advancedNode.evaluateProbabilistic(inputs);

                default:
                    return advancedNode.evaluateDecision(inputs);
            }
        };
        // ============================================================================
        // Signal Flow Execution Engine
        // ============================================================================

        class SignalFlowEngine {
            constructor() {
                this.executionStack = [];
                this.executionHistory = [];
                this.loopCounters = new Map();
                this.signalValues = new Map();
                this.debugMode = false;
                this.maxLoopIterations = 100;
                this.executionPath = [];
            }

            executeFlow(startNodeId, initialInput = {}) {
                // Reset execution state
                this.executionStack = [startNodeId];
                this.executionHistory = [];
                this.loopCounters.clear();
                this.signalValues.clear();
                this.executionPath = [];

                // Set initial input
                this.signalValues.set('input', initialInput);

                const results = [];
                let iterations = 0;
                const maxIterations = 1000; // Global safety limit

                while (this.executionStack.length > 0 && iterations < maxIterations) {
                    iterations++;
                    const currentNodeId = this.executionStack.shift();

                    // Check for loops
                    if (this.detectLoop(currentNodeId)) {
                        if (this.debugMode) {
                            console.warn(`Loop detected at node ${currentNodeId}`);
                        }
                        const loopCount = this.loopCounters.get(currentNodeId) || 0;
                        if (loopCount >= this.maxLoopIterations) {
                            console.error(`Maximum loop iterations exceeded at node ${currentNodeId}`);
                            break;
                        }
                        this.loopCounters.set(currentNodeId, loopCount + 1);
                    }

                    // Execute node
                    const node = this.getNode(currentNodeId);
                    if (!node) continue;

                    const nodeResult = this.executeNode(node);
                    results.push({
                        nodeId: currentNodeId,
                        result: nodeResult,
                        timestamp: Date.now()
                    });

                    // Record execution
                    this.executionHistory.push(currentNodeId);
                    this.executionPath.push({
                        nodeId: currentNodeId,
                        input: this.signalValues.get(currentNodeId + '_input'),
                        output: nodeResult
                    });

                    // Determine next nodes based on result
                    const nextNodes = this.determineNextNodes(node, nodeResult);
                    nextNodes.forEach(nextId => {
                        if (!this.executionStack.includes(nextId)) {
                            this.executionStack.push(nextId);
                        }
                    });

                    // Handle special node types
                    if (node.nodeType === 'merge') {
                        this.handleMergeNode(node);
                    } else if (node.nodeType === 'router') {
                        this.handleRouterNode(node, nodeResult);
                    }
                }

                if (iterations >= maxIterations) {
                    console.error('Maximum global iterations exceeded');
                }

                return {
                    results: results,
                    path: this.executionPath,
                    finalValues: Object.fromEntries(this.signalValues),
                    loopCounts: Object.fromEntries(this.loopCounters)
                };
            }

            executeNode(node) {
                // Get input values
                const inputs = this.gatherInputs(node);

                // Execute based on node type
                switch (node.nodeType) {
                    case 'logic_gate':
                        return this.executeLogicGate(node, inputs);
                    case 'fuzzy_gate':
                        return this.executeFuzzyGate(node, inputs);
                    case 'threshold':
                        return this.executeThresholdGate(node, inputs);
                    case 'router':
                        return this.executeRouter(node, inputs);
                    case 'merge':
                        return this.executeMerge(node, inputs);
                    case 'process':
                        return this.executeProcess(node, inputs);
                    default:
                        return this.executeDecision(node, inputs);
                }
            }

            executeLogicGate(node, inputs) {
                const boolInputs = inputs.map(i => Boolean(i));

                switch (node.logicType) {
                    case 'and':
                        return boolInputs.every(i => i) ? 1 : 0;
                    case 'or':
                        return boolInputs.some(i => i) ? 1 : 0;
                    case 'xor':
                        return boolInputs.filter(i => i).length % 2 ? 1 : 0;
                    case 'nand':
                        return boolInputs.every(i => i) ? 0 : 1;
                    case 'nor':
                        return boolInputs.some(i => i) ? 0 : 1;
                    case 'not':
                        return boolInputs[0] ? 0 : 1;
                    case 'majority':
                        return boolInputs.filter(i => i).length > boolInputs.length / 2 ? 1 : 0;
                    default:
                        return 0;
                }
            }

            executeFuzzyGate(node, inputs) {
                const fuzzyInputs = inputs.map(i => Math.max(0, Math.min(1, Number(i) || 0)));

                switch (node.logicType) {
                    case 'fuzzy_and':
                        return Math.min(...fuzzyInputs);
                    case 'fuzzy_or':
                        return Math.max(...fuzzyInputs);
                    case 'fuzzy_not':
                        return 1 - fuzzyInputs[0];
                    default:
                        return fuzzyInputs[0] || 0;
                }
            }

            executeThresholdGate(node, inputs) {
                const value = inputs.reduce((sum, i) => sum + Number(i), 0);
                const thresholds = node.thresholds || node.parameters?.split(',').map(Number) || [0];

                for (let i = 0; i < thresholds.length; i++) {
                    if (value < thresholds[i]) return i;
                }
                return thresholds.length;
            }

            executeRouter(node, inputs) {
                const routerOutputs = node.routerOutputs || parseInt(node.parameters) || 2;
                const inputValue = Number(inputs[0]) || 0;
                return Math.abs(inputValue) % routerOutputs;
            }

            executeMerge(node, inputs) {
                // Merge combines multiple inputs into single output
                // Can use different merge strategies
                const mergeStrategy = node.mergeStrategy || 'or';

                switch (mergeStrategy) {
                    case 'and':
                        return inputs.every(i => i) ? 1 : 0;
                    case 'or':
                        return inputs.some(i => i) ? 1 : 0;
                    case 'sum':
                        return inputs.reduce((sum, i) => sum + Number(i), 0);
                    case 'average':
                        return inputs.reduce((sum, i) => sum + Number(i), 0) / inputs.length;
                    case 'max':
                        return Math.max(...inputs.map(Number));
                    case 'min':
                        return Math.min(...inputs.map(Number));
                    default:
                        return inputs.find(i => i !== null && i !== undefined) || 0;
                }
            }

            executeProcess(node, inputs) {
                // Process nodes can transform input
                const processType = node.processType || 'passthrough';
                const input = inputs[0] || 0;

                switch (processType) {
                    case 'multiply':
                        return input * (node.factor || 2);
                    case 'add':
                        return input + (node.offset || 1);
                    case 'modulo':
                        return input % (node.divisor || 10);
                    case 'clamp':
                        const min = node.min || 0;
                        const max = node.max || 1;
                        return Math.max(min, Math.min(max, input));
                    default:
                        return input;
                }
            }

            executeDecision(node, inputs) {
                // Standard decision node execution
                // Returns branch index based on evaluation
                if (node.evaluate) {
                    return node.evaluate(inputs);
                }

                // Default binary decision
                return inputs[0] ? 1 : 0;
            }

            gatherInputs(node) {
                const inputs = [];

                // Get inputs from parent nodes
                const parents = this.findNodeParents(node.id);
                parents.forEach(parent => {
                    const parentOutput = this.signalValues.get(parent.id + '_output');
                    if (parentOutput !== undefined) {
                        inputs.push(parentOutput);
                    }
                });

                // Get stored input value
                const storedInput = this.signalValues.get(node.id + '_input');
                if (storedInput !== undefined) {
                    inputs.push(storedInput);
                }

                // Store gathered inputs
                this.signalValues.set(node.id + '_input', inputs);

                return inputs;
            }

            determineNextNodes(node, result) {
                const nextNodes = [];

                if (node.childIds && Array.isArray(node.childIds)) {
                    const branchIndex = Math.min(result, node.childIds.length - 1);
                    const nextNodeId = node.childIds[branchIndex];
                    if (nextNodeId) {
                        nextNodes.push(nextNodeId);
                    }
                }

                // Handle special connections
                if (node.connectionMode === 'backward' && node.loopTarget) {
                    nextNodes.push(node.loopTarget);
                } else if (node.connectionMode === 'skip') {
                    // Skip to specified layer
                    const skipTarget = this.findSkipTarget(node);
                    if (skipTarget) nextNodes.push(skipTarget);
                }

                // Store output for next nodes
                this.signalValues.set(node.id + '_output', result);

                return nextNodes;
            }

            handleMergeNode(node) {
                // Wait for all inputs before proceeding
                const parents = this.findNodeParents(node.id);
                const allInputsReady = parents.every(parent =>
                    this.signalValues.has(parent.id + '_output')
                );

                if (!allInputsReady) {
                    // Re-queue node to wait for other inputs
                    if (!this.executionStack.includes(node.id)) {
                        this.executionStack.push(node.id);
                    }
                }
            }

            handleRouterNode(node, result) {
                // Router sends signal to specific output based on result
                const routerOutputs = node.routerOutputs || parseInt(node.parameters) || 2;
                const outputIndex = result % routerOutputs;

                // Clear other outputs
                for (let i = 0; i < routerOutputs; i++) {
                    if (i !== outputIndex) {
                        this.signalValues.set(`${node.id}_output_${i}`, null);
                    }
                }

                this.signalValues.set(`${node.id}_output_${outputIndex}`, 1);
            }

            detectLoop(nodeId) {
                // Check if node has been executed recently
                const recentHistory = this.executionHistory.slice(-10);
                return recentHistory.filter(id => id === nodeId).length > 1;
            }

            getNode(nodeId) {
                // Get node from tree builder
                if (window.treeBuilder && window.treeBuilder.nodes) {
                    return window.treeBuilder.nodes.get(nodeId);
                }
                return null;
            }

            findNodeParents(nodeId) {
                const parents = [];
                if (window.treeBuilder && window.treeBuilder.nodes) {
                    window.treeBuilder.nodes.forEach((node, id) => {
                        if (node.childIds && node.childIds.includes(nodeId)) {
                            parents.push(node);
                        }
                    });
                }
                return parents;
            }

            findSkipTarget(node) {
                // Find target node in specified layer
                const targetLayer = node.skipToLayer || node.layer + 2;
                if (window.treeBuilder && window.treeBuilder.layers) {
                    const layer = window.treeBuilder.layers[targetLayer];
                    if (layer && layer.nodes.length > 0) {
                        return layer.nodes[0].id;
                    }
                }
                return null;
            }

            setDebugMode(enabled) {
                this.debugMode = enabled;
                if (enabled) {
                    console.log('Signal Flow Engine Debug Mode Enabled');
                }
            }

            visualizeExecutionPath() {
                // Create visual representation of execution path
                const pathViz = this.executionPath.map((step, index) => ({
                    step: index + 1,
                    node: step.nodeId,
                    input: JSON.stringify(step.input),
                    output: step.output
                }));

                console.table(pathViz);
                return pathViz;
            }
        }

        // Loop Detection System
        class LoopDetector {
            constructor() {
                this.adjacencyList = new Map();
                this.visitedNodes = new Set();
                this.recursionStack = new Set();
                this.loops = [];
            }

            buildGraph(nodes) {
                this.adjacencyList.clear();

                nodes.forEach((node, nodeId) => {
                    const edges = [];
                    if (node.childIds) {
                        node.childIds.forEach(childId => {
                            if (childId) edges.push(childId);
                        });
                    }

                    // Check for backward connections
                    if (node.connectionMode === 'backward' && node.loopTarget) {
                        edges.push(node.loopTarget);
                    }

                    this.adjacencyList.set(nodeId, edges);
                });
            }

            detectAllLoops() {
                this.loops = [];
                this.visitedNodes.clear();
                this.recursionStack.clear();

                for (let nodeId of this.adjacencyList.keys()) {
                    if (!this.visitedNodes.has(nodeId)) {
                        this.detectLoopsDFS(nodeId, []);
                    }
                }

                return this.loops;
            }

            detectLoopsDFS(nodeId, path) {
                this.visitedNodes.add(nodeId);
                this.recursionStack.add(nodeId);
                path.push(nodeId);

                const neighbors = this.adjacencyList.get(nodeId) || [];
                for (let neighbor of neighbors) {
                    if (this.recursionStack.has(neighbor)) {
                        // Found a loop
                        const loopStartIndex = path.indexOf(neighbor);
                        const loop = path.slice(loopStartIndex);
                        loop.push(neighbor); // Complete the loop
                        this.loops.push({
                            nodes: loop,
                            startNode: neighbor,
                            length: loop.length - 1
                        });
                    } else if (!this.visitedNodes.has(neighbor)) {
                        this.detectLoopsDFS(neighbor, [...path]);
                    }
                }

                this.recursionStack.delete(nodeId);
            }

            analyzeLoopComplexity() {
                const analysis = {
                    totalLoops: this.loops.length,
                    simpleLoops: 0,
                    nestedLoops: 0,
                    maxLoopLength: 0,
                    loopNodes: new Set()
                };

                this.loops.forEach(loop => {
                    if (loop.length <= 2) {
                        analysis.simpleLoops++;
                    } else {
                        analysis.nestedLoops++;
                    }

                    analysis.maxLoopLength = Math.max(analysis.maxLoopLength, loop.length);
                    loop.nodes.forEach(node => analysis.loopNodes.add(node));
                });

                return analysis;
            }

            visualizeLoops() {
                if (this.loops.length === 0) {
                    console.log('No loops detected in the graph');
                    return;
                }

                console.log(`Found ${this.loops.length} loops:`);
                this.loops.forEach((loop, index) => {
                    console.log(`Loop ${index + 1}:`);
                    console.log(`  Path: ${loop.nodes.join(' ‚Üí ')}`);
                    console.log(`  Start: ${loop.startNode}`);
                    console.log(`  Length: ${loop.length}`);
                });
            }
        }

        // Initialize execution engine
        window.signalFlowEngine = new SignalFlowEngine();
        window.loopDetector = new LoopDetector();

        // Add execution controls
        function executeSignalFlow() {
            if (!window.treeBuilder || !window.treeBuilder.nodes) {
                console.error('No tree structure to execute');
                return;
            }

            // Find start node (first node in layer 0)
            let startNode = null;
            window.treeBuilder.nodes.forEach((node, id) => {
                if (node.layer === 0 || node.isStart) {
                    startNode = id;
                }
            });

            if (!startNode) {
                // Use first node as start
                startNode = window.treeBuilder.nodes.keys().next().value;
            }

            // Execute flow
            const result = window.signalFlowEngine.executeFlow(startNode, { value: 1 });

            // Display results
            console.log('Execution Results:', result);
            window.signalFlowEngine.visualizeExecutionPath();

            // Check for loops
            window.loopDetector.buildGraph(window.treeBuilder.nodes);
            const loops = window.loopDetector.detectAllLoops();
            if (loops.length > 0) {
                console.warn('Loops detected:');
                window.loopDetector.visualizeLoops();
            }

            return result;
        }

        // Add debug controls
        function enableSignalFlowDebug() {
            window.signalFlowEngine.setDebugMode(true);
            console.log('Signal Flow Debug Mode Enabled');
        }

        // Export for use
        window.executeSignalFlow = executeSignalFlow;
        window.enableSignalFlowDebug = enableSignalFlowDebug;

        // Canvas interaction and modal functions
        let currentEditingNode = null;
        let canvasContext = null;
        let canvasNodes = new Map();

        function initializeCanvas() {
            const canvas = document.getElementById('tree-canvas');
            if (!canvas) return;

            canvasContext = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth || 800;
            canvas.height = canvas.offsetHeight || 600;

            console.log('Canvas initialized:', canvas.width + 'x' + canvas.height);

            // Add click handler for nodes
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasHover);

            // Initialize canvas renderer
            if (window.AdvancedTreeLogic && window.AdvancedTreeLogic.graph) {
                renderCanvasNodes();
            }
        }

        function handleCanvasClick(event) {
            const rect = event.target.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            console.log('Canvas clicked at:', x, y);
            console.log('Total canvas nodes:', canvasNodes.size);

            // Check if click is on a node
            for (const [nodeId, nodeData] of canvasNodes) {
                if (isPointInNode(x, y, nodeData)) {
                    console.log('Node clicked:', nodeId);
                    openNodeConfigModal(nodeId);
                    break;
                }
            }
        }

        function handleCanvasHover(event) {
            const rect = event.target.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            let hoveringNode = false;
            for (const [nodeId, nodeData] of canvasNodes) {
                if (isPointInNode(x, y, nodeData)) {
                    event.target.style.cursor = 'pointer';
                    hoveringNode = true;
                    break;
                }
            }

            if (!hoveringNode) {
                event.target.style.cursor = 'grab';
            }
        }

        function isPointInNode(x, y, nodeData) {
            if (!nodeData) return false;

            // Use rect-based hit detection if available
            if (nodeData.rect) {
                const rect = nodeData.rect;
                return x >= rect.x && x <= rect.x + rect.width &&
                       y >= rect.y && y <= rect.y + rect.height;
            }


        }

        function renderCanvasNodes() {
            if (!canvasContext) {
                console.log('Canvas context not initialized, initializing now');
                initializeCanvas();
                if (!canvasContext) return;
            }

            const canvas = canvasContext.canvas;

            // First pass: Calculate and store all node positions
            const tempNodes = new Map();
            if (treeBuilder && treeBuilder.layers) {
                let yOffset = 100;
                treeBuilder.layers.forEach((layer, layerIndex) => {
                    const xSpacing = canvas.width / (layer.nodes.length + 1);
                    layer.nodes.forEach((node, nodeIndex) => {
                        const x = xSpacing * (nodeIndex + 1);
                        const y = yOffset;
                        tempNodes.set(node.id, { x, y, radius: 40, rect: { x: x - 40, y: y - 40, width: 80, height: 80 }, node });
                    });
                    yOffset += 150;
                });
            }

            // Update global canvasNodes
            canvasNodes.clear();
            tempNodes.forEach((value, key) => {
                canvasNodes.set(key, value);
            });

            console.log('Canvas nodes populated:', canvasNodes.size);

            // Clear canvas
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);

            // Render connections
            if (treeBuilder && treeBuilder.layers) {
                canvasContext.strokeStyle = '#D1D5DB';
                canvasContext.lineWidth = 2;

                treeBuilder.layers.forEach(layer => {
                    layer.nodes.forEach(node => {
                        if (node.children) {
                            node.children.forEach((child, index) => {
                                if (child) {
                                    const parentData = canvasNodes.get(node.id);
                                    const childData = canvasNodes.get(child.id);
                                    if (parentData && childData) {
                                        canvasContext.beginPath();
                                        canvasContext.moveTo(parentData.x, parentData.y);
                                        canvasContext.lineTo(childData.x, childData.y);
                                        canvasContext.stroke();
                                    }
                                }
                            });
                        }
                        // Legacy connections
                        if (node.left) {
                            const parentData = canvasNodes.get(node.id);
                            const childData = canvasNodes.get(node.left.id);
                            if (parentData && childData) {
                                canvasContext.beginPath();
                                canvasContext.moveTo(parentData.x, parentData.y);
                                canvasContext.lineTo(childData.x, childData.y);
                                canvasContext.stroke();
                            }
                        }
                        if (node.right) {
                            const parentData = canvasNodes.get(node.id);
                            const childData = canvasNodes.get(node.right.id);
                            if (parentData && childData) {
                                canvasContext.beginPath();
                                canvasContext.moveTo(parentData.x, parentData.y);
                                canvasContext.lineTo(childData.x, childData.y);
                                canvasContext.stroke();
                            }
                        }
                    });
                });
            }

            // Render nodes
            canvasNodes.forEach((nodeData, nodeId) => {
                drawNode(nodeData.x, nodeData.y, nodeData.node);
            });
        }

        function drawNode(x, y, node) {
            const radius = 40;

            // Set color based on node type
            let fillColor = '#8B5CF6'; // Default purple
            if (node.nodeType === 'logic_gate') fillColor = '#3B82F6'; // Blue
            if (node.nodeType === 'fuzzy_gate') fillColor = '#EC4899'; // Pink
            if (node.nodeType === 'probabilistic') fillColor = '#10B981'; // Green

            // Draw node circle
            canvasContext.beginPath();
            canvasContext.arc(x, y, radius, 0, 2 * Math.PI);
            canvasContext.fillStyle = fillColor;
            canvasContext.fill();
            canvasContext.strokeStyle = '#ffffff';
            canvasContext.lineWidth = 3;
            canvasContext.stroke();

            // Draw node text
            canvasContext.fillStyle = '#ffffff';
            canvasContext.font = '14px Inter, sans-serif';
            canvasContext.textAlign = 'center';
            canvasContext.textBaseline = 'middle';
            const displayText = node.question ?
                (node.question.length > 15 ? node.question.substring(0, 12) + '...' : node.question) :
                `Node ${node.id.substring(0, 8)}`;
            canvasContext.fillText(displayText, x, y);

            // Draw branch count indicator
            if (node.branchCount && node.branchCount > 2) {
                canvasContext.fillStyle = '#FCD34D';
                canvasContext.font = 'bold 12px Inter, sans-serif';
                canvasContext.fillText(`${node.branchCount}`, x + radius - 10, y - radius + 10);
            }
        }

        function openNodeConfigModal(nodeId) {
            console.log('Opening modal for node:', nodeId);
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) {
                console.error('Node not found:', nodeId);
                return;
            }

            currentEditingNode = node;
            window.currentConfigNodeId = nodeId;

            // Populate modal with node data
            document.getElementById('modal-node-question').value = node.question || '';
            document.getElementById('modal-node-scale-min').value = node.scaleMin || currentScaleMin;
            document.getElementById('modal-node-scale-max').value = node.scaleMax || currentScaleMax;

            const scoreInput = document.getElementById('modal-node-default-score');
            if (scoreInput) scoreInput.value = node.score || 0;

            const branchInput = document.getElementById('modal-node-branch-count');
            if (branchInput) {
                branchInput.value = node.branchCount || 2;
                updateModalBranchConfig(node.branchCount || 2);
            }

            const terminalInput = document.getElementById('modal-node-terminal');
            if (terminalInput) terminalInput.checked = node.isTerminal || false;

            // Set node type
            const nodeTypeSelect = document.getElementById('modal-node-type');
            if (nodeTypeSelect) {
                nodeTypeSelect.value = node.nodeType || 'decision';
                updateModalNodeType(node.nodeType || 'decision');
            }

            // Show modal
            const modal = document.getElementById('node-config-modal');
            if (modal) {
                modal.style.display = 'block';
                console.log('Modal shown');
            } else {
                console.error('Modal element not found');
            }
        }

        function closeNodeConfigModal() {
            document.getElementById('node-config-modal').style.display = 'none';
            currentEditingNode = null;
        }

        function applyNodeConfig() {
            if (!currentEditingNode) return;

            // Update node properties
            currentEditingNode.question = document.getElementById('modal-node-question').value;
            currentEditingNode.scaleMin = parseFloat(document.getElementById('modal-node-scale-min').value);
            currentEditingNode.scaleMax = parseFloat(document.getElementById('modal-node-scale-max').value);

            const scoreInput = document.getElementById('modal-node-default-score');
            if (scoreInput) currentEditingNode.score = parseFloat(scoreInput.value) || 0;

            const branchInput = document.getElementById('modal-node-branch-count');
            if (branchInput) {
                const branchCount = parseInt(branchInput.value) || 2;
                currentEditingNode.branchCount = branchCount;

                // Collect n-ary thresholds
                if (branchCount > 2) {
                    const thresholds = [];
                    for (let i = 0; i < branchCount - 1; i++) {
                        const thresholdInput = document.getElementById(`modal-threshold-${i}`);
                        if (thresholdInput) {
                            thresholds.push(parseFloat(thresholdInput.value) || 0);
                        }
                    }
                    currentEditingNode.thresholds = thresholds;
                }

                // Collect branch labels
                const branchLabels = [];
                for (let i = 0; i < branchCount; i++) {
                    const labelInput = document.getElementById(`modal-branch-label-${i}`);
                    if (labelInput) {
                        branchLabels.push(labelInput.value || `Branch ${i + 1}`);
                    }
                }
                if (branchLabels.length > 0) {
                    currentEditingNode.branchLabels = branchLabels;
                }
            }

            const terminalInput = document.getElementById('modal-node-terminal');
            if (terminalInput) currentEditingNode.isTerminal = terminalInput.checked;

            const nodeTypeInput = document.getElementById('modal-node-type');
            if (nodeTypeInput) currentEditingNode.nodeType = nodeTypeInput.value;

            // Apply logic gate settings if applicable
            if (currentEditingNode.nodeType === 'logic_gate') {
                const gateTypeSelect = document.getElementById('modal-gate-type');
                if (gateTypeSelect) currentEditingNode.gateType = gateTypeSelect.value;
            } else if (currentEditingNode.nodeType === 'fuzzy_logic') {
                const fuzzyOpSelect = document.getElementById('modal-fuzzy-operation');
                if (fuzzyOpSelect) currentEditingNode.fuzzyOperation = fuzzyOpSelect.value;
            } else if (currentEditingNode.nodeType === 'probabilistic') {
                const distTypeSelect = document.getElementById('modal-distribution-type');
                if (distTypeSelect) currentEditingNode.probabilityType = distTypeSelect.value;
            }

            // Update advanced logic node if exists
            if (window.AdvancedTreeLogic && window.AdvancedTreeLogic.graph) {
                const advancedNode = window.AdvancedTreeLogic.graph.nodes.get(currentEditingNode.id);
                if (advancedNode) {
                    Object.assign(advancedNode, {
                        nodeType: currentEditingNode.nodeType,
                        branchCount: currentEditingNode.branchCount,
                        thresholds: currentEditingNode.thresholds,
                        branchLabels: currentEditingNode.branchLabels,
                        gateType: currentEditingNode.gateType,
                        fuzzyOperation: currentEditingNode.fuzzyOperation,
                        probabilityType: currentEditingNode.probabilityType
                    });
                }
            }

            // Update canvas
            renderCanvasNodes();

            // Update tree builder display
            if (treeBuilder && treeBuilder.updateLayersDisplay) {
                treeBuilder.updateLayersDisplay();
            }

            // Close modal
            closeNodeConfigModal();
        }

        function switchConfigTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });

            // Remove active class from all buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.style.borderBottom = 'none';
                btn.style.color = '#6B7280';
            });

            // Show selected tab
            document.getElementById(`${tabName}-tab`).style.display = 'block';

            // Add active class to clicked button
            event.target.style.borderBottom = '3px solid #8B5CF6';
            event.target.style.color = '#8B5CF6';

            // Initialize drag handlers for palette-item elements when visual tab is shown
            if (tabName === 'visual') {
                setTimeout(() => {
                    initializeVisualTabDragHandlers();
                }, 100);
            }
        }

        function initializeVisualTabDragHandlers() {
            const paletteItems = document.querySelectorAll('.palette-item');
            const canvas = document.getElementById('visual-logic-canvas');

            if (!canvas) {
                console.warn('Visual logic canvas not found');
                return;
            }

            console.log(`Initializing drag handlers for ${paletteItems.length} palette items`);

            paletteItems.forEach(item => {
                // Remove existing listeners to prevent duplicates
                const newItem = item.cloneNode(true);
                item.parentNode.replaceChild(newItem, item);
            });

            // Re-query after cloning
            const freshPaletteItems = document.querySelectorAll('.palette-item');

            freshPaletteItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('gate-type', item.dataset.gate);
                    item.classList.add('dragging');
                    console.log('Drag started:', item.dataset.gate);
                });

                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                });
            });

            // Setup canvas drop zone
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                const gateType = e.dataTransfer.getData('gate-type');
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                console.log(`Dropped ${gateType} at (${x}, ${y})`);
                addGateToVisualCanvas(gateType, x, y);
            });

            // Initialize canvas if needed
            initializeVisualCanvas();
        }

        function initializeVisualCanvas() {
            const canvas = document.getElementById('visual-logic-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Initialize storage for visual canvas nodes
            if (!window.visualCanvasNodes) window.visualCanvasNodes = [];

            // Draw initial canvas
            drawVisualCanvas();
        }

        function addGateToVisualCanvas(gateType, x, y) {
            if (!window.visualCanvasNodes) window.visualCanvasNodes = [];

            const gateNode = {
                id: `gate_${Date.now()}`,
                type: gateType,
                x: x,
                y: y,
                inputs: [],
                outputs: []
            };

            window.visualCanvasNodes.push(gateNode);
            console.log('Added gate node:', gateNode);

            drawVisualCanvas();
        }

        function drawVisualCanvas() {
            const canvas = document.getElementById('visual-logic-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#E5E7EB';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw nodes
            if (window.visualCanvasNodes) {
                window.visualCanvasNodes.forEach(node => {
                    drawGateNode(ctx, node);
                });
            }
        }

        function drawGateNode(ctx, node) {
            // Draw gate box
            ctx.fillStyle = '#8B5CF6';
            ctx.fillRect(node.x - 30, node.y - 20, 60, 40);

            // Draw gate label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.type.toUpperCase(), node.x, node.y);
        }

        function updateModalNodeType(nodeType) {
            const configDiv = document.getElementById('modal-logic-config');
            if (!configDiv) return;

            // Clear existing content
            configDiv.innerHTML = '';

            // Add configuration based on node type
            if (nodeType === 'logic_gate') {
                configDiv.innerHTML = getLogicGateConfig();
            } else if (nodeType === 'fuzzy_gate') {
                configDiv.innerHTML = getFuzzyLogicConfig();
            } else if (nodeType === 'probabilistic') {
                configDiv.innerHTML = getProbabilisticConfig();
            }
        }

        function getLogicGateConfig() {
            return `
                <div style="padding: 15px; background: #F9FAFB; border-radius: 8px;">
                    <label style="display: block; margin-bottom: 10px; color: #374151; font-weight: 600;">Gate Type:</label>
                    <select id="modal-gate-type" style="width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #D1D5DB; border-radius: 6px;">
                        <option value="and">AND - All inputs must be true</option>
                        <option value="or">OR - At least one input must be true</option>
                        <option value="not">NOT - Inverts input</option>
                        <option value="nand">NAND - NOT(AND)</option>
                        <option value="nor">NOR - NOT(OR)</option>
                        <option value="xor">XOR - Odd number of true inputs</option>
                        <option value="xnor">XNOR - Even number of true inputs</option>
                        <option value="majority">MAJORITY - More than half true</option>
                        <option value="threshold">THRESHOLD - K of N true</option>
                    </select>

                    <div id="threshold-config" style="display: none;">
                        <label style="display: block; margin-bottom: 5px; color: #6B7280;">Threshold K:</label>
                        <input type="number" id="modal-threshold-k" min="1" value="2" style="width: 100px; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">
                    </div>

                    <label style="display: flex; align-items: center; gap: 10px; margin-top: 15px;">
                        <input type="checkbox" id="modal-continuous-domain">
                        Enable Continuous Domain (0-1 values)
                    </label>
                </div>
            `;
        }

        function getFuzzyLogicConfig() {
            return `
                <div style="padding: 15px; background: #F9FAFB; border-radius: 8px;">
                    <label style="display: block; margin-bottom: 10px; color: #374151; font-weight: 600;">Fuzzy Operation:</label>
                    <select id="modal-fuzzy-op" style="width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #D1D5DB; border-radius: 6px;">
                        <optgroup label="T-norms (AND-like)">
                            <option value="fuzzy_min">Minimum - min(a,b)</option>
                            <option value="fuzzy_product">Product - a√ób</option>
                            <option value="fuzzy_lukasiewicz">Lukasiewicz - max(0, a+b-1)</option>
                        </optgroup>
                        <optgroup label="S-norms (OR-like)">
                            <option value="fuzzy_max">Maximum - max(a,b)</option>
                            <option value="fuzzy_sum">Probabilistic Sum - a+b-ab</option>
                            <option value="fuzzy_lukasiewicz_or">Lukasiewicz - min(1, a+b)</option>
                        </optgroup>
                        <optgroup label="Averaging">
                            <option value="fuzzy_average">Arithmetic Mean</option>
                            <option value="fuzzy_geometric">Geometric Mean</option>
                            <option value="fuzzy_weighted">Weighted Average</option>
                        </optgroup>
                    </select>

                    <label style="display: block; margin-bottom: 10px; color: #374151; font-weight: 600;">Membership Function:</label>
                    <select id="modal-membership" style="width: 100%; padding: 10px; border: 1px solid #D1D5DB; border-radius: 6px;">
                        <option value="triangular">Triangular</option>
                        <option value="trapezoidal">Trapezoidal</option>
                        <option value="gaussian">Gaussian</option>
                        <option value="sigmoid">Sigmoid</option>
                    </select>
                </div>
            `;
        }

        function getProbabilisticConfig() {
            return `
                <div style="padding: 15px; background: #F9FAFB; border-radius: 8px;">
                    <label style="display: block; margin-bottom: 10px; color: #374151; font-weight: 600;">Distribution:</label>
                    <select id="modal-distribution" style="width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #D1D5DB; border-radius: 6px;">
                        <optgroup label="Discrete">
                            <option value="bernoulli">Bernoulli</option>
                            <option value="binomial">Binomial</option>
                            <option value="poisson">Poisson</option>
                        </optgroup>
                        <optgroup label="Continuous">
                            <option value="gaussian">Gaussian/Normal</option>
                            <option value="uniform">Uniform</option>
                            <option value="exponential">Exponential</option>
                            <option value="beta">Beta</option>
                        </optgroup>
                    </select>

                    <div id="distribution-params">
                        <!-- Dynamic parameters based on distribution -->
                    </div>
                </div>
            `;
        }

        function updateModalBranchCount(count) {
            if (currentEditingNode) {
                currentEditingNode.branchCount = parseInt(count);
            }
        }

        // Export functions for global use
        window.openNodeConfigModal = openNodeConfigModal;
        window.closeNodeConfigModal = closeNodeConfigModal;
        window.applyNodeConfig = applyNodeConfig;
        window.switchConfigTab = switchConfigTab;
        window.updateModalNodeType = updateModalNodeType;
        window.updateModalBranchCount = updateModalBranchCount;
        window.renderCanvasNodes = renderCanvasNodes;

        // Function to update node threshold
        function updateNodeThreshold(nodeId, index, value) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            if (!node.thresholds) {
                node.thresholds = [];
            }
            node.thresholds[index] = parseFloat(value);

            // Update advanced node if exists
            if (window.AdvancedTreeLogic && window.AdvancedTreeLogic.graph) {
                const advancedNode = window.AdvancedTreeLogic.graph.nodes.get(nodeId);
                if (advancedNode) {
                    advancedNode.thresholds = node.thresholds;
                }
            }

            // Update visualization
            visualizeTree();
        }
        window.updateNodeThreshold = updateNodeThreshold;

        // Function to update branch label
        function updateBranchLabel(nodeId, index, label) {
            const node = treeBuilder.nodes.get(nodeId);
            if (!node) return;

            if (!node.branchLabels) {
                const count = node.branchCount || node.numBranches || 2;
                node.branchLabels = [];
                for (let i = 0; i < count; i++) {
                    node.branchLabels.push(`Branch ${i + 1}`);
                }
            }
            node.branchLabels[index] = label;

            // Update advanced node if exists
            if (window.AdvancedTreeLogic && window.AdvancedTreeLogic.graph) {
                const advancedNode = window.AdvancedTreeLogic.graph.nodes.get(nodeId);
                if (advancedNode) {
                    advancedNode.branchLabels = node.branchLabels;
                }
            }

            // Update visualization
            visualizeTree();
        }
        window.updateBranchLabel = updateBranchLabel;

        // Function to open connection canvas - works in both main and builder modes
        window.openConnectionCanvas = function(nodeId) {
            console.log('Opening connection canvas for node:', nodeId);

            // Check if we're in builder mode or main mode
            const builderPanel = document.getElementById('builder-panel');
            const isBuilderMode = builderPanel && builderPanel.style.display !== 'none';

            let canvas, canvasContainer, renderer;

            if (isBuilderMode) {
                // Use builder canvas
                canvasContainer = document.getElementById('builder-canvas-container');
                canvas = document.getElementById('builderCanvas');

                if (canvasContainer) {
                    canvasContainer.style.display = 'block';
                }

                // Initialize builder canvas state if needed
                if (!window.builderCanvasState) {
                    window.builderCanvasState = {
                        gates: [],
                        connections: [],
                        selectedGate: null,
                        isDragging: false,
                        isConnecting: false,
                        connectionStart: null,
                        mousePos: { x: 0, y: 0 }
                    };
                }

                // Use builder canvas state
                window.currentCanvasState = window.builderCanvasState;
            } else {
                // Use main canvas
                canvasContainer = document.getElementById('advanced-canvas-container');
                canvas = document.getElementById('advancedCanvas');

                if (canvasContainer) {
                    canvasContainer.style.display = 'block';
                    document.getElementById('tree-container').style.display = 'none';
                }

                // Use main canvas state
                window.currentCanvasState = window.canvasState;
            }

            // Initialize IEEE renderer if available
            if (typeof IEEEGateRenderer !== 'undefined' && canvas) {
                renderer = new IEEEGateRenderer(canvas);

                if (isBuilderMode) {
                    window.builderIeeeRenderer = renderer;
                } else {
                    window.ieeeRenderer = renderer;
                }

                // Initialize canvas events
                initializeCanvasEventsForElement(canvas, window.currentCanvasState);

                // Render node connections
                renderNodeConnectionsIEEE(nodeId, canvas, renderer);
            }

            // Update canvas title if available
            const node = treeBuilder.nodes.get(nodeId);
            if (node) {
                const titleId = isBuilderMode ? 'builder-canvas-title' : 'canvas-title';
                const title = document.getElementById(titleId);
                if (title) {
                    title.textContent = `Connection Canvas - ${node.question}`;
                }
            }

            // Store current node for canvas operations
            window.currentCanvasNodeId = nodeId;

            // Redraw the canvas
            redrawCanvasForState(canvas, window.currentCanvasState);
        };

        // Update modal for n-ary branch configuration
        window.updateModalBranchConfig = function(branchCount) {
            const count = parseInt(branchCount) || 2;
            console.log('Updating modal for', count, 'branches');

            // Update threshold inputs for n-ary
            const thresholdDiv = document.getElementById('modal-thresholds');
            if (thresholdDiv) {
                let html = '';
                if (count > 2) {
                    html = '<label style="margin-top: 10px;">Branch Thresholds (n-ary):</label><div style="display: flex; flex-wrap: wrap; gap: 10px;">';
                    for (let i = 0; i < count - 1; i++) {
                        html += `<input type="number" id="modal-threshold-${i}" placeholder="Threshold ${i+1}" style="width: 100px; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">`;
                    }
                    html += '</div>';
                }
                thresholdDiv.innerHTML = html;
            }

            // Update branch labels
            const labelsDiv = document.getElementById('modal-branch-labels');
            if (labelsDiv) {
                let html = '<label style="margin-top: 10px;">Branch Labels:</label><div style="display: flex; flex-direction: column; gap: 5px;">';
                for (let i = 0; i < count; i++) {
                    const defaultLabel = count === 2 ? (i === 0 ? 'False' : 'True') :
                                        count === 3 ? ['Low', 'Medium', 'High'][i] :
                                        `Branch ${i + 1}`;
                    html += `<input type="text" id="modal-branch-label-${i}" placeholder="Label ${i+1}" value="${defaultLabel}" style="padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">`;
                }
                html += '</div>';
                labelsDiv.innerHTML = html;
            }
        };

        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Initializing Advanced Tree Logic Integration...');

            // Initialize hamburger menu
            const hamburgerMenu = document.getElementById('hamburgerMenu');
            const navPanel = document.getElementById('navPanel');
            const navOverlay = document.getElementById('navOverlay');

            if (hamburgerMenu) {
                hamburgerMenu.addEventListener('click', function() {
                    navPanel.classList.toggle('active');
                    navOverlay.classList.toggle('active');
                    hamburgerMenu.classList.toggle('active');
                });
                console.log('‚úÖ Hamburger menu initialized');
            }

            if (navOverlay) {
                navOverlay.addEventListener('click', function() {
                    navPanel.classList.remove('active');
                    navOverlay.classList.remove('active');
                    hamburgerMenu.classList.remove('active');
                });
            }

            // Initialize crypt.js if available
            if (typeof crypt !== 'undefined' && crypt.init) {
                try {
                    await crypt.init();
                    window.cryptReady = true;
                    console.log('‚úÖ Crypt.js initialized');
                } catch (error) {
                    console.warn('Could not initialize crypt.js:', error);
                    window.cryptReady = false;
                }
            }

            // Initialize advanced logic - always enabled
            initializeAdvancedLogic();

            // Initialize canvas interactions
            initializeCanvas();

            // Render initial canvas after a short delay
            setTimeout(() => {
                renderCanvasNodes();
            }, 500);

            // Set advanced features as enabled
            if (!window.AdvancedTreeLogic) {
                window.AdvancedTreeLogic = {};
            }
            window.AdvancedTreeLogic.enabled = true;

            // Show advanced controls in all layers
            document.querySelectorAll('.layer-advanced-controls').forEach(control => {
                control.style.display = 'block';
            });
        });
        // Expose functions globally for HTML event handlers
        window.setGateType = setGateType;
        window.setLogicGate = setGateType; // Alias for consistency
        window.updateBranchCount = updateBranchCount;
        window.updateFuzzyThreshold = updateFuzzyThreshold;
        window.updateTNorm = updateTNorm;
        window.toggleAdvancedPanel = toggleAdvancedPanel;
        window.closeAdvancedLogicPopup = function() {
            document.getElementById('advanced-logic-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
        };

        // Function to open and populate Advanced Logic popup with node-specific data
        // Removed duplicate openAdvancedLogicPopup function
        // The primary implementation is at line 7841 which sends messages to React modal

        // Keep a stub for toggleAdvancedFeatures in case it's called elsewhere
        window.toggleAdvancedFeatures = function(enabled) {
            console.log('Advanced features are always enabled');
            return true;
        };

        // Function to update modal based on node type
        window.updateModalNodeType = function(nodeType) {
            // Hide all option sections
            const gateOptions = document.getElementById('modal-logic-gate-options');
            const fuzzyOptions = document.getElementById('modal-fuzzy-logic-options');
            const probOptions = document.getElementById('modal-probabilistic-options');

            if (gateOptions) gateOptions.style.display = 'none';
            if (fuzzyOptions) fuzzyOptions.style.display = 'none';
            if (probOptions) probOptions.style.display = 'none';

            // Show relevant section
            switch(nodeType) {
                case 'logic_gate':
                    if (gateOptions) gateOptions.style.display = 'block';
                    break;
                case 'fuzzy_logic':
                    if (fuzzyOptions) fuzzyOptions.style.display = 'block';
                    break;
                case 'probabilistic':
                    if (probOptions) probOptions.style.display = 'block';
                    break;
            }
        };

        window.AdvancedTreeLogicIntegration = {
            initialize: initializeAdvancedLogic,
            enhance: enhanceExistingTree,
            togglePanel: toggleAdvancedPanel,
            setGateType: setGateType,
            updateBranchCount: updateBranchCount,
            evaluateWithLogic: window.evaluateWithAdvancedLogic,
            toggleFeatures: toggleAdvancedFeatures
        };
    </script>
<script type="text/template" id="advanced-ui-template">
<script type="text/template" id="advanced-ui-template">
                            <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.05), rgba(99, 102, 241, 0.05)); border-radius: 8px; padding: 10px; margin: 10px 0;">

                                <!-- Custom Scale for this Node -->
                                <div style="margin-bottom: 10px; padding: 8px; background: rgba(255, 255, 255, 0.5); border-radius: 6px;">
                                    <label style="font-weight: 600; color: #6366F1;">Custom Scale Range (optional):</label>
                                    <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
                                        <input type="number" id="node-scale-min-${node.id}"
                                               controls="${currentScaleMin}"
                                               value="${node.scaleMin || \'\'}"
                                               onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {scaleMin: parseFloat(this.value) || currentScaleMin})"
                                               style="flex: 1; padding: 6px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 6px;">
                                        <span>to</span>
                                        <input type="number" id="node-scale-max-${node.id}"
                                               controls="${currentScaleMax}"
                                               value="${node.scaleMax || \'\'}"
                                               onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {scaleMax: parseFloat(this.value) || currentScaleMax})"
                                               style="flex: 1; padding: 6px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 6px;">
                                        <button onclick="updateNodeScaleRange(\'${node.id}\')"
                                                style="padding: 6px 12px; background: #6366F1; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                            Apply
                                        </button>
                                    </div>
                                </div>

                                <label style="font-weight: 600; color: #6366F1;">Node Type:</label>
                                <select id="node-type-${node.id}" onchange="updateNodeTypeInLayer(\'${node.id}\', this.value)" style="width: 100%; margin-bottom: 8px; padding: 6px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 6px;">
                                    <option value="decision" ${node.nodeType === \'decision\' ? \'selected\' : \'\'}>Decision Node</option>
                                    <option value="logic_gate" ${node.nodeType === \'logic_gate\' ? \'selected\' : \'\'}>Logic Gate</option>
                                    <option value="fuzzy_gate" ${node.nodeType === \'fuzzy_gate\' ? \'selected\' : \'\'}>Fuzzy Logic</option>
                                    <option value="probabilistic" ${node.nodeType === \'probabilistic\' ? \'selected\' : \'\'}>Probabilistic</option>
                                </select>

                                <div id="gate-options-${node.id}" style="display: ${node.nodeType === \'logic_gate\' ? \'block\' : \'none\'};">
                                    <label style="font-weight: 600; margin-bottom: 5px; display: block;">Logic Gate Configuration:</label>

                                    <!-- Gate Type Selection -->
                                    <label style="font-size: 12px;">Gate Type:</label>
                                    <select id="gate-type-${node.id}" onchange="updateGateTypeForNode(\'${node.id}\', this.value)" style="width: 100%; padding: 6px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 6px; margin-bottom: 8px;">
                                        <option value="and" ${node.logicType === \'and\' ? \'selected\' : \'\'}>AND - All inputs must be true</option>
                                        <option value="or" ${node.logicType === \'or\' ? \'selected\' : \'\'}>OR - At least one input must be true</option>
                                        <option value="not" ${node.logicType === \'not\' ? \'selected\' : \'\'}>NOT - Inverts single input</option>
                                        <option value="nand" ${node.logicType === \'nand\' ? \'selected\' : \'\'}>NAND - NOT(AND)</option>
                                        <option value="nor" ${node.logicType === \'nor\' ? \'selected\' : \'\'}>NOR - NOT(OR)</option>
                                        <option value="xor" ${node.logicType === \'xor\' ? \'selected\' : \'\'}>XOR - Odd number of true inputs</option>
                                        <option value="xnor" ${node.logicType === \'xnor\' ? \'selected\' : \'\'}>XNOR - Even number of true inputs</option>
                                        <option value="majority" ${node.logicType === \'majority\' ? \'selected\' : \'\'}>MAJORITY - More than half inputs true</option>
                                        <option value="threshold" ${node.logicType === \'threshold\' ? \'selected\' : \'\'}>THRESHOLD - K of N inputs true</option>
                                        <option value="custom" ${node.logicType === \'custom\' ? \'selected\' : \'\'}>CUSTOM - Truth table</option>
                                    </select>

                                    <!-- Continuous Domain Support -->
                                    <div style="background: rgba(255, 255, 255, 0.5); padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                                        <label style="display: flex; align-items: center; font-size: 12px;">
                                            <input type="checkbox" id="continuous-domain-${node.id}"
                                                   ${node.continuousDomain ? \'checked\' : \'\'}
                                                   onchange="toggleContinuousDomain(\'${node.id}\', this.checked)"
                                                   style="margin-right: 5px;">
                                            Enable Continuous Domain (0-1 values instead of binary)
                                        </label>
                                    </div>

                                    <!-- Threshold Configuration (for threshold gate) -->
                                    <div id="threshold-config-${node.id}" style="display: ${node.logicType === \'threshold\' ? \'block\' : \'none\'}; padding: 8px; background: rgba(255, 255, 255, 0.3); border-radius: 6px; margin-bottom: 8px;">
                                        <label style="font-size: 12px;">Threshold K (minimum true inputs):</label>
                                        <input type="number" id="threshold-k-${node.id}"
                                               value="${node.thresholdK || 2}"
                                               min="1" step="1"
                                               onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {thresholdK: parseInt(this.value)})"
                                               style="width: 100%; padding: 4px;">
                                    </div>

                                    <!-- Custom Truth Table (for custom gate) -->
                                    <div id="custom-truth-${node.id}" style="display: ${node.logicType === \'custom\' ? \'block\' : \'none\'}; padding: 8px; background: rgba(255, 255, 255, 0.3); border-radius: 6px; margin-bottom: 8px;">
                                        <label style="font-size: 12px; font-weight: 600;">Custom Truth Table:</label>
                                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                                            Define output for each input combination (2^n rows)
                                        </div>
                                        <textarea id="truth-table-${node.id}"
                                                  placeholder="00:0&#10;01:1&#10;10:1&#10;11:0"
                                                  onchange="updateCustomTruthTable(\'${node.id}\', this.value)"
                                                  style="width: 100%; height: 80px; padding: 4px; font-family: monospace; font-size: 11px;">${node.truthTable || \'\'}</textarea>
                                    </div>

                                    <!-- Input Scale Range (for continuous domain) -->
                                    <div id="gate-scale-${node.id}" style="display: ${node.continuousDomain ? \'block\' : \'none\'}; padding: 8px; background: rgba(255, 255, 255, 0.3); border-radius: 6px;">
                                        <label style="font-size: 12px; font-weight: 600;">Input Value Range:</label>
                                        <div style="display: flex; gap: 5px; align-items: center;">
                                            <input type="number" id="gate-scale-min-${node.id}"
                                                   value="${node.gateScaleMin || 0}"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {gateScaleMin: parseFloat(this.value)})"
                                                   style="flex: 1; padding: 4px;"
                                                   placeholder="Min">
                                            <span>to</span>
                                            <input type="number" id="gate-scale-max-${node.id}"
                                                   value="${node.gateScaleMax || 1}"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {gateScaleMax: parseFloat(this.value)})"
                                                   style="flex: 1; padding: 4px;"
                                                   placeholder="Max">
                                        </div>
                                        <label style="font-size: 11px; margin-top: 5px;">Threshold for True (continuous):</label>
                                        <input type="number" id="gate-threshold-${node.id}"
                                               value="${node.gateThreshold || 0.5}"
                                               min="0" max="1" step="0.01"
                                               onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {gateThreshold: parseFloat(this.value)})"
                                               style="width: 100%; padding: 4px;">
                                    </div>
                                </div>

                                <div id="fuzzy-options-${node.id}" style="display: ${node.nodeType === \'fuzzy_gate\' ? \'block\' : \'none\'};">
                                    <label style="font-weight: 600; margin-bottom: 5px; display: block;">Fuzzy Logic Configuration:</label>

                                    <!-- Fuzzy Operation Selection -->
                                    <label style="font-size: 12px;">Fuzzy Operation Type:</label>
                                    <select id="fuzzy-op-${node.id}" onchange="updateFuzzyOperation(\'${node.id}\', this.value)" style="width: 100%; padding: 6px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 6px; margin-bottom: 8px;">
                                        <!-- T-norm Operations (AND-like) -->
                                        <optgroup label="T-norms (Fuzzy AND)">
                                            <option value="fuzzy_min" ${node.logicType === \'fuzzy_min\' ? \'selected\' : \'\'}>Zadeh Minimum - min(a,b)</option>
                                            <option value="fuzzy_product" ${node.logicType === \'fuzzy_product\' ? \'selected\' : \'\'}>Algebraic Product - a√ób</option>
                                            <option value="fuzzy_lukasiewicz_and" ${node.logicType === \'fuzzy_lukasiewicz_and\' ? \'selected\' : \'\'}>Lukasiewicz T-norm - max(0, a+b-1)</option>
                                            <option value="fuzzy_drastic_and" ${node.logicType === \'fuzzy_drastic_and\' ? \'selected\' : \'\'}>Drastic Product - min when max(a,b)=1, else 0</option>
                                            <option value="fuzzy_nilpotent_min" ${node.logicType === \'fuzzy_nilpotent_min\' ? \'selected\' : \'\'}>Nilpotent Minimum - min if a+b>1, else 0</option>
                                            <option value="fuzzy_hamacher_product" ${node.logicType === \'fuzzy_hamacher_product\' ? \'selected\' : \'\'}>Hamacher Product - ab/(a+b-ab)</option>
                                        </optgroup>

                                        <!-- S-norm Operations (OR-like) -->
                                        <optgroup label="S-norms (Fuzzy OR)">
                                            <option value="fuzzy_max" ${node.logicType === \'fuzzy_max\' ? \'selected\' : \'\'}>Zadeh Maximum - max(a,b)</option>
                                            <option value="fuzzy_sum" ${node.logicType === \'fuzzy_sum\' ? \'selected\' : \'\'}>Probabilistic Sum - a+b-ab</option>
                                            <option value="fuzzy_lukasiewicz_or" ${node.logicType === \'fuzzy_lukasiewicz_or\' ? \'selected\' : \'\'}>Lukasiewicz S-norm - min(1, a+b)</option>
                                            <option value="fuzzy_drastic_or" ${node.logicType === \'fuzzy_drastic_or\' ? \'selected\' : \'\'}>Drastic Sum - max when min(a,b)=0, else 1</option>
                                            <option value="fuzzy_nilpotent_max" ${node.logicType === \'fuzzy_nilpotent_max\' ? \'selected\' : \'\'}>Nilpotent Maximum - max if a+b<1, else 1</option>
                                            <option value="fuzzy_einstein_sum" ${node.logicType === \'fuzzy_einstein_sum\' ? \'selected\' : \'\'}>Einstein Sum - (a+b)/(1+ab)</option>
                                        </optgroup>

                                        <!-- Averaging Operations -->
                                        <optgroup label="Averaging Operators">
                                            <option value="fuzzy_average" ${node.logicType === \'fuzzy_average\' ? \'selected\' : \'\'}>Arithmetic Mean - (Œ£x)/n</option>
                                            <option value="fuzzy_geometric" ${node.logicType === \'fuzzy_geometric\' ? \'selected\' : \'\'}>Geometric Mean - (Œ†x)^(1/n)</option>
                                            <option value="fuzzy_harmonic" ${node.logicType === \'fuzzy_harmonic\' ? \'selected\' : \'\'}>Harmonic Mean - n/(Œ£(1/x))</option>
                                            <option value="fuzzy_weighted_average" ${node.logicType === \'fuzzy_weighted_average\' ? \'selected\' : \'\'}>Weighted Average - Œ£(w√óx)/Œ£w</option>
                                            <option value="fuzzy_owa" ${node.logicType === \'fuzzy_owa\' ? \'selected\' : \'\'}>OWA (Ordered Weighted Average)</option>
                                            <option value="fuzzy_median" ${node.logicType === \'fuzzy_median\' ? \'selected\' : \'\'}>Median Value</option>
                                        </optgroup>

                                        <!-- Membership Functions -->
                                        <optgroup label="Membership Functions">
                                            <option value="fuzzy_gaussian" ${node.logicType === \'fuzzy_gaussian\' ? \'selected\' : \'\'}>Gaussian - exp(-((x-Œº)/œÉ)¬≤/2)</option>
                                            <option value="fuzzy_sigmoid" ${node.logicType === \'fuzzy_sigmoid\' ? \'selected\' : \'\'}>Sigmoid - 1/(1+exp(-k(x-c)))</option>
                                            <option value="fuzzy_triangular" ${node.logicType === \'fuzzy_triangular\' ? \'selected\' : \'\'}>Triangular - Linear rise/fall</option>
                                            <option value="fuzzy_trapezoidal" ${node.logicType === \'fuzzy_trapezoidal\' ? \'selected\' : \'\'}>Trapezoidal - Flat top triangular</option>
                                            <option value="fuzzy_bell" ${node.logicType === \'fuzzy_bell\' ? \'selected\' : \'\'}>Bell-shaped - 1/(1+|x-c/a|^2b)</option>
                                            <option value="fuzzy_pi" ${node.logicType === \'fuzzy_pi\' ? \'selected\' : \'\'}>Pi-shaped - S(x)√ó(1-S(x))</option>
                                        </optgroup>

                                        <!-- Special Operations -->
                                        <optgroup label="Special Operations">
                                            <option value="fuzzy_not" ${node.logicType === \'fuzzy_not\' ? \'selected\' : \'\'}>Fuzzy NOT - 1-x</option>
                                            <option value="fuzzy_very" ${node.logicType === \'fuzzy_very\' ? \'selected\' : \'\'}>Very (Concentration) - x¬≤</option>
                                            <option value="fuzzy_somewhat" ${node.logicType === \'fuzzy_somewhat\' ? \'selected\' : \'\'}>Somewhat (Dilation) - ‚àöx</option>
                                            <option value="fuzzy_threshold" ${node.logicType === \'fuzzy_threshold\' ? \'selected\' : \'\'}>Alpha-cut Threshold</option>
                                            <option value="fuzzy_custom" ${node.logicType === \'fuzzy_custom\' ? \'selected\' : \'\'}>Custom Formula</option>
                                        </optgroup>
                                    </select>

                                    <!-- Continuous Domain Support for Fuzzy Logic -->
                                    <div style="background: rgba(255, 255, 255, 0.5); padding: 8px; border-radius: 6px; margin: 8px 0;">
                                        <label style="display: flex; align-items: center; font-size: 12px;">
                                            <input type="checkbox" id="fuzzy-continuous-${node.id}"
                                                   ${node.fuzzyContinuous !== false ? \'checked\' : \'\'}
                                                   onchange="toggleFuzzyContinuous(\'${node.id}\', this.checked)"
                                                   style="margin-right: 5px;">
                                            Continuous Domain (Fuzzy values already continuous by default)
                                        </label>

                                        <!-- Fuzzy Value Range -->
                                        <div style="margin-top: 8px;">
                                            <label style="font-size: 11px; font-weight: 600;">Input Value Range:</label>
                                            <div style="display: flex; gap: 5px; align-items: center;">
                                                <input type="number" id="fuzzy-scale-min-${node.id}"
                                                       value="${node.fuzzyScaleMin || 0}"
                                                       onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {fuzzyScaleMin: parseFloat(this.value)})"
                                                       style="flex: 1; padding: 4px;"
                                                       placeholder="Min">
                                                <span>to</span>
                                                <input type="number" id="fuzzy-scale-max-${node.id}"
                                                       value="${node.fuzzyScaleMax || 1}"
                                                       onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {fuzzyScaleMax: parseFloat(this.value)})"
                                                       style="flex: 1; padding: 4px;"
                                                       placeholder="Max">
                                            </div>
                                        </div>

                                        <!-- Defuzzification Method -->
                                        <div style="margin-top: 8px;">
                                            <label style="font-size: 11px; font-weight: 600;">Defuzzification Method:</label>
                                            <select id="defuzz-method-${node.id}"
                                                    onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {defuzzMethod: this.value})"
                                                    style="width: 100%; padding: 4px;">
                                                <option value="centroid" ${node.defuzzMethod === \'centroid\' ? \'selected\' : \'\'}>Centroid (Center of Area)</option>
                                                <option value="bisector" ${node.defuzzMethod === \'bisector\' ? \'selected\' : \'\'}>Bisector (Vertical Line)</option>
                                                <option value="mom" ${node.defuzzMethod === \'mom\' ? \'selected\' : \'\'}>Mean of Maximum</option>
                                                <option value="som" ${node.defuzzMethod === \'som\' ? \'selected\' : \'\'}>Smallest of Maximum</option>
                                                <option value="lom" ${node.defuzzMethod === \'lom\' ? \'selected\' : \'\'}>Largest of Maximum</option>
                                                <option value="weighted" ${node.defuzzMethod === \'weighted\' ? \'selected\' : \'\'}>Weighted Average</option>
                                            </select>
                                        </div>
                                    </div>

                                    <!-- Gaussian/Sigmoid Parameters -->
                                    <div id="fuzzy-params-${node.id}" style="display: ${node.logicType === \'fuzzy_gaussian\' || node.logicType === \'fuzzy_sigmoid\' ? \'block\' : \'none\'}; padding: 8px; background: rgba(255, 255, 255, 0.5); border-radius: 6px;">
                                        <div style="display: ${node.logicType === \'fuzzy_gaussian\' ? \'block\' : \'none\'};">
                                            <label style="font-size: 12px;">Gaussian Mean (Œº):</label>
                                            <input type="number" id="gaussian-mean-${node.id}"
                                                   value="${node.gaussianMean || ((node.scaleMin || currentScaleMin) + (node.scaleMax || currentScaleMax)) / 2}"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {gaussianMean: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px; margin-bottom: 5px;">
                                            <label style="font-size: 12px;">Standard Deviation (œÉ):</label>
                                            <input type="number" id="gaussian-std-${node.id}"
                                                   value="${node.gaussianStd || ((node.scaleMax || currentScaleMax) - (node.scaleMin || currentScaleMin)) / 6}"
                                                   step="0.1"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {gaussianStd: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>
                                        <div style="display: ${node.logicType === \'fuzzy_sigmoid\' ? \'block\' : \'none\'};">
                                            <label style="font-size: 12px;">Sigmoid Center:</label>
                                            <input type="number" id="sigmoid-center-${node.id}"
                                                   value="${node.sigmoidCenter || ((node.scaleMin || currentScaleMin) + (node.scaleMax || currentScaleMax)) / 2}"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {sigmoidCenter: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px; margin-bottom: 5px;">
                                            <label style="font-size: 12px;">Steepness (k):</label>
                                            <input type="number" id="sigmoid-k-${node.id}"
                                                   value="${node.sigmoidK || 1}"
                                                   step="0.1"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {sigmoidK: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>
                                    </div>

                                    <!-- Statistical Rigor Controls -->
                                    <div style="margin-top: 10px; padding: 8px; background: rgba(255, 255, 255, 0.3); border-radius: 6px;">
                                        <label style="font-size: 12px; font-weight: 600; display: block; margin-bottom: 5px;">Statistical Significance:</label>

                                        <label style="font-size: 11px;">P-value Threshold (Œ±):</label>
                                        <input type="number" id="p-threshold-${node.id}"
                                               value="${node.pThreshold || 0.05}"
                                               min="0.0001" max="1" step="0.001"
                                               onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {pThreshold: parseFloat(this.value)})"
                                               style="width: 100%; padding: 4px; margin-bottom: 5px;">

                                        <label style="font-size: 11px;">Confidence Level:</label>
                                        <select id="confidence-${node.id}"
                                                onchange="updateConfidenceLevel(\'${node.id}\', this.value)"
                                                style="width: 100%; padding: 4px; margin-bottom: 5px;">
                                            <option value="0.90" ${node.confidenceLevel == 0.90 ? \'selected\' : \'\'}>90%</option>
                                            <option value="0.95" ${node.confidenceLevel == 0.95 ? \'selected\' : \'\'}>95%</option>
                                            <option value="0.99" ${node.confidenceLevel == 0.99 ? \'selected\' : \'\'}>99%</option>
                                            <option value="0.999" ${node.confidenceLevel == 0.999 ? \'selected\' : \'\'}>99.9%</option>
                                            <option value="custom">Custom</option>
                                        </select>

                                        <div id="custom-confidence-${node.id}" style="display: ${node.confidenceLevel === \'custom\' ? \'block\' : \'none\'};">
                                            <input type="number"
                                                   placeholder="Enter confidence (0-1)"
                                                   min="0" max="1" step="0.001"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {confidenceLevel: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>

                                        <label style="font-size: 11px;">Statistical Test:</label>
                                        <select id="stat-test-${node.id}"
                                                onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {statTest: this.value})"
                                                style="width: 100%; padding: 4px; margin-bottom: 5px;">
                                            <option value="none" ${!node.statTest ? \'selected\' : \'\'}>None</option>
                                            <option value="z-test" ${node.statTest === \'z-test\' ? \'selected\' : \'\'}>Z-test</option>
                                            <option value="t-test" ${node.statTest === \'t-test\' ? \'selected\' : \'\'}>T-test</option>
                                            <option value="chi-square" ${node.statTest === \'chi-square\' ? \'selected\' : \'\'}>Chi-square</option>
                                            <option value="f-test" ${node.statTest === \'f-test\' ? \'selected\' : \'\'}>F-test</option>
                                            <option value="mann-whitney" ${node.statTest === \'mann-whitney\' ? \'selected\' : \'\'}>Mann-Whitney U</option>
                                            <option value="wilcoxon" ${node.statTest === \'wilcoxon\' ? \'selected\' : \'\'}>Wilcoxon Signed-Rank</option>
                                            <option value="kruskal-wallis" ${node.statTest === \'kruskal-wallis\' ? \'selected\' : \'\'}>Kruskal-Wallis</option>
                                        </select>

                                        <label style="font-size: 11px;">Critical Value Method:</label>
                                        <select id="critical-method-${node.id}"
                                                onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {criticalMethod: this.value})"
                                                style="width: 100%; padding: 4px;">
                                            <option value="auto" ${!node.criticalMethod || node.criticalMethod === \'auto\' ? \'selected\' : \'\'}>Auto-calculate</option>
                                            <option value="manual" ${node.criticalMethod === \'manual\' ? \'selected\' : \'\'}>Manual Input</option>
                                            <option value="percentile" ${node.criticalMethod === \'percentile\' ? \'selected\' : \'\'}>Percentile-based</option>
                                            <option value="bonferroni" ${node.criticalMethod === \'bonferroni\' ? \'selected\' : \'\'}>Bonferroni Correction</option>
                                            <option value="fdr" ${node.criticalMethod === \'fdr\' ? \'selected\' : \'\'}>False Discovery Rate</option>
                                        </select>

                                        <div id="critical-value-${node.id}" style="display: ${node.criticalMethod === \'manual\' ? \'block\' : \'none\'}; margin-top: 5px;">
                                            <label style="font-size: 11px;">Critical Value:</label>
                                            <input type="number"
                                                   placeholder="Enter critical value"
                                                   step="0.001"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {criticalValue: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>
                                    </div>
                                </div>

                                <!-- Probabilistic Options Section -->
                                <div id="prob-options-${node.id}" style="display: ${node.nodeType === \'probabilistic\' ? \'block\' : \'none\'};">
                                    <label style="font-weight: 600; margin-bottom: 5px; display: block;">Probabilistic Node Configuration:</label>

                                    <!-- Probability Distribution Type -->
                                    <label style="font-size: 12px;">Probability Distribution:</label>
                                    <select id="prob-dist-${node.id}" onchange="updateProbabilityDistribution(\'${node.id}\', this.value)" style="width: 100%; padding: 6px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 6px; margin-bottom: 8px;">
                                        <!-- Discrete Distributions -->
                                        <optgroup label="Discrete Distributions">
                                            <option value="bernoulli" ${node.probabilityType === \'bernoulli\' ? \'selected\' : \'\'}>Bernoulli - Binary outcome (p, 1-p)</option>
                                            <option value="binomial" ${node.probabilityType === \'binomial\' ? \'selected\' : \'\'}>Binomial - n trials, probability p</option>
                                            <option value="multinomial" ${node.probabilityType === \'multinomial\' ? \'selected\' : \'\'}>Multinomial - Multiple outcomes</option>
                                            <option value="poisson" ${node.probabilityType === \'poisson\' ? \'selected\' : \'\'}>Poisson - Rate Œª events</option>
                                            <option value="geometric" ${node.probabilityType === \'geometric\' ? \'selected\' : \'\'}>Geometric - First success</option>
                                            <option value="hypergeometric" ${node.probabilityType === \'hypergeometric\' ? \'selected\' : \'\'}>Hypergeometric - Without replacement</option>
                                            <option value="negative_binomial" ${node.probabilityType === \'negative_binomial\' ? \'selected\' : \'\'}>Negative Binomial - r successes</option>
                                        </optgroup>

                                        <!-- Continuous Distributions -->
                                        <optgroup label="Continuous Distributions">
                                            <option value="gaussian" ${node.probabilityType === \'gaussian\' ? \'selected\' : \'\'}>Gaussian/Normal - N(Œº, œÉ¬≤)</option>
                                            <option value="uniform" ${node.probabilityType === \'uniform\' ? \'selected\' : \'\'}>Uniform - Equal probability [a,b]</option>
                                            <option value="exponential" ${node.probabilityType === \'exponential\' ? \'selected\' : \'\'}>Exponential - Rate Œª decay</option>
                                            <option value="beta" ${node.probabilityType === \'beta\' ? \'selected\' : \'\'}>Beta - Shape Œ±, Œ≤ on [0,1]</option>
                                            <option value="gamma" ${node.probabilityType === \'gamma\' ? \'selected\' : \'\'}>Gamma - Shape k, scale Œ∏</option>
                                            <option value="chi_squared" ${node.probabilityType === \'chi_squared\' ? \'selected\' : \'\'}>Chi-Squared - k degrees freedom</option>
                                            <option value="student_t" ${node.probabilityType === \'student_t\' ? \'selected\' : \'\'}>Student\'s t - ŒΩ degrees freedom</option>
                                            <option value="f_dist" ${node.probabilityType === \'f_dist\' ? \'selected\' : \'\'}>F-Distribution - d‚ÇÅ, d‚ÇÇ degrees</option>
                                            <option value="lognormal" ${node.probabilityType === \'lognormal\' ? \'selected\' : \'\'}>Log-Normal - ln(X) ~ N(Œº, œÉ¬≤)</option>
                                            <option value="weibull" ${node.probabilityType === \'weibull\' ? \'selected\' : \'\'}>Weibull - Shape k, scale Œª</option>
                                            <option value="cauchy" ${node.probabilityType === \'cauchy\' ? \'selected\' : \'\'}>Cauchy - Location x‚ÇÄ, scale Œ≥</option>
                                            <option value="laplace" ${node.probabilityType === \'laplace\' ? \'selected\' : \'\'}>Laplace - Location Œº, scale b</option>
                                            <option value="pareto" ${node.probabilityType === \'pareto\' ? \'selected\' : \'\'}>Pareto - Scale x‚Çò, shape Œ±</option>
                                        </optgroup>

                                        <!-- Mixed/Special -->
                                        <optgroup label="Special Distributions">
                                            <option value="mixture" ${node.probabilityType === \'mixture\' ? \'selected\' : \'\'}>Mixture Model - Multiple components</option>
                                            <option value="empirical" ${node.probabilityType === \'empirical\' ? \'selected\' : \'\'}>Empirical - From data</option>
                                            <option value="custom" ${node.probabilityType === \'custom\' ? \'selected\' : \'\'}>Custom - User-defined</option>
                                        </optgroup>
                                    </select>

                                    <!-- Continuous Domain Support -->
                                    <div style="background: rgba(255, 255, 255, 0.5); padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                                        <label style="display: flex; align-items: center; font-size: 12px;">
                                            <input type="checkbox" id="prob-continuous-${node.id}"
                                                   ${node.continuousProbability ? \'checked\' : \'\'}
                                                   onchange="toggleContinuousProbability(\'${node.id}\', this.checked)"
                                                   style="margin-right: 5px;">
                                            Enable Continuous Domain (Use continuous distributions)
                                        </label>

                                        <div id="cont-prob-options-${node.id}" style="display: ${node.continuousProbability ? \'block\' : \'none\'}; margin-top: 8px;">
                                            <label style="font-size: 11px;">Sample Resolution:</label>
                                            <input type="number" id="sample-resolution-${node.id}"
                                                   value="${node.sampleResolution || 1000}"
                                                   min="10" max="100000" step="10"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {sampleResolution: parseInt(this.value)})"
                                                   style="width: 100%; padding: 4px; margin-bottom: 5px;">

                                            <label style="font-size: 11px;">Integration Method:</label>
                                            <select id="integration-method-${node.id}"
                                                    onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {integrationMethod: this.value})"
                                                    style="width: 100%; padding: 4px;">
                                                <option value="monte_carlo" ${node.integrationMethod === \'monte_carlo\' ? \'selected\' : \'\'}>Monte Carlo</option>
                                                <option value="simpson" ${node.integrationMethod === \'simpson\' ? \'selected\' : \'\'}>Simpson\'s Rule</option>
                                                <option value="trapezoidal" ${node.integrationMethod === \'trapezoidal\' ? \'selected\' : \'\'}>Trapezoidal Rule</option>
                                                <option value="gaussian_quadrature" ${node.integrationMethod === \'gaussian_quadrature\' ? \'selected\' : \'\'}>Gaussian Quadrature</option>
                                            </select>
                                        </div>
                                    </div>

                                    <!-- Distribution Parameters -->
                                    <div id="dist-params-${node.id}" style="padding: 8px; background: rgba(255, 255, 255, 0.3); border-radius: 6px; margin-bottom: 8px;">
                                        <!-- Gaussian Parameters -->
                                        <div style="display: ${node.probabilityType === \'gaussian\' ? \'block\' : \'none\'};">
                                            <label style="font-size: 12px;">Mean (Œº):</label>
                                            <input type="number" id="prob-mean-${node.id}"
                                                   value="${node.probMean || 0}"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {probMean: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px; margin-bottom: 5px;">
                                            <label style="font-size: 12px;">Standard Deviation (œÉ):</label>
                                            <input type="number" id="prob-std-${node.id}"
                                                   value="${node.probStd || 1}"
                                                   min="0.001" step="0.1"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {probStd: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>

                                        <!-- Beta Parameters -->
                                        <div style="display: ${node.probabilityType === \'beta\' ? \'block\' : \'none\'};">
                                            <label style="font-size: 12px;">Alpha (Œ±):</label>
                                            <input type="number" id="beta-alpha-${node.id}"
                                                   value="${node.betaAlpha || 2}"
                                                   min="0.001" step="0.1"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {betaAlpha: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px; margin-bottom: 5px;">
                                            <label style="font-size: 12px;">Beta (Œ≤):</label>
                                            <input type="number" id="beta-beta-${node.id}"
                                                   value="${node.betaBeta || 2}"
                                                   min="0.001" step="0.1"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {betaBeta: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>

                                        <!-- Uniform Parameters -->
                                        <div style="display: ${node.probabilityType === \'uniform\' ? \'block\' : \'none\'};">
                                            <label style="font-size: 12px;">Lower Bound (a):</label>
                                            <input type="number" id="uniform-a-${node.id}"
                                                   value="${node.uniformA || 0}"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {uniformA: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px; margin-bottom: 5px;">
                                            <label style="font-size: 12px;">Upper Bound (b):</label>
                                            <input type="number" id="uniform-b-${node.id}"
                                                   value="${node.uniformB || 1}"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {uniformB: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>

                                        <!-- Exponential/Poisson Rate -->
                                        <div style="display: ${[\'exponential\', \'poisson\'].includes(node.probabilityType) ? \'block\' : \'none\'};">
                                            <label style="font-size: 12px;">Rate (Œª):</label>
                                            <input type="number" id="rate-lambda-${node.id}"
                                                   value="${node.rateLambda || 1}"
                                                   min="0.001" step="0.1"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {rateLambda: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>

                                        <!-- Binomial Parameters -->
                                        <div style="display: ${node.probabilityType === \'binomial\' ? \'block\' : \'none\'};">
                                            <label style="font-size: 12px;">Number of Trials (n):</label>
                                            <input type="number" id="binomial-n-${node.id}"
                                                   value="${node.binomialN || 10}"
                                                   min="1" step="1"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {binomialN: parseInt(this.value)})"
                                                   style="width: 100%; padding: 4px; margin-bottom: 5px;">
                                            <label style="font-size: 12px;">Probability (p):</label>
                                            <input type="number" id="binomial-p-${node.id}"
                                                   value="${node.binomialP || 0.5}"
                                                   min="0" max="1" step="0.01"
                                                   onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {binomialP: parseFloat(this.value)})"
                                                   style="width: 100%; padding: 4px;">
                                        </div>
                                    </div>

                                    <!-- Custom Distribution -->
                                    <div id="custom-dist-${node.id}" style="display: ${node.probabilityType === \'custom\' ? \'block\' : \'none\'}; padding: 8px; background: rgba(255, 255, 255, 0.3); border-radius: 6px;">
                                        <label style="font-size: 12px; font-weight: 600;">Custom Probability Distribution:</label>
                                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                                            Enter probabilities for each branch (must sum to 1.0)
                                        </div>
                                        <textarea id="custom-probs-${node.id}"
                                                  placeholder="0.3&#10;0.5&#10;0.2"
                                                  onchange="updateCustomProbabilities(\'${node.id}\', this.value)"
                                                  style="width: 100%; height: 60px; padding: 4px; font-family: monospace; font-size: 11px;">${node.customProbs || \'\'}</textarea>
                                    </div>

                                    <!-- Sampling Method -->
                                    <div style="margin-top: 8px;">
                                        <label style="font-size: 12px;">Sampling Method:</label>
                                        <select id="sampling-method-${node.id}"
                                                onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {samplingMethod: this.value})"
                                                style="width: 100%; padding: 4px;">
                                            <option value="inverse_transform" ${node.samplingMethod === \'inverse_transform\' ? \'selected\' : \'\'}>Inverse Transform</option>
                                            <option value="rejection" ${node.samplingMethod === \'rejection\' ? \'selected\' : \'\'}>Rejection Sampling</option>
                                            <option value="metropolis" ${node.samplingMethod === \'metropolis\' ? \'selected\' : \'\'}>Metropolis-Hastings</option>
                                            <option value="gibbs" ${node.samplingMethod === \'gibbs\' ? \'selected\' : \'\'}>Gibbs Sampling</option>
                                            <option value="importance" ${node.samplingMethod === \'importance\' ? \'selected\' : \'\'}>Importance Sampling</option>
                                        </select>
                                    </div>
                                </div>

                                <label>Branch Count:</label>
                                <input type="number" id="branches-${node.id}" min="2" max="16" value="${node.branchCount || 2}"
                                    onchange="updateNodeBranches(\'${node.id}\', this.value)"
                                    style="width: 100%; padding: 6px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 6px;">
                            </div>

                            <label>Default Score (${currentScaleMin} to ${currentScaleMax}) for testing:</label>
                            <input type="number" min="${currentScaleMin}" max="${currentScaleMax}" step="${allowDecimals ? \'0.1\' : \'1\'}" value="${node.score || ((currentScaleMin + currentScaleMax) / 2)}"
                                onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {score: parseFloat(this.value)})">

                            <label>Threshold Mode:</label>
                            <select id="threshold-mode-${node.id}" onchange="updateThresholdMode(\'${node.id}\', this.value)">
                                <option value="manual" ${node.thresholdMode === \'manual\' ? \'selected\' : \'\'}>Manual</option>
                                <option value="mean" ${node.thresholdMode === \'mean\' ? \'selected\' : \'\'}>Mean of Responses</option>
                                <option value="median" ${node.thresholdMode === \'median\' ? \'selected\' : \'\'}>Median of Responses</option>
                                <option value="percentile" ${node.thresholdMode === \'percentile\' ? \'selected\' : \'\'}>Percentile (75th)</option>
                            </select>

                            <div id="thresholds-container-${node.id}">
                                ${node.branchCount && node.branchCount > 2 ?
                                    this.renderMultipleThresholds(node) :
                                    `<label>Threshold (triggers right branch if score ‚â• threshold):</label>
                                    <input type="number" id="threshold-value-${node.id}" min="${currentScaleMin}" max="${currentScaleMax}" step="${allowDecimals ? \'0.1\' : \'1\'}"
                                        value="${node.threshold}" ${node.thresholdMode !== \'manual\' ? \'disabled\' : \'\'}
                                        onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {threshold: parseFloat(this.value)})">`
                                }
                            </div>
                            ${node.thresholdMode !== \'manual\' ? `<small style="color: var(--gsu-primary);\">Auto-calculated: ${node.threshold ? node.threshold.toFixed(2) : \'N/A\'}</small>` : \'\'}

                            ${index > 0 ? this.renderBranchConnections(node, index, parentOptions) : \'<label style="font-weight: 600; color: var(--gsu-primary);\">Root Node</label>\'}
                            <label>Terminal Node:</label>
                            <input type="checkbox" ${node.isTerminal ? \'checked\' : \'\'}
                                onchange="treeBuilder.updateNodeProperties(\'${node.id}\', {isTerminal: this.checked})">
                            <button class="remove-node-btn" onclick="treeBuilder.removeNode('${node.id}')">Remove</button>
                        </div>
                    </div>
                `;

                layerDiv.appendChild(nodeDiv);
            });

            container.appendChild(layerDiv);
        });
    }
}
</script>